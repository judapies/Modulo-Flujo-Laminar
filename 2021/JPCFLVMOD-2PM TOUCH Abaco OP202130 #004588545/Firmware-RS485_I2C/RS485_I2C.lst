CCS PCH C Compiler, Version 4.104, 5967               26-feb.-21 07:41

               Filename: D:\Laboratorio\Modulo Flujo Laminar\2021\JPCFLVMOD-2PM TOUCH Abaco OP202130 #0045884XX\Firmware-RS485_I2C\RS485_I2C.lst

               ROM used: 2840 bytes (9%)
                         Largest free fragment is 29924
               RAM used: 1275 (62%) at main() level
                         1292 (63%) worst case
               Stack:    9 worst case (6 in main + 3 for interrupts)

*
0000:  GOTO   09A2
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  F9D.1
004A:  GOTO   0054
004E:  BTFSC  F9E.1
0050:  GOTO   0304
0054:  BTFSS  F9D.5
0056:  GOTO   0060
005A:  BTFSC  F9E.5
005C:  GOTO   038A
0060:  BTFSS  F9D.3
0062:  GOTO   006C
0066:  BTFSC  F9E.3
0068:  GOTO   0408
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
.................... // Cuatro pulsadores de entrada (Derecha, Izquierda, arriba y abajo). 
.................... // Reloj con XT de 4 MHz. 
.................... // Programación para Autoclave con Calderin 
.................... // Tiene Menú:Ciclo: Liquidos, Instrumental suave, Textil Instrumental y Caucho. 
.................... // Tiene 6 niveles programables para desfogue suave. 
.................... // Ing. Juan David Piñeros. 
.................... // JP Inglobal. 2015 
....................  
.................... #include <18F2550.h> 
.................... //////// Standard Header file for the PIC18F2550 device //////////////// 
.................... #device PIC18F2550 
.................... #list 
....................  
.................... #fuses XTPLL,WDT1024,NOPROTECT,NOLVP,NODEBUG,USBDIV,PLL1,CPUDIV4,VREGEN,NOSTVREN,NOPUT,NOCPD,NOWRT,NOIESO,NOFCMEN,NOPBADEN,NOWRTC,NOWRTB,NOEBTR,NOEBTRB,NOCPB,NOXINST,NOBROWNOUT,NOLPT1OSC,NOMCLR 
.................... //#fuses HSPLL,NOWDT,NOPROTECT,NOLVP,NODEBUG,USBDIV,PLL1,CPUDIV1,VREGEN,NOMCLR 
.................... #use delay(clock=16000000) 
*
0548:  MOVLW  04
054A:  MOVLB  5
054C:  SUBWF  x05,F
054E:  BNC   0562
0550:  MOVLW  05
0552:  MOVWF  FEA
0554:  MOVWF  FE9
0556:  MOVF   FEF,W
0558:  BZ    0562
055A:  BRA    055E
055C:  NOP   
055E:  DECFSZ FEF,F
0560:  BRA    055C
0562:  MOVLB  0
0564:  RETLW  00
....................  
.................... #use i2c(slave, slow, sda=PIN_B0, scl=PIN_B1, address=0xB0) 
*
03F0:  MOVF   FC9,W
03F2:  MOVFF  50A,FC9
03F6:  BSF    FC6.4
03F8:  BCF    F9E.3
03FA:  BTFSC  FC7.0
03FC:  BRA    03FA
03FE:  CLRF   01
0400:  BTFSC  FC6.4
0402:  INCF   01,F
0404:  GOTO   043C (RETURN)
....................  
.................... #define   Buzzer_on           output_bit(PIN_A5,1) 
.................... #define   Buzzer_off          output_bit(PIN_A5,0) 
....................  
.................... #define MODBUS_TYPE MODBUS_TYPE_MASTER 
.................... #define MODBUS_SERIAL_TYPE MODBUS_RTU     //use MODBUS_ASCII for ASCII mode 
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE 1023 
.................... #define MODBUS_SERIAL_BAUD 9600 
....................  
.................... #use RS232(BAUD=9600, BITS=8, PARITY=N, XMIT=PIN_B4, RCV=PIN_B5,stream=PC, errors) 
.................... #define MODBUS_SERIAL_INT_SOURCE MODBUS_INT_RDA 
.................... #define MODBUS_SERIAL_TX_PIN PIN_C6   // Data transmit pin 
.................... #define MODBUS_SERIAL_RX_PIN PIN_C7   // Data receive pin 
.................... //The following should be defined for RS485 communication 
.................... #define MODBUS_SERIAL_ENABLE_PIN   PIN_B2   // Controls DE pin for RS485 
.................... #define MODBUS_SERIAL_RX_ENABLE    0   // Controls RE pin for RS485 
.................... #define DEBUG_MSG(msg) fprintf(PC, msg) 
.................... #define DEBUG_DATA(msg,data) fprintf(PC, msg, data) 
....................  
....................  
.................... #include <modbus.c> 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                      modbus.c                                    //// 
.................... ////                                                                                  //// 
.................... ////                 MODBUS protocol driver for serial communications.                //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// DEFINES:                                                                         //// 
.................... ////                                                                                  //// 
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           //// 
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              //// 
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2,   //// 
.................... ////                                   MODBUS_INT_RDA3,MODBUS_INT_RDA4)               //// 
.................... ////  MODBUS_SERIAL_TYPE            MODBUS_RTU or MODBUS_ASCII                        //// 
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        //// 
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      //// 
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     //// 
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           //// 
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       //// 
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        //// 
.................... ////                                                                                  //// 
.................... ////                                                                                  //// 
.................... //// SHARED API:                                                                      //// 
.................... ////                                                                                  //// 
.................... ////  modbus_init()                                                                   //// 
.................... ////    - Initialize modbus serial communication system                               //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_start(address,func)                                          //// 
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data //// 
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_stop()                                                       //// 
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  //// 
.................... ////                                                                                  //// 
.................... ////  modbus_kbhit()                                                                  //// 
.................... ////    - Used to check if a packet has been received.                                //// 
.................... ////                                                                                  //// 
.................... //// MASTER API:                                                                      //// 
.................... ////  All master API functions return 0 on success.                                   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     //// 
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            //// 
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         //// 
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           //// 
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   //// 
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           //// 
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_exception_status(address)                                 //// 
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             //// 
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_counter(address)                                //// 
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_log(address)                                    //// 
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   //// 
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.//// 
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  //// 
.................... ////                    coils.                                                        //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)/// 
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. //// 
.................... ////    - Special Note: values is a pointer to an int8 array                          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_report_slave_id(address)                                       //// 
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  //// 
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 //// 
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)//// 
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,//// 
.................... ////                            write_start,write_quantity, *write_registers_value)   //// 
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          //// 
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////                                                                                  //// 
.................... //// Slave API:                                                                       //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_coils_rsp(address,byte_count,*coil_data)                       //// 
.................... ////    - Wrapper to respond to 0x01(read coils) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_discrete_input_rsp(address,byte_count,*input_data)             //// 
.................... ////    - Wrapper to respond to 0x02(read discret input) in the MODBUS specification. //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_holding_registers_rsp(address,byte_count,*reg_data)            //// 
.................... ////    - Wrapper to respond to 0x03(read holding regs) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_input_registers_rsp(address,byte_count,*input_data)            //// 
.................... ////    - Wrapper to respond to 0x04(read input regs) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_single_coil_rsp(address,output_address,output_value)          //// 
.................... ////    - Wrapper to respond to 0x05(write single coil) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_single_register_rsp(address,reg_address,reg_value)            //// 
.................... ////    - Wrapper to respond to 0x06(write single reg) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_exception_status_rsp(address, data)                            //// 
.................... ////    - Wrapper to respond to 0x07(read void status) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_diagnostics_rsp(address,sub_func,data)                              //// 
.................... ////    - Wrapper to respond to 0x08(diagnostics) in the MODBUS specification.        //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_get_comm_event_counter_rsp(address,status,event_count)              //// 
.................... ////    - Wrapper to respond to 0x0B(get comm event count) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_get_comm_event_log_rsp(address,status,event_count,message_count,    //// 
.................... ////                                   *events, events_len)                           //// 
.................... ////    - Wrapper to respond to 0x0C(get comm event log) in the MODBUS specification. //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_multiple_coils_rsp(address,start_address,quantity)            //// 
.................... ////    - Wrapper to respond to 0x0F(write multiple coils) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_multiple_registers_rsp(address,start_address,quantity)        //// 
.................... ////    - Wrapper to respond to 0x10(write multiple regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_report_slave_id_rsp(address,slave_id,run_status,*data,data_len)     //// 
.................... ////    - Wrapper to respond to 0x11(report slave id) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_file_record_rsp(address,byte_count,*request)                   //// 
.................... ////    - Wrapper to respond to 0x14(read file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_file_record_rsp(address,byte_count,*request)                  //// 
.................... ////    - Wrapper to respond to 0x15(write file record) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_mask_write_register_rsp(address,reference_address,AND_mask,OR_mask) //// 
.................... ////    - Wrapper to respond to 0x16(read coils) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_write_multiple_registers_rsp(address,*data,data_len)           //// 
.................... ////    - Wrapper to respond to 0x17(read write mult regs) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_FIFO_queue_rsp(address,FIFO_len,*data)                         //// 
.................... ////    - Wrapper to respond to 0x18(read FIFO queue) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_exception_rsp(int8 address, int16 func, exception error)            //// 
.................... ////    - Wrapper to send an exception response.  See exception list below.           //// 
.................... ////                                                                                  //// 
.................... //// Exception List:                                                                  //// 
.................... ////  ILLEGAL_FUNCTION, ILLEGAL_DATA_ADDRESS, ILLEGAL_DATA_VALUE,                     //// 
.................... ////  SLAVE_DEVICE_FAILURE, ACKNOWLEDGE, SLAVE_DEVICE_BUSY, MEMORY_PARITY_ERROR,      //// 
.................... ////  GATEWAY_PATH_UNAVAILABLE, GATEWAY_TARGET_NO_RESPONSE                            //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// Revision history:                                                                //// 
.................... ////  May 8, 2009          Made PCD Compatible                                        //// 
.................... ////  August 21, 2009      Added Modbus ASCII protocol                                //// 
.................... ////  September 25, 2009   Fixed Bug in RCV_ON function                               //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2006 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... /*Some defines so we can use identifiers to set things up*/ 
.................... #define MODBUS_TYPE_MASTER 99999 
.................... #define MODBUS_TYPE_SLAVE  88888 
.................... #define MODBUS_INT_RDA     77777 
.................... #define MODBUS_INT_RDA2    66666 
.................... #define MODBUS_INT_RDA3    44444 
.................... #define MODBUS_INT_RDA4    33333 
.................... #define MODBUS_INT_EXT     55555 
.................... #define MODBUS_RTU         1 
.................... #define MODBUS_ASCII       2 
....................  
.................... #ifndef MODBUS_TYPE 
.................... #define MODBUS_TYPE MODBUS_TYPE_MASTER 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_TYPE 
.................... #define MODBUS_SERIAL_TYPE MODBUS_RTU 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_INT_SOURCE 
.................... #define MODBUS_SERIAL_INT_SOURCE MODBUS_INT_RDA    // Select between external interrupt 
.................... #endif                                             // or asynchronous serial interrupt 
....................  
.................... #ifndef MODBUS_SERIAL_BAUD 
.................... #define MODBUS_SERIAL_BAUD 9600 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_RX_PIN 
.................... #define MODBUS_SERIAL_RX_PIN       PIN_C7   // Data receive pin 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_TX_PIN 
.................... #define MODBUS_SERIAL_TX_PIN       PIN_C6   // Data transmit pin 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_ENABLE_PIN 
.................... #define MODBUS_SERIAL_ENABLE_PIN   0   // Controls DE pin.  RX low, TX high. 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_RX_ENABLE 
.................... #define MODBUS_SERIAL_RX_ENABLE    0   // Controls RE pin.  Should keep low. 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_TIMEOUT 
....................    #if (MODBUS_SERIAL_TYPE == MODBUS_ASCII) 
....................       #define MODBUS_SERIAL_TIMEOUT    1000000 
....................    #else 
....................       #define MODBUS_SERIAL_TIMEOUT      10000     //in us 
....................    #endif 
.................... #endif 
....................  
.................... #if( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA ) 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART1, bits=8, stop=1, parity=N, stream=MODBUS_SERIAL, errors) 
*
0336:  BTFSS  F9E.5
0338:  BRA    0336
033A:  MOVFF  FAB,17
033E:  MOVFF  FAE,01
0342:  BTFSS  17.1
0344:  BRA    034A
0346:  BCF    FAB.4
0348:  BSF    FAB.4
034A:  RETLW  00
*
0566:  BTFSS  F9E.4
0568:  BRA    0566
056A:  MOVWF  FAD
056C:  GOTO   0578 (RETURN)
....................    #define RCV_OFF() {disable_interrupts(INT_RDA);} 
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2 ) 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART2, bits=8, stop=1, parity=N, stream=MODBUS_SERIAL, errors) 
....................    #define RCV_OFF() {disable_interrupts(INT_RDA2);} 
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3 ) 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART3, bits=8, stop=1, parity=N, stream=MODBUS_SERIAL, errors) 
....................    #define RCV_OFF() {disable_interrupts(INT_RDA3);} 
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4 ) 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART4, bits=8, stop=1, parity=N, stream=MODBUS_SERIAL, errors) 
....................    #define RCV_OFF() {disable_interrupts(INT_RDA4);} 
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_EXT ) 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, xmit=MODBUS_SERIAL_TX_PIN, rcv=MODBUS_SERIAL_RX_PIN, bits=8, stop=1, parity=N, stream=MODBUS_SERIAL, disable_ints) 
....................    #if defined(__PCD__) 
....................    #define RCV_OFF() {disable_interrupts(INT_EXT0);} 
....................    #else 
....................    #define RCV_OFF() {disable_interrupts(INT_EXT);} 
....................    #endif 
.................... #else 
....................    #error Please define a correct interrupt source 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_RX_BUFFER_SIZE 
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE  64      //size of send/rcv buffer 
.................... #endif 
....................  
.................... #if (MODBUS_TYPE == MODBUS_TYPE_MASTER) 
.................... int32 modbus_serial_wait=MODBUS_SERIAL_TIMEOUT; 
....................  
.................... #define MODBUS_SERIAL_WAIT_FOR_RESPONSE()\ 
.................... {\ 
....................     if(address)\ 
....................     {\ 
....................         while(!modbus_kbhit() && --modbus_serial_wait)\ 
....................             delay_us(1);\ 
....................         if(!modbus_serial_wait)\ 
....................             modbus_rx.error=TIMEOUT;\ 
....................     }\ 
....................     modbus_serial_wait = MODBUS_SERIAL_TIMEOUT;\ 
.................... } 
.................... #endif 
....................  
.................... #if (MODBUS_SERIAL_INT_SOURCE != MODBUS_INT_EXT) 
....................    #if defined(__PCD__) 
....................       #if (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA) 
....................          #word TXSTA=getenv("SFR:U1STA")  
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2) 
....................          #word TXSTA=getenv("SFR:U2STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3) 
....................          #word TXSTA=getenv("SFR:U3STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4) 
....................          #word TXSTA=getenv("SFR:U4STA") 
....................          #bit TRMT=TXSTA.8 
....................       #endif 
....................    #else 
....................       #byte TXSTA=getenv("sfr:TXSTA") 
....................       #bit TRMT=TXSTA.1 
....................    #endif 
....................  
.................... #define WAIT_FOR_HW_BUFFER()\ 
.................... {\ 
....................    while(!TRMT);\ 
.................... }    
.................... #endif 
....................  
.................... int1 modbus_serial_new=0; 
....................  
.................... /******************************************************************** 
.................... These exceptions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to communicate problems with the transmission back 
.................... to the master who can also use these to easily check the exceptions.   
.................... The first exception is the only one that is not part of the protocol  
.................... specification.  The TIMEOUT exception is returned when no slave  
.................... responds to the master's request within the timeout period. 
.................... ********************************************************************/ 
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2,  
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6,  
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11, 
.................... TIMEOUT=12} exception; 
....................  
.................... /******************************************************************** 
.................... These functions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to check the incomming function.  See  
.................... ex_modbus_slave.c for example usage. 
.................... ********************************************************************/ 
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02, 
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04, 
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06, 
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08, 
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C, 
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10, 
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14, 
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16, 
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function; 
....................      
.................... /*Stages of MODBUS reception.  Used to keep our ISR fast enough.*/ 
.................... #if (MODBUS_SERIAL_TYPE==MODBUS_ASCII) 
....................    enum {MODBUS_START=0, MODBUS_GETADDY, MODBUS_GETFUNC, MODBUS_GETDATA, MODBUS_STOP} modbus_serial_state=0; 
.................... #else 
....................    enum {MODBUS_GETADDY=0, MODBUS_GETFUNC=1, MODBUS_GETDATA=2} modbus_serial_state = 0; 
.................... #endif 
....................  
.................... /*Global value holding our current CRC value.*/ 
.................... #if (MODBUS_SERIAL_TYPE==MODBUS_ASCII) 
....................    unsigned int8 modbus_serial_lrc; 
.................... #else 
....................    union 
....................    { 
....................       int8 b[2]; 
....................       int16 d; 
....................    } modbus_serial_crc; 
.................... #endif 
....................  
.................... /******************************************************************** 
.................... Our receive struct.  This is used when receiving data as a master or 
.................... slave.  Once a message is sent to you with your address, you should 
.................... begin processing that message.  Refer to ex_modbus_slave.c to see  
.................... how to properly use this structure. 
.................... ********************************************************************/ 
.................... struct 
.................... { 
....................    int8 address; 
....................    int8 len;                                //number of bytes in the message received 
....................    function func;                           //the function of the message received 
....................    exception error;                         //error recieved, if any 
....................    int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received 
.................... } modbus_rx; 
....................  
.................... /* Table of CRC values for high–order byte */ 
.................... #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
.................... const unsigned char modbus_auchCRCHi[] = { 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40 
.................... }; 
....................  
.................... /* Table of CRC values for low–order byte */ 
.................... const char modbus_auchCRCLo[] = { 
.................... 0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4, 
.................... 0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09, 
.................... 0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD, 
.................... 0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3, 
.................... 0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7, 
.................... 0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A, 
.................... 0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE, 
.................... 0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26, 
.................... 0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2, 
.................... 0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F, 
.................... 0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB, 
.................... 0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5, 
.................... 0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91, 
.................... 0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C, 
.................... 0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88, 
.................... 0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C, 
.................... 0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80, 
.................... 0x40 
.................... }; 
.................... #endif 
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void) 
.................... { 
....................    #if (MODBUS_SERIAL_INT_SOURCE!=MODBUS_INT_EXT) 
....................       while(kbhit(MODBUS_SERIAL)) {fgetc(MODBUS_SERIAL);}  //Clear RX buffer. Clear RDA interrupt flag. Clear overrun error flag. 
*
047A:  BTFSS  F9E.5
047C:  BRA    0482
047E:  RCALL  0336
....................       #if (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA) 
0480:  BRA    047A
....................         clear_interrupt(INT_RDA); 
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA2) 
....................         clear_interrupt(INT_RDA2); 
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA3) 
....................         clear_interrupt(INT_RDA3); 
....................       #else 
....................         clear_interrupt(INT_RDA4); 
....................       #endif 
....................  
....................       #if (MODBUS_SERIAL_RX_ENABLE!=0)  
....................          output_low(MODBUS_SERIAL_RX_ENABLE); 
....................       #endif 
....................  
....................       #if (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA) 
....................         enable_interrupts(INT_RDA); 
0482:  BSF    F9D.5
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA2) 
....................         enable_interrupts(INT_RDA2); 
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA3) 
....................         enable_interrupts(INT_RDA3); 
....................       #else 
....................         enable_interrupts(INT_RDA4); 
....................       #endif 
....................    #else 
....................       #if defined(__PCD__) 
....................          clear_interrupt(INT_EXT0); 
....................       #else 
....................          clear_interrupt(INT_EXT); 
....................       #endif 
....................        
....................       ext_int_edge(H_TO_L); 
....................       
....................       #if (MODBUS_SERIAL_RX_ENABLE!=0)  
....................          output_low(MODBUS_SERIAL_RX_ENABLE); 
....................       #endif 
....................  
....................       #if defined(__PCD__) 
....................          enable_interrupts(INT_EXT0); 
....................       #else 
....................          enable_interrupts(INT_EXT); 
....................       #endif 
....................    #endif 
.................... } 
0484:  RETLW  00
....................  
.................... // Purpose:    Initialize RS485 communication. Call this before 
.................... //             using any other RS485 functions. 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void modbus_init() 
.................... { 
....................    output_low(MODBUS_SERIAL_ENABLE_PIN); 
0486:  BCF    F93.2
0488:  BCF    F8A.2
....................  
....................    RCV_ON(); 
048A:  RCALL  047A
....................  
....................    #if defined(__PCD__) 
....................       #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
....................          setup_timer2(TMR_INTERNAL | TMR_DIV_BY_8,4999); //~4ms interrupts for 20Mhz clock 
....................       #endif 
....................       enable_interrupts(INTR_GLOBAL); 
....................    #else 
....................       #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
....................          setup_timer_2(T2_DIV_BY_16,249,5);  //~4ms interrupts 
048C:  MOVLW  20
048E:  IORLW  06
0490:  MOVWF  FCA
0492:  MOVLW  F9
0494:  MOVWF  FCB
....................       #endif 
....................       enable_interrupts(GLOBAL); 
0496:  MOVLW  C0
0498:  IORWF  FF2,F
....................    #endif 
.................... } 
049A:  GOTO   0A60 (RETURN)
....................  
.................... // Purpose:    Start our timeout timer 
.................... // Inputs:     Enable, used to turn timer on/off 
.................... // Outputs:    None 
.................... // Not used for ASCII mode 
.................... #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
.................... void modbus_enable_timeout(int1 enable) 
.................... { 
....................    disable_interrupts(INT_TIMER2); 
*
02F2:  BCF    F9D.1
....................    if (enable) { 
02F4:  MOVLB  5
02F6:  MOVF   x09,F
02F8:  BZ    0300
....................       set_timer2(0); 
02FA:  CLRF   FCC
....................       clear_interrupt(INT_TIMER2); 
02FC:  BCF    F9E.1
....................       enable_interrupts(INT_TIMER2); 
02FE:  BSF    F9D.1
....................    } 
.................... } 
0300:  MOVLB  0
0302:  RETLW  00
.................... #endif 
....................  
.................... // Purpose:    Check if we have timed out waiting for a response 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... // Not used for ASCII mode 
.................... #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
....................    #int_timer2 
....................    void modbus_timeout_now(void) 
....................    { 
....................       if((modbus_serial_state == MODBUS_GETDATA) && (modbus_serial_crc.d == 0x0000) && (!modbus_serial_new)) 
0304:  MOVF   1D,W
0306:  SUBLW  02
0308:  BNZ   031E
030A:  MOVF   1E,F
030C:  BNZ   031E
030E:  MOVF   1F,F
0310:  BNZ   031E
0312:  BTFSC  1C.0
0314:  BRA    031E
....................       { 
....................          modbus_rx.len-=2; 
0316:  MOVLW  02
0318:  SUBWF  21,F
....................          modbus_serial_new=TRUE; 
031A:  BSF    1C.0
....................       } 
....................       else 
031C:  BRA    0320
....................          modbus_serial_new=FALSE; 
031E:  BCF    1C.0
....................     
....................       modbus_serial_crc.d=0xFFFF; 
0320:  MOVLW  FF
0322:  MOVWF  1F
0324:  MOVWF  1E
....................       modbus_serial_state=MODBUS_GETADDY; 
0326:  CLRF   1D
....................       modbus_enable_timeout(FALSE); 
0328:  MOVLB  5
032A:  CLRF   x09
032C:  MOVLB  0
032E:  RCALL  02F2
....................    } 
.................... #endif 
....................  
.................... // Purpose:    Calculate crc of data and updates global crc 
.................... // Inputs:     Character 
.................... // Outputs:    None 
0330:  BCF    F9E.1
0332:  GOTO   006C
.................... void modbus_calc_crc(char data) 
.................... { 
....................    #if (MODBUS_SERIAL_TYPE == MODBUS_ASCII) 
....................       modbus_serial_lrc+=data; 
....................    #else 
....................       unsigned int8 uIndex ; // will index into CRC lookup table 
....................  
....................       uIndex = (modbus_serial_crc.b[1]) ^ data; // calculate the CRC 
*
034C:  MOVF   1F,W
034E:  MOVLB  5
0350:  XORWF  x09,W
0352:  MOVWF  x0A
....................       modbus_serial_crc.b[1] = (modbus_serial_crc.b[0]) ^ modbus_auchCRCHi[uIndex]; 
0354:  CLRF   03
0356:  MOVF   x0A,W
0358:  MOVFF  FF2,50B
035C:  BCF    FF2.7
035E:  MOVLB  0
0360:  RCALL  00AE
0362:  MOVLB  5
0364:  BTFSC  x0B.7
0366:  BSF    FF2.7
0368:  MOVWF  01
036A:  MOVF   1E,W
036C:  XORWF  01,W
036E:  MOVWF  1F
....................       modbus_serial_crc.b[0] = modbus_auchCRCLo[uIndex]; 
0370:  CLRF   03
0372:  MOVF   x0A,W
0374:  MOVFF  FF2,50B
0378:  BCF    FF2.7
037A:  MOVLB  0
037C:  RCALL  01D0
037E:  MOVLB  5
0380:  BTFSC  x0B.7
0382:  BSF    FF2.7
0384:  MOVWF  1E
....................    #endif 
.................... } 
0386:  MOVLB  0
0388:  RETLW  00
....................  
.................... // Purpose:    Puts a character onto the serial line 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_putc(int8 c) 
.................... { 
....................    #if (MODBUS_SERIAL_TYPE==MODBUS_ASCII) 
....................       int8 asciih,asciil; 
....................        
....................       asciih=c>>4; 
....................       if(asciih>9) 
....................          asciih+=0x37; 
....................       else 
....................          asciih+=0x30; 
....................       asciil=c&0xF; 
....................       if(asciil>9) 
....................          asciil+=0x37; 
....................       else 
....................          asciil+=0x30; 
....................       fputc(asciih,MODBUS_SERIAL); 
....................       fputc(asciil,MODBUS_SERIAL); 
....................       modbus_calc_crc(c); 
....................    #else 
....................       fputc(c, MODBUS_SERIAL); 
*
0570:  MOVLB  5
0572:  MOVF   x04,W
0574:  MOVLB  0
0576:  BRA    0566
0578:  CLRF   16
057A:  BTFSC  FF2.7
057C:  BSF    16.7
057E:  BCF    FF2.7
....................       modbus_calc_crc(c); 
0580:  MOVFF  504,509
0584:  RCALL  034C
0586:  BTFSC  16.7
0588:  BSF    FF2.7
....................       delay_us(1000000/MODBUS_SERIAL_BAUD); //one stop bit.  not exact 
058A:  MOVLW  8A
058C:  MOVWF  00
058E:  DECFSZ 00,F
0590:  BRA    058E
0592:  NOP   
....................    #endif 
.................... } 
0594:  RETLW  00
....................  
.................... // Purpose:   Interrupt service routine for handling incoming serial data 
.................... // Inputs:    None 
.................... // Outputs:   None 
.................... #if (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA) 
.................... #int_rda 
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA2) 
.................... #int_rda2 
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA3) 
.................... #int_rda3 
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA4) 
.................... #int_rda4 
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_EXT) 
.................... #if defined(__PCD__) 
.................... #int_ext0 
.................... #else 
.................... #int_ext 
.................... #endif 
.................... #else 
.................... #error Please define a correct interrupt source 
.................... #endif 
.................... void incomming_modbus_serial() { 
....................    char c; 
....................    #if (MODBUS_SERIAL_TYPE==MODBUS_ASCII) 
....................       static int1 two_characters=0; 
....................       static int8 datah,datal,data; 
....................    #endif 
....................  
....................    c=fgetc(MODBUS_SERIAL); 
*
038A:  RCALL  0336
038C:  MOVFF  01,508
....................     
....................    if (!modbus_serial_new) 
0390:  BTFSC  1C.0
0392:  BRA    03DE
....................    { 
....................       #if (MODBUS_SERIAL_TYPE==MODBUS_ASCII) 
....................          if(modbus_serial_state == MODBUS_START) 
....................          { 
....................             if(c==':') 
....................                modbus_serial_state++; 
....................          } 
....................          else if(modbus_serial_state == MODBUS_GETADDY) 
....................          { 
....................             if(!two_characters) 
....................             { 
....................                if(c>=0x41) 
....................                   datah=((c-0x37)<<4); 
....................                else 
....................                   datah=((c-0x30)<<4); 
....................                modbus_serial_lrc=0; 
....................             } 
....................             else 
....................             { 
....................                if(c>=0x41) 
....................                   datal=c-0x37; 
....................                else 
....................                   datal=c-0x30; 
....................                data=(datah | datal); 
....................                modbus_rx.address=data; 
....................                modbus_calc_crc(data); 
....................                modbus_serial_state++; 
....................             } 
....................             two_characters++; 
....................          } 
....................          else if(modbus_serial_state == MODBUS_GETFUNC) 
....................          { 
....................             if(!two_characters) 
....................             { 
....................                if(c>=0x41) 
....................                   datah=((c-0x37)<<4); 
....................                else 
....................                   datah=((c-0x30)<<4); 
....................             } 
....................             else 
....................             { 
....................                if(c>=0x41) 
....................                   datal=c-0x37; 
....................                else 
....................                   datal=c-0x30; 
....................                data=(datah | datal); 
....................                modbus_rx.func=data; 
....................                modbus_calc_crc(data); 
....................                modbus_serial_state++; 
....................                modbus_rx.len=0; 
....................                modbus_rx.error=0; 
....................             } 
....................             two_characters++; 
....................          } 
....................          else if(modbus_serial_state == MODBUS_GETDATA) 
....................          { 
....................             if(c=='\r') 
....................             { 
....................                modbus_serial_state++; 
....................                modbus_rx.len--; 
....................                modbus_serial_lrc-=data; 
....................             } 
....................             else if(!two_characters) 
....................             { 
....................                if(c>=0x41) 
....................                   datah=((c-0x37)<<4); 
....................                else 
....................                   datah=((c-0x30)<<4); 
....................                two_characters++; 
....................             } 
....................             else 
....................             { 
....................                if(c>=0x41) 
....................                   datal=c-0x37; 
....................                else 
....................                   datal=c-0x30; 
....................                data=(datah | datal); 
....................                if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) 
....................                   modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1; 
....................                modbus_rx.data[modbus_rx.len]=data; 
....................                modbus_rx.len++; 
....................                modbus_calc_crc(data); 
....................                two_characters++; 
....................             } 
....................          } 
....................          else if(modbus_serial_state==MODBUS_STOP) 
....................          { 
....................             if(c=='\n') 
....................             { 
....................                modbus_serial_lrc=((0xFF-modbus_serial_lrc)+1); 
....................                if(modbus_serial_lrc==data) 
....................                   modbus_serial_new=TRUE; 
....................             } 
....................             modbus_serial_state=MODBUS_START; 
....................             two_characters=0; 
....................          } 
....................       #else 
....................              
....................          if(modbus_serial_state == MODBUS_GETADDY) 
0394:  MOVF   1D,F
0396:  BNZ   03AA
....................          { 
....................             modbus_serial_crc.d = 0xFFFF; 
0398:  MOVLW  FF
039A:  MOVWF  1F
039C:  MOVWF  1E
....................             modbus_rx.address = c; 
039E:  MOVFF  508,20
....................             modbus_serial_state++; 
03A2:  INCF   1D,F
....................             modbus_rx.len = 0; 
03A4:  CLRF   21
....................             modbus_rx.error=0; 
03A6:  CLRF   23
....................          } 
....................          else if(modbus_serial_state == MODBUS_GETFUNC) 
03A8:  BRA    03CE
03AA:  DECFSZ 1D,W
03AC:  BRA    03B6
....................          { 
....................             modbus_rx.func = c; 
03AE:  MOVFF  508,22
....................             modbus_serial_state++; 
03B2:  INCF   1D,F
....................          } 
....................          else if(modbus_serial_state == MODBUS_GETDATA) 
03B4:  BRA    03CE
03B6:  MOVF   1D,W
03B8:  SUBLW  02
03BA:  BNZ   03CE
....................          { 
....................             if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) {modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1;} 
....................             modbus_rx.data[modbus_rx.len]=c; 
03BC:  MOVLW  24
03BE:  ADDWF  21,W
03C0:  MOVWF  FE9
03C2:  CLRF   FEA
03C4:  BTFSC  FD8.0
03C6:  INCF   FEA,F
03C8:  MOVFF  508,FEF
....................             modbus_rx.len++; 
03CC:  INCF   21,F
....................          } 
....................     
....................          modbus_calc_crc(c); 
03CE:  MOVFF  508,509
03D2:  RCALL  034C
....................          modbus_enable_timeout(TRUE); 
03D4:  MOVLW  01
03D6:  MOVLB  5
03D8:  MOVWF  x09
03DA:  MOVLB  0
03DC:  RCALL  02F2
....................       #endif 
....................    } 
....................    #if (MODBUS_TYPE == MODBUS_TYPE_MASTER) 
....................       modbus_serial_wait=MODBUS_SERIAL_TIMEOUT; 
03DE:  CLRF   1B
03E0:  CLRF   1A
03E2:  MOVLW  27
03E4:  MOVWF  19
03E6:  MOVLW  10
03E8:  MOVWF  18
....................    #endif 
.................... } 
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... //             4) The length of the data 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
03EA:  BCF    F9E.5
03EC:  GOTO   006C
.................... void modbus_serial_send_start(int8 to, int8 func) 
.................... { 
....................    #if (MODBUS_SERIAL_TYPE==MODBUS_ASCII) 
....................       modbus_serial_lrc=0; 
....................    #else 
....................       modbus_serial_crc.d=0xFFFF; 
*
0596:  MOVLW  FF
0598:  MOVWF  1F
059A:  MOVWF  1E
....................    #endif 
....................    modbus_serial_new=FALSE; 
059C:  BCF    1C.0
....................  
....................    RCV_OFF(); 
059E:  BCF    F9D.5
....................     
.................... #if (MODBUS_SERIAL_ENABLE_PIN!=0)  
....................    output_high(MODBUS_SERIAL_ENABLE_PIN); 
05A0:  BCF    F93.2
05A2:  BSF    F8A.2
.................... #endif 
....................  
....................    #if (MODBUS_SERIAL_TYPE==MODBUS_RTU) 
....................       delay_us(3500000/MODBUS_SERIAL_BAUD); //3.5 character delay 
05A4:  MOVLW  02
05A6:  MOVLB  5
05A8:  MOVWF  x04
05AA:  MOVLW  B5
05AC:  MOVWF  x05
05AE:  MOVLB  0
05B0:  RCALL  0548
05B2:  MOVLB  5
05B4:  DECFSZ x04,F
05B6:  BRA    05AA
....................    #else 
....................       fputc(':',MODBUS_SERIAL); 
....................    #endif 
....................  
....................    modbus_serial_putc(to); 
05B8:  MOVFF  502,504
05BC:  MOVLB  0
05BE:  RCALL  0570
....................    modbus_serial_putc(func); 
05C0:  MOVFF  503,504
05C4:  RCALL  0570
.................... } 
05C6:  RETLW  00
....................  
.................... void modbus_serial_send_stop() 
.................... { 
....................    #if (MODBUS_SERIAL_TYPE == MODBUS_ASCII) 
....................       int8 i; 
....................        
....................       for(i=0;i<8;i++) 
....................       { 
....................          if(bit_test(modbus_serial_lrc,i)) 
....................             bit_clear(modbus_serial_lrc,i); 
....................          else 
....................             bit_set(modbus_serial_lrc,i); 
....................       } 
....................       modbus_serial_lrc++; 
....................        
....................       modbus_serial_putc(modbus_serial_lrc); 
....................       fputc('\r',MODBUS_SERIAL); 
....................       fputc('\n',MODBUS_SERIAL); 
....................    #else 
....................       int8 crc_low, crc_high; 
....................     
....................       crc_high=modbus_serial_crc.b[1]; 
05C8:  MOVFF  1F,503
....................       crc_low=modbus_serial_crc.b[0]; 
05CC:  MOVFF  1E,502
....................     
....................       modbus_serial_putc(crc_high); 
05D0:  MOVFF  503,504
05D4:  RCALL  0570
....................       modbus_serial_putc(crc_low); 
05D6:  MOVFF  502,504
05DA:  RCALL  0570
....................    #endif 
....................     
.................... #if (MODBUS_SERIAL_INT_SOURCE!=MODBUS_INT_EXT) 
....................    WAIT_FOR_HW_BUFFER(); 
05DC:  BTFSS  FAC.1
05DE:  BRA    05DC
.................... #endif 
....................     
....................    #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
....................       delay_us(3500000/MODBUS_SERIAL_BAUD); //3.5 character delay 
05E0:  MOVLW  02
05E2:  MOVLB  5
05E4:  MOVWF  x04
05E6:  MOVLW  B5
05E8:  MOVWF  x05
05EA:  MOVLB  0
05EC:  RCALL  0548
05EE:  MOVLB  5
05F0:  DECFSZ x04,F
05F2:  BRA    05E6
....................    #endif 
....................  
....................    RCV_ON(); 
05F4:  MOVLB  0
05F6:  RCALL  047A
....................  
.................... #if (MODBUS_SERIAL_ENABLE_PIN!=0)  
....................    output_low(MODBUS_SERIAL_ENABLE_PIN); 
05F8:  BCF    F93.2
05FA:  BCF    F8A.2
.................... #endif 
....................  
....................    #if (MODBUS_SERIAL_TYPE == MODBUS_ASCII) 
....................       modbus_serial_lrc=0; 
....................    #else 
....................       modbus_serial_crc.d=0xFFFF; 
05FC:  MOVLW  FF
05FE:  MOVWF  1F
0600:  MOVWF  1E
....................    #endif 
.................... } 
0602:  RETLW  00
....................  
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer 
.................... // Inputs:     None 
.................... // Outputs:    TRUE if a message was received 
.................... //             FALSE if no message is available 
.................... // Note:       Data will be filled in at the modbus_rx struct: 
.................... int1 modbus_kbhit() 
.................... { 
....................    if(!modbus_serial_new) 
0604:  BTFSC  1C.0
0606:  BRA    0610
....................       return FALSE; 
0608:  MOVLW  00
060A:  MOVWF  01
060C:  BRA    0622
....................    else if(modbus_rx.func & 0x80)           //did we receive an error? 
060E:  BRA    061C
0610:  BTFSS  22.7
0612:  BRA    061C
....................    { 
....................       modbus_rx.error = modbus_rx.data[0];  //if so grab the error and return true 
0614:  MOVFF  24,23
....................       modbus_rx.len = 1; 
0618:  MOVLW  01
061A:  MOVWF  21
....................    } 
....................    modbus_serial_new=FALSE; 
061C:  BCF    1C.0
....................    return TRUE; 
061E:  MOVLW  01
0620:  MOVWF  01
.................... } 
0622:  RETLW  00
....................  
.................... #if (MODBUS_TYPE==MODBUS_TYPE_MASTER) 
.................... /*MODBUS Master Functions*/ 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request.  These 
.................... functions take in one of these structs. 
.................... Please refer to the MODBUS protocol specification if you do not 
.................... understand the members of the structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
.................... } modbus_read_sub_request; 
....................  
.................... typedef struct _modbus_write_sub_request 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
....................    int16 data[MODBUS_SERIAL_RX_BUFFER_SIZE-8]; 
.................... } modbus_write_sub_request; 
....................  
....................  
.................... /******************************************************************** 
.................... The following functions are defined in the MODBUS protocol.  Please 
.................... refer to http://www.modbus.org for the purpose of each of these. 
.................... All functions take the slaves address as their first parameter. 
.................... Each function returns the exception code received from the response. 
.................... The function will return 0 if there were no errors in transmission. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_coils(int8 address, int16 start_address, int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................     
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_discrete_input 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_discrete_input(int8 address, int16 start_address, int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................        
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_holding_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_holding_registers(int8 address, int16 start_address, int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
0624:  MOVFF  4FB,502
0628:  MOVLW  03
062A:  MOVLB  5
062C:  MOVWF  x03
062E:  MOVLB  0
0630:  RCALL  0596
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
0632:  MOVFF  4FD,500
0636:  MOVFF  4FD,504
063A:  RCALL  0570
....................    modbus_serial_putc(make8(start_address,0)); 
063C:  MOVFF  4FC,500
0640:  MOVFF  4FC,504
0644:  RCALL  0570
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
0646:  MOVFF  4FF,500
064A:  MOVFF  4FF,504
064E:  RCALL  0570
....................    modbus_serial_putc(make8(quantity,0)); 
0650:  MOVFF  4FE,500
0654:  MOVFF  4FE,504
0658:  RCALL  0570
....................  
....................    modbus_serial_send_stop(); 
065A:  RCALL  05C8
....................     
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
065C:  MOVLB  4
065E:  MOVF   xFB,F
0660:  BZ    06A6
0662:  MOVLB  0
0664:  RCALL  0604
0666:  MOVF   01,F
0668:  BNZ   0690
066A:  MOVLW  FF
066C:  ADDWF  18,F
066E:  BTFSS  FD8.0
0670:  ADDWF  19,F
0672:  BTFSS  FD8.0
0674:  ADDWF  1A,F
0676:  BTFSS  FD8.0
0678:  ADDWF  1B,F
067A:  MOVF   18,F
067C:  BNZ   068A
067E:  MOVF   19,F
0680:  BNZ   068A
0682:  MOVF   1A,F
0684:  BNZ   068A
0686:  MOVF   1B,F
0688:  BZ    0690
068A:  BRA    068C
068C:  BRA    068E
068E:  BRA    0664
0690:  MOVF   18,F
0692:  BNZ   06A4
0694:  MOVF   19,F
0696:  BNZ   06A4
0698:  MOVF   1A,F
069A:  BNZ   06A4
069C:  MOVF   1B,F
069E:  BNZ   06A4
06A0:  MOVLW  0C
06A2:  MOVWF  23
06A4:  MOVLB  4
06A6:  CLRF   1B
06A8:  CLRF   1A
06AA:  MOVLW  27
06AC:  MOVWF  19
06AE:  MOVLW  10
06B0:  MOVWF  18
....................  
....................    return modbus_rx.error; 
06B2:  MOVFF  23,01
.................... } 
06B6:  MOVLB  0
06B8:  RETLW  00
....................  
.................... /* 
.................... read_input_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_input_registers(int8 address, int16 start_address, int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................     
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_single_coil 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Address to write into 
....................            int1       on                 true for on, false for off 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_single_coil(int8 address, int16 output_address, int1 on) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
....................    modbus_serial_putc(make8(output_address,0)); 
....................  
....................    if(on) 
....................        modbus_serial_putc(0xFF); 
....................    else 
....................        modbus_serial_putc(0x00); 
....................     
....................    modbus_serial_putc(0x00); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_single_register 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Address to write into 
....................            int16      reg_value          Value to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_single_register(int8 address, int16 reg_address, int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
*
08BA:  MOVFF  4FD,502
08BE:  MOVLW  06
08C0:  MOVLB  5
08C2:  MOVWF  x03
08C4:  MOVLB  0
08C6:  RCALL  0596
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
08C8:  MOVFF  4FF,502
08CC:  MOVFF  4FF,504
08D0:  RCALL  0570
....................    modbus_serial_putc(make8(reg_address,0)); 
08D2:  MOVFF  4FE,502
08D6:  MOVFF  4FE,504
08DA:  RCALL  0570
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
08DC:  MOVFF  501,502
08E0:  MOVFF  501,504
08E4:  RCALL  0570
....................    modbus_serial_putc(make8(reg_value,0)); 
08E6:  MOVFF  500,502
08EA:  MOVFF  500,504
08EE:  RCALL  0570
....................  
....................    modbus_serial_send_stop(); 
08F0:  RCALL  05C8
....................     
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
08F2:  MOVLB  4
08F4:  MOVF   xFD,F
08F6:  BZ    093C
08F8:  MOVLB  0
08FA:  RCALL  0604
08FC:  MOVF   01,F
08FE:  BNZ   0926
0900:  MOVLW  FF
0902:  ADDWF  18,F
0904:  BTFSS  FD8.0
0906:  ADDWF  19,F
0908:  BTFSS  FD8.0
090A:  ADDWF  1A,F
090C:  BTFSS  FD8.0
090E:  ADDWF  1B,F
0910:  MOVF   18,F
0912:  BNZ   0920
0914:  MOVF   19,F
0916:  BNZ   0920
0918:  MOVF   1A,F
091A:  BNZ   0920
091C:  MOVF   1B,F
091E:  BZ    0926
0920:  BRA    0922
0922:  BRA    0924
0924:  BRA    08FA
0926:  MOVF   18,F
0928:  BNZ   093A
092A:  MOVF   19,F
092C:  BNZ   093A
092E:  MOVF   1A,F
0930:  BNZ   093A
0932:  MOVF   1B,F
0934:  BNZ   093A
0936:  MOVLW  0C
0938:  MOVWF  23
093A:  MOVLB  4
093C:  CLRF   1B
093E:  CLRF   1A
0940:  MOVLW  27
0942:  MOVWF  19
0944:  MOVLW  10
0946:  MOVWF  18
....................  
....................    return modbus_rx.error; 
0948:  MOVFF  23,01
.................... } 
094C:  MOVLB  0
094E:  RETLW  00
....................  
.................... /* 
.................... read_exception_status 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_exception_status(int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... diagnostics 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Subfunction to send 
....................            int16      data               Data to send, changes based on subfunction 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_diagnostics(int8 address, int16 sub_func, int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... get_comm_event_couter 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_get_comm_event_counter(int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... get_comm_event_log 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_get_comm_event_log(int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start at 
....................            int16      quantity           Amount of coils to write to 
....................            int1*      values             A pointer to an array holding the values to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_multiple_coils(int8 address, int16 start_address, int16 quantity, 
....................                            int8 *values) 
.................... { 
....................    int8 i,count; 
....................     
....................    count = (int8)((quantity/8)); 
....................     
....................    if(quantity%8) 
....................       count++;       
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_putc(count); 
....................  
....................    for(i=0; i < count; ++i)  
....................       modbus_serial_putc(values[i]); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_multiple_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start at 
....................            int16      quantity           Amount of coils to write to 
....................            int16*     values             A pointer to an array holding the data to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_multiple_registers(int8 address, int16 start_address, int16 quantity, 
....................                            int16 *values) 
.................... { 
....................    int8 i,count; 
....................     
....................    count = quantity*2; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................     
....................    modbus_serial_putc(count); 
....................  
....................    for(i=0; i < quantity; ++i) 
....................    { 
....................       modbus_serial_putc(make8(values[i],1)); 
....................       modbus_serial_putc(make8(values[i],0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... report_slave_id 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_report_slave_id(int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_file_record 
.................... Input:     int8                address            Slave Address 
....................            int8                byte_count         Number of bytes to read 
....................            read_sub_request*   request            Structure holding record information 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_file_record(int8 address, int8 byte_count,  
....................                             modbus_read_sub_request *request) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < (byte_count/7); i+=7) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_file_record 
.................... Input:     int8                address            Slave Address 
....................            int8                byte_count         Number of bytes to read 
....................            read_sub_request*   request            Structure holding record/data information 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_file_record(int8 address, int8 byte_count,  
....................                             modbus_write_sub_request *request) 
.................... { 
....................    int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length) &&  
....................             (j < MODBUS_SERIAL_RX_BUFFER_SIZE-8); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... mask_write_register 
.................... Input:     int8       address            Slave Address 
....................            int16      reference_address  Address to mask 
....................            int16      AND_mask           A mask to AND with the data at reference_address 
....................            int16      OR_mask            A mask to OR with the data at reference_address 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_mask_write_register(int8 address, int16 reference_address, 
....................                            int16 AND_mask, int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers 
.................... Input:     int8       address                Slave Address 
....................            int16      read_start             Address to start reading 
....................            int16      read_quantity          Amount of registers to read 
....................            int16      write_start            Address to start writing 
....................            int16      write_quantity         Amount of registers to write 
....................            int16*     write_registers_value  Pointer to an aray us to write 
.................... Output:    exception                         0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_write_multiple_registers(int8 address, int16 read_start, 
....................                                     int16 read_quantity, int16 write_start, 
....................                                     int16 write_quantity, 
....................                                     int16 *write_registers_value) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(read_start,1)); 
....................    modbus_serial_putc(make8(read_start,0)); 
....................  
....................    modbus_serial_putc(make8(read_quantity,1)); 
....................    modbus_serial_putc(make8(read_quantity,0)); 
....................  
....................    modbus_serial_putc(make8(write_start, 1)); 
....................    modbus_serial_putc(make8(write_start, 0)); 
....................  
....................    modbus_serial_putc(make8(write_quantity, 1)); 
....................    modbus_serial_putc(make8(write_quantity, 0)); 
....................  
....................    modbus_serial_putc((int8)(2*write_quantity)); 
....................  
....................    for(i=0; i < write_quantity ; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(write_registers_value[i], 1)); 
....................       modbus_serial_putc(make8(write_registers_value[i+1], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue 
.................... Input:     int8       address           Slave Address 
....................            int16      FIFO_address      FIFO address 
.................... Output:    exception                    0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_FIFO_queue(int8 address, int16 FIFO_address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(FIFO_address, 1)); 
....................    modbus_serial_putc(make8(FIFO_address, 0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... #else 
.................... /*MODBUS Slave Functions*/ 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request_rsp.  These 
.................... functions take in one of these structs.  Please refer to the MODBUS 
.................... protocol specification if you do not understand the members of the 
.................... structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request_rsp 
.................... { 
....................    int8 record_length; 
....................    int8 reference_type; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3]; 
.................... } modbus_read_sub_request_rsp; 
....................  
.................... typedef struct _modbus_write_sub_request_rsp 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8]; 
.................... } modbus_write_sub_request_rsp; 
....................  
....................  
.................... /******************************************************************** 
.................... The following slave functions are defined in the MODBUS protocol. 
.................... Please refer to http://www.modbus.org for the purpose of each of 
.................... these.  All functions take the slaves address as their first 
.................... parameter. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      coil_data          Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_coils_rsp(int8 address, int8 byte_count, int8* coil_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*coil_data); 
....................       coil_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_discrete_input_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_discrete_input_rsp(int8 address, int8 byte_count,  
....................                                     int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_holding_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      reg_data           Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_holding_registers_rsp(int8 address, int8 byte_count,  
....................                                         int16 *reg_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(*reg_data,1)); 
....................       modbus_serial_putc(make8(*reg_data,0)); 
....................       reg_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_input_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_input_registers_rsp(int8 address, int8 byte_count,  
....................                                         int16 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(*input_data,1)); 
....................       modbus_serial_putc(make8(*input_data,0)); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_coil_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Echo of output address received 
....................            int16      output_value       Echo of output value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_coil_rsp(int8 address, int16 output_address,  
....................                                     int16 output_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
....................    modbus_serial_putc(make8(output_address,0)); 
....................  
....................    modbus_serial_putc(make8(output_value,1)); 
....................    modbus_serial_putc(make8(output_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_register_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Echo of register address received 
....................            int16      reg_value          Echo of register value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_register_rsp(int8 address, int16 reg_address,  
....................                                         int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
....................    modbus_serial_putc(make8(reg_address,0)); 
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
....................    modbus_serial_putc(make8(reg_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_exception_status_rsp 
.................... Input:     int8       address            Slave Address 
.................... Output:    void 
.................... */ 
.................... void modbus_read_exception_status_rsp(int8 address, int8 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... diagnostics_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Echo of sub function received 
....................            int16      data               Echo of data received 
.................... Output:    void 
.................... */ 
.................... void modbus_diagnostics_rsp(int8 address, int16 sub_func, int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_counter_rsp(int8 address, int16 status,  
....................                                         int16 event_count) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
....................            int16      message_count      Count of messages 
....................            int8*      events             Pointer to event data 
....................            int8       events_len         Length of event data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_log_rsp(int8 address, int16 status, 
....................                                     int16 event_count, int16 message_count,  
....................                                     int8 *events, int8 events_len) 
.................... { 
....................    int8 i; 
....................      
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................  
....................    modbus_serial_putc(events_len+6); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_putc(make8(message_count, 1)); 
....................    modbus_serial_putc(make8(message_count, 0)); 
....................  
....................    for(i=0; i < events_len; ++i) 
....................    { 
....................       modbus_serial_putc(*events); 
....................       events++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of coils written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_coils_rsp(int8 address, int16 start_address,  
....................                                         int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of registers written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_registers_rsp(int8 address, int16 start_address,  
....................                                             int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... report_slave_id_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       slave_id           Slave Address 
....................            int8       run_status         Are we running? 
....................            int8*      data               Pointer to an array holding the data 
....................            int8       data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_report_slave_id_rsp(int8 address, int8 slave_id, int1 run_status, 
....................                               int8 *data, int8 data_len) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................  
....................    modbus_serial_putc(data_len+2); 
....................    modbus_serial_putc(slave_id); 
....................  
....................    if(run_status) 
....................     modbus_serial_putc(0xFF); 
....................    else 
....................     modbus_serial_putc(0x00); 
....................  
....................    for(i=0; i < data_len; ++i) 
....................    { 
....................       modbus_serial_putc(*data); 
....................       data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Number of bytes to send 
....................            read_sub_request_rsp*    request            Structure holding record/data information 
.................... Output:    void 
.................... */ 
.................... void modbus_read_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_read_sub_request_rsp *request) 
.................... { 
....................    int8 i=0,j; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    while(i < byte_count); 
....................    { 
....................       modbus_serial_putc(request->record_length); 
....................       modbus_serial_putc(request->reference_type); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................  
....................       i += (request->record_length)+1; 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Echo of number of bytes sent 
....................            write_sub_request_rsp*   request            Echo of Structure holding record information 
.................... Output:    void 
.................... */ 
.................... void modbus_write_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_write_sub_request_rsp *request) 
.................... { 
....................    int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... mask_write_register_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       reference_address  Echo of reference address 
....................            int16       AND_mask           Echo of AND mask 
....................            int16       OR_mask            Echo or OR mask 
.................... Output:    void 
.................... */ 
.................... void modbus_mask_write_register_rsp(int8 address, int16 reference_address, 
....................                            int16 AND_mask, int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16*      data               Pointer to an array of data 
....................            int8        data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_read_write_multiple_registers_rsp(int8 address, int8 data_len,  
....................                                                 int16 *data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(data_len*2); 
....................  
....................    for(i=0; i < data_len*2; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       FIFO_len           Length of FIFO in bytes 
....................            int16*      data               Pointer to an array of data 
.................... Output:    void 
.................... */ 
.................... void modbus_read_FIFO_queue_rsp(int8 address, int16 FIFO_len, int16 *data) 
.................... { 
....................    int8 i; 
....................    int16 byte_count; 
....................  
....................    byte_count = ((FIFO_len*2)+2); 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(byte_count, 1)); 
....................    modbus_serial_putc(make8(byte_count, 0)); 
....................  
....................    modbus_serial_putc(make8(FIFO_len, 1)); 
....................    modbus_serial_putc(make8(FIFO_len, 0)); 
....................  
....................    for(i=0; i < FIFO_len; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... void modbus_exception_rsp(int8 address, int16 func, exception error) 
.................... { 
....................    modbus_serial_send_start(address, func|0x80); 
....................    modbus_serial_putc(error); 
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... #define MODBUS_SLAVE_ADDRESS_1 0x01 
.................... #define MODBUS_SLAVE_ADDRESS_2 0x02 
.................... #define MODBUS_SLAVE_ADDRESS_3 0x03 
....................  
.................... // Variables para Pt100 
.................... int8 instruccion=0,address=0,regl=0,regh=0,i=0,pwm1l=0,pwm1h=0,pwm2l=0,pwm2h=0,crc1=0,crc2=0,conteoError=0,conteoError2=0,conteoError3=0,temporal=0; 
.................... int16 reg=0,pwm1=0,pwm2=0; 
....................  
.................... int8 fstate;                     //Guardara el estado del bus I2C 
.................... int8 posicion, buffer[50], txbuf[90],rxbuf[50];     //Buffer de memoria 
....................  
.................... #INT_SSP 
.................... void ssp_interupt (){ 
....................    int8 incoming;                //Variable donde se recibe el byte que manda el maestro 
....................     
....................    fstate = i2c_isr_state();    //Lectura del estado del bus I2c la interrupción 
*
0408:  BTFSC  FC7.5
040A:  BRA    0414
040C:  MOVLB  4
040E:  CLRF   xF8
0410:  BTFSC  FC7.2
0412:  BSF    xF8.7
0414:  MOVLB  4
0416:  MOVF   xF8,W
0418:  INCF   xF8,F
041A:  MOVWF  x38
....................  
....................    if(fstate == 0x80) {          
041C:  MOVF   x38,W
041E:  SUBLW  80
0420:  BNZ   0440
....................        //Manda al maestro la información contenida en la posición de memoria que le ha solicitado 
....................       i2c_write (txbuf[posicion]); 
0422:  CLRF   03
0424:  MOVF   x39,W
0426:  ADDLW  6C
0428:  MOVWF  FE9
042A:  MOVLW  04
042C:  ADDWFC 03,W
042E:  MOVWF  FEA
0430:  MOVFF  FEF,509
0434:  MOVFF  509,50A
0438:  MOVLB  0
043A:  BRA    03F0
....................    }else {                              //Sino es que hay dato en el bus I2C... 
043C:  BRA    0474
043E:  MOVLB  4
....................       incoming = i2c_read();           //... lo lee 
0440:  BCF    FC6.6
0442:  BTFSS  F9E.3
0444:  BRA    0442
0446:  MOVF   FC9,W
0448:  BSF    FC6.4
044A:  MOVLB  5
044C:  MOVWF  x08
....................       if (fState == 1) {          //Información recibida corresponde a la posicion 
044E:  MOVLB  4
0450:  DECFSZ x38,W
0452:  BRA    045A
....................          posicion = incoming;          //Se guarda posición 
0454:  MOVFF  508,439
....................       } 
....................       else if (fState == 2) {          //Información recibida corresponde al dato 
0458:  BRA    0472
045A:  MOVF   x38,W
045C:  SUBLW  02
045E:  BNZ   0472
....................          rxbuf[posicion] = incoming; 
0460:  CLRF   03
0462:  MOVF   x39,W
0464:  ADDLW  C6
0466:  MOVWF  FE9
0468:  MOVLW  04
046A:  ADDWFC 03,W
046C:  MOVWF  FEA
046E:  MOVFF  508,FEF
0472:  MOVLB  0
....................       } 
....................   } 
.................... } 
....................  
0474:  BCF    F9E.3
0476:  GOTO   006C
.................... void Lee_Vector(void){ 
....................    instruccion=rxbuf[0]; 
*
04C0:  MOVFF  4C6,423
....................    address=rxbuf[1]; 
04C4:  MOVFF  4C7,424
....................    regl=rxbuf[2]; 
04C8:  MOVFF  4C8,425
....................    regh=rxbuf[3]; 
04CC:  MOVFF  4C9,426
....................    reg=(regh*256)+regl; 
04D0:  MOVLB  4
04D2:  CLRF   xFA
04D4:  MOVFF  426,4F9
04D8:  MOVLW  01
04DA:  MOVWF  xFC
04DC:  CLRF   xFB
04DE:  MOVLB  0
04E0:  RCALL  049E
04E2:  MOVLB  4
04E4:  MOVF   x25,W
04E6:  ADDWF  01,W
04E8:  MOVWF  x32
04EA:  MOVLW  00
04EC:  ADDWFC 02,W
04EE:  MOVWF  x33
....................    pwm1l=rxbuf[4]; 
04F0:  MOVFF  4CA,428
....................    pwm1h=rxbuf[5]; 
04F4:  MOVFF  4CB,429
....................    pwm2l=rxbuf[6]; 
04F8:  MOVFF  4CC,42A
....................    pwm2h=rxbuf[7]; 
04FC:  MOVFF  4CD,42B
....................    pwm1=(pwm1h*256)+pwm1l; 
0500:  CLRF   xFA
0502:  MOVFF  429,4F9
0506:  MOVLW  01
0508:  MOVWF  xFC
050A:  CLRF   xFB
050C:  MOVLB  0
050E:  RCALL  049E
0510:  MOVLB  4
0512:  MOVF   x28,W
0514:  ADDWF  01,W
0516:  MOVWF  x34
0518:  MOVLW  00
051A:  ADDWFC 02,W
051C:  MOVWF  x35
....................    pwm2=(pwm2h*256)+pwm2l; 
051E:  CLRF   xFA
0520:  MOVFF  42B,4F9
0524:  MOVLW  01
0526:  MOVWF  xFC
0528:  CLRF   xFB
052A:  MOVLB  0
052C:  RCALL  049E
052E:  MOVLB  4
0530:  MOVF   x2A,W
0532:  ADDWF  01,W
0534:  MOVWF  x36
0536:  MOVLW  00
0538:  ADDWFC 02,W
053A:  MOVWF  x37
....................    crc1=rxbuf[8]; 
053C:  MOVFF  4CE,42C
....................    crc2=rxbuf[9]; 
0540:  MOVFF  4CF,42D
.................... } 
0544:  MOVLB  0
0546:  RETLW  00
....................  
.................... int8 swap_bits(int8 c) 
.................... { 
....................    return ((c&1)?128:0)|((c&2)?64:0)|((c&4)?32:0)|((c&8)?16:0)|((c&16)?8:0) 
....................           |((c&32)?4:0)|((c&64)?2:0)|((c&128)?1:0); 
.................... } 
....................  
.................... void read_all_holding(int8 start,int8 size) 
.................... {    
....................    if(!(modbus_read_holding_registers(1,start,size))){ //Lee Variador #1 
*
06BA:  MOVLW  01
06BC:  MOVLB  4
06BE:  MOVWF  xFB
06C0:  CLRF   xFD
06C2:  MOVFF  4F9,4FC
06C6:  CLRF   xFF
06C8:  MOVFF  4FA,4FE
06CC:  MOVLB  0
06CE:  RCALL  0624
06D0:  MOVF   01,F
06D2:  BNZ   073C
....................       txbuf[1]=(int8)modbus_rx.data[1];//Registro 1 
06D4:  MOVFF  25,46D
....................       txbuf[2]=(int8)modbus_rx.data[2];//Registro 1 
06D8:  MOVFF  26,46E
....................       txbuf[3]=(int8)modbus_rx.data[3];//Registro 2 
06DC:  MOVFF  27,46F
....................       txbuf[4]=(int8)modbus_rx.data[4];//Registro 2 
06E0:  MOVFF  28,470
....................       txbuf[5]=(int8)modbus_rx.data[7];//Registro 4 
06E4:  MOVFF  2B,471
....................       txbuf[6]=(int8)modbus_rx.data[8];//Registro 4 
06E8:  MOVFF  2C,472
....................       txbuf[7]=(int8)modbus_rx.data[11];//Registro 6 
06EC:  MOVFF  2F,473
....................       txbuf[8]=(int8)modbus_rx.data[12];//Registro 6 
06F0:  MOVFF  30,474
....................       txbuf[9]=(int8)modbus_rx.data[13];//Registro 7 
06F4:  MOVFF  31,475
....................       txbuf[10]=(int8)modbus_rx.data[14];//Registro 7 
06F8:  MOVFF  32,476
....................       txbuf[11]=(int8)modbus_rx.data[15];//Registro 8 
06FC:  MOVFF  33,477
....................       txbuf[12]=(int8)modbus_rx.data[16];//Registro 8 
0700:  MOVFF  34,478
....................       txbuf[13]=(int8)modbus_rx.data[21];//Registro 11 
0704:  MOVFF  39,479
....................       txbuf[14]=(int8)modbus_rx.data[22];//Registro 11 
0708:  MOVFF  3A,47A
....................       txbuf[15]=(int8)modbus_rx.data[39];//Registro 20 
070C:  MOVFF  4B,47B
....................       txbuf[16]=(int8)modbus_rx.data[40];//Registro 20 
0710:  MOVFF  4C,47C
....................       txbuf[17]=(int8)modbus_rx.data[41];//Registro 21 
0714:  MOVFF  4D,47D
....................       txbuf[18]=(int8)modbus_rx.data[42];//Registro 21 
0718:  MOVFF  4E,47E
....................       txbuf[19]=(int8)modbus_rx.data[43];//Registro 22 
071C:  MOVFF  4F,47F
....................       txbuf[20]=(int8)modbus_rx.data[44];//Registro 22 
0720:  MOVFF  50,480
....................       txbuf[21]=(int8)modbus_rx.data[45];//Registro 23 
0724:  MOVFF  51,481
....................       txbuf[22]=(int8)modbus_rx.data[46];//Registro 23 
0728:  MOVFF  52,482
....................       txbuf[23]=(int8)modbus_rx.data[47];//Registro 24 
072C:  MOVFF  53,483
....................       txbuf[24]=(int8)modbus_rx.data[48];//Registro 24 
0730:  MOVFF  54,484
....................       conteoError=0; 
0734:  MOVLB  4
0736:  CLRF   x2E
....................    }else{ 
0738:  BRA    0764
073A:  MOVLB  0
....................       conteoError++; 
073C:  MOVLB  4
073E:  INCF   x2E,F
....................       if(conteoError>20){ 
0740:  MOVF   x2E,W
0742:  SUBLW  14
0744:  BC    0764
....................          for(i=1; i < 25; ++i){          
0746:  MOVLW  01
0748:  MOVWF  x27
074A:  MOVF   x27,W
074C:  SUBLW  18
074E:  BNC   0764
....................             txbuf[i]=0; 
0750:  CLRF   03
0752:  MOVF   x27,W
0754:  ADDLW  6C
0756:  MOVWF  FE9
0758:  MOVLW  04
075A:  ADDWFC 03,W
075C:  MOVWF  FEA
075E:  CLRF   FEF
....................          } 
0760:  INCF   x27,F
0762:  BRA    074A
....................       } 
....................    } 
....................     
....................    if(!(modbus_read_holding_registers(2,start,size))){ //Lee Variador #2 
0764:  MOVLW  02
0766:  MOVWF  xFB
0768:  CLRF   xFD
076A:  MOVFF  4F9,4FC
076E:  CLRF   xFF
0770:  MOVFF  4FA,4FE
0774:  MOVLB  0
0776:  RCALL  0624
0778:  MOVF   01,F
077A:  BNZ   07E4
....................       txbuf[25]=(int8)modbus_rx.data[1];//Registro 1 
077C:  MOVFF  25,485
....................       txbuf[26]=(int8)modbus_rx.data[2];//Registro 1 
0780:  MOVFF  26,486
....................       txbuf[27]=(int8)modbus_rx.data[3];//Registro 2 
0784:  MOVFF  27,487
....................       txbuf[28]=(int8)modbus_rx.data[4];//Registro 2 
0788:  MOVFF  28,488
....................       txbuf[29]=(int8)modbus_rx.data[7];//Registro 4 
078C:  MOVFF  2B,489
....................       txbuf[30]=(int8)modbus_rx.data[8];//Registro 4 
0790:  MOVFF  2C,48A
....................       txbuf[31]=(int8)modbus_rx.data[11];//Registro 6 
0794:  MOVFF  2F,48B
....................       txbuf[32]=(int8)modbus_rx.data[12];//Registro 6 
0798:  MOVFF  30,48C
....................       txbuf[33]=(int8)modbus_rx.data[13];//Registro 7 
079C:  MOVFF  31,48D
....................       txbuf[34]=(int8)modbus_rx.data[14];//Registro 7 
07A0:  MOVFF  32,48E
....................       txbuf[35]=(int8)modbus_rx.data[15];//Registro 8 
07A4:  MOVFF  33,48F
....................       txbuf[36]=(int8)modbus_rx.data[16];//Registro 8 
07A8:  MOVFF  34,490
....................       txbuf[37]=(int8)modbus_rx.data[21];//Registro 11 
07AC:  MOVFF  39,491
....................       txbuf[38]=(int8)modbus_rx.data[22];//Registro 11 
07B0:  MOVFF  3A,492
....................       txbuf[39]=(int8)modbus_rx.data[39];//Registro 20 
07B4:  MOVFF  4B,493
....................       txbuf[40]=(int8)modbus_rx.data[40];//Registro 20 
07B8:  MOVFF  4C,494
....................       txbuf[41]=(int8)modbus_rx.data[41];//Registro 21 
07BC:  MOVFF  4D,495
....................       txbuf[42]=(int8)modbus_rx.data[42];//Registro 21 
07C0:  MOVFF  4E,496
....................       txbuf[43]=(int8)modbus_rx.data[43];//Registro 22 
07C4:  MOVFF  4F,497
....................       txbuf[44]=(int8)modbus_rx.data[44];//Registro 22 
07C8:  MOVFF  50,498
....................       txbuf[45]=(int8)modbus_rx.data[45];//Registro 23 
07CC:  MOVFF  51,499
....................       txbuf[46]=(int8)modbus_rx.data[46];//Registro 23 
07D0:  MOVFF  52,49A
....................       txbuf[47]=(int8)modbus_rx.data[47];//Registro 24 
07D4:  MOVFF  53,49B
....................       txbuf[48]=(int8)modbus_rx.data[48];//Registro 24 
07D8:  MOVFF  54,49C
....................       conteoError2=0; 
07DC:  MOVLB  4
07DE:  CLRF   x2F
....................    }else{ 
07E0:  BRA    080C
07E2:  MOVLB  0
....................       conteoError2++; 
07E4:  MOVLB  4
07E6:  INCF   x2F,F
....................       if(conteoError2>20){ 
07E8:  MOVF   x2F,W
07EA:  SUBLW  14
07EC:  BC    080C
....................          for(i=25; i < 49; ++i){          
07EE:  MOVLW  19
07F0:  MOVWF  x27
07F2:  MOVF   x27,W
07F4:  SUBLW  30
07F6:  BNC   080C
....................             txbuf[i]=0; 
07F8:  CLRF   03
07FA:  MOVF   x27,W
07FC:  ADDLW  6C
07FE:  MOVWF  FE9
0800:  MOVLW  04
0802:  ADDWFC 03,W
0804:  MOVWF  FEA
0806:  CLRF   FEF
....................          } 
0808:  INCF   x27,F
080A:  BRA    07F2
....................       } 
....................    } 
....................     
....................    if(!(modbus_read_holding_registers(3,start,size))){ //Lee Variador #3 
080C:  MOVLW  03
080E:  MOVWF  xFB
0810:  CLRF   xFD
0812:  MOVFF  4F9,4FC
0816:  CLRF   xFF
0818:  MOVFF  4FA,4FE
081C:  MOVLB  0
081E:  RCALL  0624
0820:  MOVF   01,F
0822:  BNZ   088C
....................       txbuf[50]=(int8)modbus_rx.data[1];//Registro 1 
0824:  MOVFF  25,49E
....................       txbuf[51]=(int8)modbus_rx.data[2];//Registro 1 
0828:  MOVFF  26,49F
....................       txbuf[52]=(int8)modbus_rx.data[3];//Registro 2 
082C:  MOVFF  27,4A0
....................       txbuf[53]=(int8)modbus_rx.data[4];//Registro 2 
0830:  MOVFF  28,4A1
....................       txbuf[54]=(int8)modbus_rx.data[7];//Registro 4 
0834:  MOVFF  2B,4A2
....................       txbuf[55]=(int8)modbus_rx.data[8];//Registro 4 
0838:  MOVFF  2C,4A3
....................       txbuf[56]=(int8)modbus_rx.data[11];//Registro 6 
083C:  MOVFF  2F,4A4
....................       txbuf[57]=(int8)modbus_rx.data[12];//Registro 6 
0840:  MOVFF  30,4A5
....................       txbuf[58]=(int8)modbus_rx.data[13];//Registro 7 
0844:  MOVFF  31,4A6
....................       txbuf[59]=(int8)modbus_rx.data[14];//Registro 7 
0848:  MOVFF  32,4A7
....................       txbuf[60]=(int8)modbus_rx.data[15];//Registro 8 
084C:  MOVFF  33,4A8
....................       txbuf[61]=(int8)modbus_rx.data[16];//Registro 8 
0850:  MOVFF  34,4A9
....................       txbuf[62]=(int8)modbus_rx.data[21];//Registro 11 
0854:  MOVFF  39,4AA
....................       txbuf[63]=(int8)modbus_rx.data[22];//Registro 11 
0858:  MOVFF  3A,4AB
....................       txbuf[64]=(int8)modbus_rx.data[39];//Registro 20 
085C:  MOVFF  4B,4AC
....................       txbuf[65]=(int8)modbus_rx.data[40];//Registro 20 
0860:  MOVFF  4C,4AD
....................       txbuf[66]=(int8)modbus_rx.data[41];//Registro 21 
0864:  MOVFF  4D,4AE
....................       txbuf[67]=(int8)modbus_rx.data[42];//Registro 21 
0868:  MOVFF  4E,4AF
....................       txbuf[68]=(int8)modbus_rx.data[43];//Registro 22 
086C:  MOVFF  4F,4B0
....................       txbuf[69]=(int8)modbus_rx.data[44];//Registro 22 
0870:  MOVFF  50,4B1
....................       txbuf[70]=(int8)modbus_rx.data[45];//Registro 23 
0874:  MOVFF  51,4B2
....................       txbuf[71]=(int8)modbus_rx.data[46];//Registro 23 
0878:  MOVFF  52,4B3
....................       txbuf[72]=(int8)modbus_rx.data[47];//Registro 24 
087C:  MOVFF  53,4B4
....................       txbuf[73]=(int8)modbus_rx.data[48];//Registro 24 
0880:  MOVFF  54,4B5
....................       conteoError3=0; 
0884:  MOVLB  4
0886:  CLRF   x30
....................    }else{ 
0888:  BRA    08B4
088A:  MOVLB  0
....................       conteoError3++; 
088C:  MOVLB  4
088E:  INCF   x30,F
....................       if(conteoError3>20){ 
0890:  MOVF   x30,W
0892:  SUBLW  14
0894:  BC    08B4
....................          for(i=50; i < 74; ++i){          
0896:  MOVLW  32
0898:  MOVWF  x27
089A:  MOVF   x27,W
089C:  SUBLW  49
089E:  BNC   08B4
....................             txbuf[i]=0; 
08A0:  CLRF   03
08A2:  MOVF   x27,W
08A4:  ADDLW  6C
08A6:  MOVWF  FE9
08A8:  MOVLW  04
08AA:  ADDWFC 03,W
08AC:  MOVWF  FEA
08AE:  CLRF   FEF
....................          } 
08B0:  INCF   x27,F
08B2:  BRA    089A
....................       } 
....................    } 
.................... } 
08B4:  MOVLB  0
08B6:  GOTO   0AF8 (RETURN)
....................  
.................... void write_reg(int16 address,int16 reg) 
.................... { 
....................    /* 
....................    DEBUG_MSG("Writing Single Register:\r\n"); 
....................    if(!(modbus_write_single_register(0x01,address,reg))) 
....................    { 
....................       DEBUG_MSG("Data: "); 
....................       for(i=0; i < (modbus_rx.len); ++i) 
....................          DEBUG_DATA("%X ", modbus_rx.data[i]); 
....................       DEBUG_MSG("\r\n\r\n"); 
....................       Buzzer_off; 
....................    } 
....................    else 
....................    { 
....................       output_toggle(PIN_A5); 
....................    } 
....................    */ 
....................    modbus_write_single_register(1,address,reg); 
*
0950:  MOVLW  01
0952:  MOVLB  4
0954:  MOVWF  xFD
0956:  MOVFF  4FA,4FF
095A:  MOVFF  4F9,4FE
095E:  MOVFF  4FC,501
0962:  MOVFF  4FB,500
0966:  MOVLB  0
0968:  RCALL  08BA
....................    modbus_write_single_register(2,address,reg); 
096A:  MOVLW  02
096C:  MOVLB  4
096E:  MOVWF  xFD
0970:  MOVFF  4FA,4FF
0974:  MOVFF  4F9,4FE
0978:  MOVFF  4FC,501
097C:  MOVFF  4FB,500
0980:  MOVLB  0
0982:  RCALL  08BA
....................    modbus_write_single_register(3,address,reg); 
0984:  MOVLW  03
0986:  MOVLB  4
0988:  MOVWF  xFD
098A:  MOVFF  4FA,4FF
098E:  MOVFF  4F9,4FE
0992:  MOVFF  4FC,501
0996:  MOVFF  4FB,500
099A:  MOVLB  0
099C:  RCALL  08BA
.................... } 
099E:  GOTO   0B12 (RETURN)
....................  
.................... void main() 
.................... { 
09A2:  CLRF   FF8
09A4:  BCF    FD0.7
09A6:  BSF    07.7
09A8:  CLRF   FEA
09AA:  CLRF   FE9
09AC:  BSF    F93.1
09AE:  BSF    F93.0
09B0:  MOVLW  B0
09B2:  MOVWF  FC8
09B4:  MOVLW  36
09B6:  MOVWF  FC6
09B8:  BCF    F93.4
09BA:  BSF    F8A.4
09BC:  BSF    FB8.3
09BE:  MOVLW  A0
09C0:  MOVWF  FAF
09C2:  MOVLW  01
09C4:  MOVWF  FB0
09C6:  MOVLW  A6
09C8:  MOVWF  FAC
09CA:  MOVLW  90
09CC:  MOVWF  FAB
09CE:  CLRF   1B
09D0:  CLRF   1A
09D2:  MOVLW  27
09D4:  MOVWF  19
09D6:  MOVLW  10
09D8:  MOVWF  18
09DA:  BCF    1C.0
09DC:  CLRF   1D
09DE:  MOVLB  4
09E0:  CLRF   x23
09E2:  CLRF   x24
09E4:  CLRF   x25
09E6:  CLRF   x26
09E8:  CLRF   x27
09EA:  CLRF   x28
09EC:  CLRF   x29
09EE:  CLRF   x2A
09F0:  CLRF   x2B
09F2:  CLRF   x2C
09F4:  CLRF   x2D
09F6:  CLRF   x2E
09F8:  CLRF   x2F
09FA:  CLRF   x30
09FC:  CLRF   x31
09FE:  CLRF   x33
0A00:  CLRF   x32
0A02:  CLRF   x35
0A04:  CLRF   x34
0A06:  CLRF   x37
0A08:  CLRF   x36
0A0A:  MOVF   FC1,W
0A0C:  ANDLW  C0
0A0E:  IORLW  0F
0A10:  MOVWF  FC1
0A12:  MOVLW  07
0A14:  MOVWF  FB4
0A16:  CLRF   17
0A18:  MOVLW  03
0A1A:  MOVWF  xF8
....................    fState = 0; 
0A1C:  CLRF   x38
....................    for (posicion=0;posicion<0x10;posicion++){ 
0A1E:  CLRF   x39
0A20:  MOVF   x39,W
0A22:  SUBLW  0F
0A24:  BNC   0A5A
....................       buffer[posicion] = 0x00; 
0A26:  CLRF   03
0A28:  MOVF   x39,W
0A2A:  ADDLW  3A
0A2C:  MOVWF  FE9
0A2E:  MOVLW  04
0A30:  ADDWFC 03,W
0A32:  MOVWF  FEA
0A34:  CLRF   FEF
....................       txbuf[posicion] = 0x00; 
0A36:  CLRF   03
0A38:  MOVF   x39,W
0A3A:  ADDLW  6C
0A3C:  MOVWF  FE9
0A3E:  MOVLW  04
0A40:  ADDWFC 03,W
0A42:  MOVWF  FEA
0A44:  CLRF   FEF
....................       rxbuf[posicion] = 0x00; 
0A46:  CLRF   03
0A48:  MOVF   x39,W
0A4A:  ADDLW  C6
0A4C:  MOVWF  FE9
0A4E:  MOVLW  04
0A50:  ADDWFC 03,W
0A52:  MOVWF  FEA
0A54:  CLRF   FEF
....................    } 
0A56:  INCF   x39,F
0A58:  BRA    0A20
....................    enable_interrupts(INT_SSP); 
0A5A:  BSF    F9D.3
....................    modbus_init();    
0A5C:  MOVLB  0
0A5E:  BRA    0486
....................    setup_wdt(WDT_ON); 
0A60:  BSF    FD1.0
....................    setup_timer_2(T2_DIV_BY_16, 255, 16);  
0A62:  MOVLW  78
0A64:  IORLW  06
0A66:  MOVWF  FCA
0A68:  MOVLW  FF
0A6A:  MOVWF  FCB
....................    setup_ccp1(CCP_PWM); 
0A6C:  BCF    F94.2
0A6E:  BCF    F8B.2
0A70:  MOVLW  0C
0A72:  MOVWF  FBD
....................    setup_ccp2(CCP_PWM); 
0A74:  BCF    F94.1
0A76:  BCF    F8B.1
0A78:  MOVWF  FBA
....................    set_pwm1_duty (0); 
0A7A:  CLRF   FBE
....................    set_pwm2_duty (0); 
0A7C:  CLRF   FBB
....................    enable_interrupts(global); 
0A7E:  MOVLW  C0
0A80:  IORWF  FF2,F
....................    Lee_Vector(); 
0A82:  RCALL  04C0
....................     
....................  
.................... while(true) 
.................... { 
....................    restart_wdt(); 
0A84:  CLRWDT
....................    txbuf[0]=10; 
0A86:  MOVLW  0A
0A88:  MOVLB  4
0A8A:  MOVWF  x6C
....................    txbuf[49]=128; 
0A8C:  MOVLW  80
0A8E:  MOVWF  x9D
....................    //temporal++;    
....................    set_pwm1_duty(pwm1); 
0A90:  MOVFF  435,02
0A94:  MOVFF  434,01
0A98:  RRCF   02,F
0A9A:  RRCF   01,F
0A9C:  RRCF   02,F
0A9E:  RRCF   01,F
0AA0:  RRCF   02,F
0AA2:  MOVFF  01,FBE
0AA6:  RRCF   02,F
0AA8:  RRCF   02,W
0AAA:  ANDLW  30
0AAC:  MOVWF  00
0AAE:  MOVF   FBD,W
0AB0:  ANDLW  CF
0AB2:  IORWF  00,W
0AB4:  MOVWF  FBD
....................    set_pwm2_duty(pwm2); 
0AB6:  MOVFF  437,02
0ABA:  MOVFF  436,01
0ABE:  RRCF   02,F
0AC0:  RRCF   01,F
0AC2:  RRCF   02,F
0AC4:  RRCF   01,F
0AC6:  RRCF   02,F
0AC8:  MOVFF  01,FBB
0ACC:  RRCF   02,F
0ACE:  RRCF   02,W
0AD0:  ANDLW  30
0AD2:  MOVWF  00
0AD4:  MOVF   FBA,W
0AD6:  ANDLW  CF
0AD8:  IORWF  00,W
0ADA:  MOVWF  FBA
....................    //write_reg(1,temporal); 
....................    if(crc1==txbuf[0] && crc2==txbuf[49]){ 
0ADC:  MOVF   x6C,W
0ADE:  SUBWF  x2C,W
0AE0:  BNZ   0B14
0AE2:  MOVF   x9D,W
0AE4:  SUBWF  x2D,W
0AE6:  BNZ   0B14
....................       if(instruccion==3){ 
0AE8:  MOVF   x23,W
0AEA:  SUBLW  03
0AEC:  BNZ   0AFA
....................          read_all_holding(0,25); 
0AEE:  CLRF   xF9
0AF0:  MOVLW  19
0AF2:  MOVWF  xFA
0AF4:  MOVLB  0
0AF6:  BRA    06BA
0AF8:  MOVLB  4
....................       } 
....................       if(instruccion==5){ 
0AFA:  MOVF   x23,W
0AFC:  SUBLW  05
0AFE:  BNZ   0B14
....................          write_reg(address,reg); 
0B00:  CLRF   xFA
0B02:  MOVFF  424,4F9
0B06:  MOVFF  433,4FC
0B0A:  MOVFF  432,4FB
0B0E:  MOVLB  0
0B10:  BRA    0950
0B12:  MOVLB  4
....................          /* 
....................          if(address_ant!=address){ 
....................             address_ant=address; 
....................             if(reg_ant!=reg){ 
....................                reg_ant=reg; 
....................                write_reg(address,reg); 
....................             }          
....................          } 
....................          */ 
....................       }   
....................    } 
....................    Lee_Vector();    
0B14:  MOVLB  0
0B16:  RCALL  04C0
.................... } 
0B18:  BRA    0A84
.................... } 
0B1A:  SLEEP 

Configuration Fuses:
   Word  1: 0238   XTPLL NOIESO NOFCMEN PLL1 CPUDIV4 USBDIV
   Word  2: 1539   NOBROWNOUT WDT BORV20 NOPUT WDT1024 VREGEN
   Word  3: 0100   NOPBADEN CCP2C1 NOMCLR NOLPT1OSC
   Word  4: 0080   NOSTVREN NODEBUG NOLVP NOXINST
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
