CCS PCH C Compiler, Version 4.104, 5967               05-feb.-21 16:55

               Filename: D:\Laboratorio\Modulo Flujo Laminar\2021\JPCFLVMOD-2PM TOUCH Abaco OP202130 #0045884XX\Ejemplo MODBUS\PICmodbus-master - 4X20LCD -I2C\ex_modbus_master.lst

               ROM used: 2860 bytes (9%)
                         Largest free fragment is 29904
               RAM used: 1228 (60%) at main() level
                         1235 (60%) worst case
               Stack:    6 worst case (3 in main + 3 for interrupts)

*
0000:  GOTO   09C6
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  F9D.1
004A:  GOTO   0054
004E:  BTFSC  F9E.1
0050:  GOTO   02E0
0054:  BTFSS  F9D.5
0056:  GOTO   0060
005A:  BTFSC  F9E.5
005C:  GOTO   0368
0060:  BTFSS  F9D.3
0062:  GOTO   006C
0066:  BTFSC  F9E.3
0068:  GOTO   03E6
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                        ex_modbus_master.c                       //// 
.................... ////                                                                 //// 
.................... ////    This is a simple test program for a modbus master device.    //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Notes:                                                          //// 
.................... ////                                                                 //// 
.................... //// Testing Example:                                                //// 
.................... //// To test the master code you will need a slave device loaded     //// 
.................... //// with the ex_modbus_slave.c program (Note that you can test it   //// 
.................... //// with PC software as well.  See Communicating with PC Software.) //// 
.................... //// After making the proper connections (refer to wiring diagram)   //// 
.................... //// you should power on the slave device and then power on the      //// 
.................... //// master device.  The master device should begin sending commands //// 
.................... //// out and showing the replies from the slave through the PC       //// 
.................... //// connection.                                                     //// 
.................... ////                                                                 //// 
.................... //// Hardware UART:                                                  //// 
.................... //// If you use a hardware UART, make sure MODBUS_SERIAL_INT_SOURCE  //// 
.................... //// is set to MODBUS_INT_RDA or MODBUS_INT_RDA2 depending on which  //// 
.................... //// UART you are using.  Also, when using a hardware UART you do    ////  
.................... //// not need to specify the TX and RX pins.  The driver figures     ////  
.................... //// them out for you.                                               //// 
.................... ////                                                                 //// 
.................... //// Communicating with PC software:                                 //// 
.................... //// To communicate with a PC, connect the board to your computer    //// 
.................... //// using the serial cable provided with your board.  Then          //// 
.................... //// uncomment the #define USE_WITH_PC 1 line.  In this              //// 
.................... //// configuration the PIC is the master and the PC is the slave.    //// 
.................... ////                                                                 //// 
.................... //// Troubleshooting:                                                //// 
.................... //// If the device seems unresponsive, power cycle the board and     //// 
.................... //// wait 5 seconds.                                                 //// 
.................... ////                                                                 //// 
.................... //// Wiring Diagram:                                                 //// 
.................... //// This is the diagram for the default configuration.  Note that   ////  
.................... //// the external interrupt (INT), PIN B0, is the only pin that can  //// 
.................... //// be used for receiving with software RS232 for PCM and PCH, and  //// 
.................... //// for PCD the exteranl interrupt (INT0), usually PIN F6, is the   //// 
.................... //// only pin that can be used for receiving with software RS232.    //// 
.................... ////                                                                 //// 
.................... ////            PCH and PCM                        PCD               //// 
.................... ////    ----------     ----------       ----------     ----------    //// 
.................... ////    |        |     |        |       |        |     |        |    //// 
.................... ////    | Master |     | Slave  |       | Master |     | Slave  |    //// 
.................... ////    |        |     |        |       |        |     |        |    //// 
.................... ////    |      B1|---->|B0      |       |      D8|---->|F6      |    //// 
.................... ////    |      B0|<----|B1      |       |      F6|<----|D8      |    //// 
.................... ////    ----------     ----------       ----------     ----------    //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2006 Custom Computer Services        //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... //#define USE_WITH_PC 1 
....................  
.................... //#include <18f4620.h> 
.................... #include <18f2550.h> 
.................... //////// Standard Header file for the PIC18F2550 device //////////////// 
.................... #device PIC18F2550 
.................... #list 
....................  
.................... //#fuses HS,NOWDT,NOPROTECT,NOLVP,NODEBUG,NOSTVREN,NOPUT,NOCPD,NOWRT,NOIESO,NOFCMEN,NOPBADEN,NOWRTC,NOWRTB,NOEBTR,NOEBTRB,NOCPB,NOXINST,,NOLPT1OSC,NOMCLR 
.................... //#fuses XT,NOWDT,NOPROTECT,NOLVP,NODEBUG,NOSTVREN,NOPUT,NOCPD,NOWRT,NOIESO,NOFCMEN,NOPBADEN,NOWRTC,NOWRTB,NOEBTR,NOEBTRB,NOCPB,NOXINST,NOBROWNOUT,NOLPT1OSC,NOMCLR,NOUSBDIV,NOVREGEN,PLL1 
.................... //#fuses HS,NOWDT 
.................... //#use delay(clock=2M) 
.................... #fuses XTPLL,NOWDT,NOPROTECT,NOLVP,NODEBUG,USBDIV,PLL1,CPUDIV4,VREGEN,NOSTVREN,NOPUT,NOCPD,NOWRT,NOIESO,NOFCMEN,NOPBADEN,NOWRTC,NOWRTB,NOEBTR,NOEBTRB,NOCPB,NOXINST,NOBROWNOUT,NOLPT1OSC,NOMCLR 
.................... #use delay(clock=16000000) 
*
07E8:  MOVLW  04
07EA:  MOVWF  FEA
07EC:  MOVLW  CA
07EE:  MOVWF  FE9
07F0:  MOVF   FEF,W
07F2:  BZ    0810
07F4:  MOVLW  05
07F6:  MOVWF  01
07F8:  CLRF   00
07FA:  DECFSZ 00,F
07FC:  BRA    07FA
07FE:  DECFSZ 01,F
0800:  BRA    07F8
0802:  MOVLW  2E
0804:  MOVWF  00
0806:  DECFSZ 00,F
0808:  BRA    0806
080A:  BRA    080C
080C:  DECFSZ FEF,F
080E:  BRA    07F4
0810:  RETLW  00
.................... #use i2c(slave, slow, sda=PIN_B0, scl=PIN_B1, address=0xB0,force_HW, stream = i2cS) 
*
03CE:  MOVF   FC9,W
03D0:  MOVFF  4D1,FC9
03D4:  BSF    FC6.4
03D6:  BCF    F9E.3
03D8:  BTFSC  FC7.0
03DA:  BRA    03D8
03DC:  CLRF   01
03DE:  BTFSC  FC6.4
03E0:  INCF   01,F
03E2:  GOTO   041A (RETURN)
....................  
.................... #define   UP            !input(PIN_A5) 
.................... #define   DOWN          !input(PIN_E0) 
.................... #define   RIGHT         !input(PIN_E1) 
.................... #define   LEFT          !input(PIN_E2) 
....................  
.................... #define MODBUS_TYPE MODBUS_TYPE_MASTER 
.................... #define MODBUS_SERIAL_TYPE MODBUS_RTU     //use MODBUS_ASCII for ASCII mode 
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE 1023 
.................... #define MODBUS_SERIAL_BAUD 9600 
....................  
.................... //#ifndef USE_WITH_PC 
.................... //#use rs232(baud=9600, UART1, stream=PC, errors) 
.................... #use RS232(BAUD=9600, BITS=8, PARITY=N, XMIT=PIN_B4, RCV=PIN_B5,stream=PC, errors) 
*
0812:  BCF    F93.4
0814:  BCF    F8A.4
0816:  MOVLW  08
0818:  MOVWF  01
081A:  BRA    081C
081C:  NOP   
081E:  BSF    01.7
0820:  BRA    0842
0822:  BCF    01.7
0824:  MOVLB  4
0826:  RRCF   xCD,F
0828:  MOVLB  0
082A:  BTFSC  FD8.0
082C:  BSF    F8A.4
082E:  BTFSS  FD8.0
0830:  BCF    F8A.4
0832:  BSF    01.6
0834:  BRA    0842
0836:  BCF    01.6
0838:  DECFSZ 01,F
083A:  BRA    0824
083C:  BRA    083E
083E:  NOP   
0840:  BSF    F8A.4
0842:  MOVLW  84
0844:  MOVWF  FE9
0846:  DECFSZ FE9,F
0848:  BRA    0846
084A:  BRA    084C
084C:  NOP   
084E:  BTFSC  01.7
0850:  BRA    0822
0852:  BTFSC  01.6
0854:  BRA    0836
0856:  RETLW  00
.................... //#define MODBUS_SERIAL_INT_SOURCE MODBUS_INT_EXT 
.................... #define MODBUS_SERIAL_INT_SOURCE MODBUS_INT_RDA 
.................... #define MODBUS_SERIAL_TX_PIN PIN_C6   // Data transmit pin 
.................... #define MODBUS_SERIAL_RX_PIN PIN_C7   // Data receive pin 
.................... //The following should be defined for RS485 communication 
.................... #define MODBUS_SERIAL_ENABLE_PIN   PIN_C1   // Controls DE pin for RS485 
.................... #define MODBUS_SERIAL_RX_ENABLE    0   // Controls RE pin for RS485 
.................... #define DEBUG_MSG(msg) fprintf(PC, msg) 
.................... #define DEBUG_DATA(msg,data) fprintf(PC, msg, data) 
.................... //#else 
.................... //#define MODBUS_SERIAL_INT_SOURCE MODBUS_INT_EXT 
.................... //#define DEBUG_MSG(msg) if(0) 
.................... //#define DEBUG_DATA(msg,data) if(0) 
.................... //#endif 
....................  
.................... #include <modbus.c> 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                      modbus.c                                    //// 
.................... ////                                                                                  //// 
.................... ////                 MODBUS protocol driver for serial communications.                //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// DEFINES:                                                                         //// 
.................... ////                                                                                  //// 
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           //// 
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              //// 
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2,   //// 
.................... ////                                   MODBUS_INT_RDA3,MODBUS_INT_RDA4)               //// 
.................... ////  MODBUS_SERIAL_TYPE            MODBUS_RTU or MODBUS_ASCII                        //// 
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        //// 
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      //// 
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     //// 
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           //// 
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       //// 
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        //// 
.................... ////                                                                                  //// 
.................... ////                                                                                  //// 
.................... //// SHARED API:                                                                      //// 
.................... ////                                                                                  //// 
.................... ////  modbus_init()                                                                   //// 
.................... ////    - Initialize modbus serial communication system                               //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_start(address,func)                                          //// 
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data //// 
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_stop()                                                       //// 
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  //// 
.................... ////                                                                                  //// 
.................... ////  modbus_kbhit()                                                                  //// 
.................... ////    - Used to check if a packet has been received.                                //// 
.................... ////                                                                                  //// 
.................... //// MASTER API:                                                                      //// 
.................... ////  All master API functions return 0 on success.                                   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     //// 
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            //// 
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         //// 
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           //// 
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   //// 
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           //// 
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_exception_status(address)                                 //// 
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             //// 
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_counter(address)                                //// 
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_log(address)                                    //// 
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   //// 
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.//// 
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  //// 
.................... ////                    coils.                                                        //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)/// 
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. //// 
.................... ////    - Special Note: values is a pointer to an int8 array                          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_report_slave_id(address)                                       //// 
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  //// 
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 //// 
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)//// 
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,//// 
.................... ////                            write_start,write_quantity, *write_registers_value)   //// 
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          //// 
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////                                                                                  //// 
.................... //// Slave API:                                                                       //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_coils_rsp(address,byte_count,*coil_data)                       //// 
.................... ////    - Wrapper to respond to 0x01(read coils) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_discrete_input_rsp(address,byte_count,*input_data)             //// 
.................... ////    - Wrapper to respond to 0x02(read discret input) in the MODBUS specification. //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_holding_registers_rsp(address,byte_count,*reg_data)            //// 
.................... ////    - Wrapper to respond to 0x03(read holding regs) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_input_registers_rsp(address,byte_count,*input_data)            //// 
.................... ////    - Wrapper to respond to 0x04(read input regs) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_single_coil_rsp(address,output_address,output_value)          //// 
.................... ////    - Wrapper to respond to 0x05(write single coil) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_single_register_rsp(address,reg_address,reg_value)            //// 
.................... ////    - Wrapper to respond to 0x06(write single reg) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_exception_status_rsp(address, data)                            //// 
.................... ////    - Wrapper to respond to 0x07(read void status) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_diagnostics_rsp(address,sub_func,data)                              //// 
.................... ////    - Wrapper to respond to 0x08(diagnostics) in the MODBUS specification.        //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_get_comm_event_counter_rsp(address,status,event_count)              //// 
.................... ////    - Wrapper to respond to 0x0B(get comm event count) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_get_comm_event_log_rsp(address,status,event_count,message_count,    //// 
.................... ////                                   *events, events_len)                           //// 
.................... ////    - Wrapper to respond to 0x0C(get comm event log) in the MODBUS specification. //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_multiple_coils_rsp(address,start_address,quantity)            //// 
.................... ////    - Wrapper to respond to 0x0F(write multiple coils) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_multiple_registers_rsp(address,start_address,quantity)        //// 
.................... ////    - Wrapper to respond to 0x10(write multiple regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_report_slave_id_rsp(address,slave_id,run_status,*data,data_len)     //// 
.................... ////    - Wrapper to respond to 0x11(report slave id) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_file_record_rsp(address,byte_count,*request)                   //// 
.................... ////    - Wrapper to respond to 0x14(read file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_file_record_rsp(address,byte_count,*request)                  //// 
.................... ////    - Wrapper to respond to 0x15(write file record) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_mask_write_register_rsp(address,reference_address,AND_mask,OR_mask) //// 
.................... ////    - Wrapper to respond to 0x16(read coils) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_write_multiple_registers_rsp(address,*data,data_len)           //// 
.................... ////    - Wrapper to respond to 0x17(read write mult regs) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_FIFO_queue_rsp(address,FIFO_len,*data)                         //// 
.................... ////    - Wrapper to respond to 0x18(read FIFO queue) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_exception_rsp(int8 address, int16 func, exception error)            //// 
.................... ////    - Wrapper to send an exception response.  See exception list below.           //// 
.................... ////                                                                                  //// 
.................... //// Exception List:                                                                  //// 
.................... ////  ILLEGAL_FUNCTION, ILLEGAL_DATA_ADDRESS, ILLEGAL_DATA_VALUE,                     //// 
.................... ////  SLAVE_DEVICE_FAILURE, ACKNOWLEDGE, SLAVE_DEVICE_BUSY, MEMORY_PARITY_ERROR,      //// 
.................... ////  GATEWAY_PATH_UNAVAILABLE, GATEWAY_TARGET_NO_RESPONSE                            //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// Revision history:                                                                //// 
.................... ////  May 8, 2009          Made PCD Compatible                                        //// 
.................... ////  August 21, 2009      Added Modbus ASCII protocol                                //// 
.................... ////  September 25, 2009   Fixed Bug in RCV_ON function                               //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2006 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... /*Some defines so we can use identifiers to set things up*/ 
.................... #define MODBUS_TYPE_MASTER 99999 
.................... #define MODBUS_TYPE_SLAVE  88888 
.................... #define MODBUS_INT_RDA     77777 
.................... #define MODBUS_INT_RDA2    66666 
.................... #define MODBUS_INT_RDA3    44444 
.................... #define MODBUS_INT_RDA4    33333 
.................... #define MODBUS_INT_EXT     55555 
.................... #define MODBUS_RTU         1 
.................... #define MODBUS_ASCII       2 
....................  
.................... #ifndef MODBUS_TYPE 
.................... #define MODBUS_TYPE MODBUS_TYPE_MASTER 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_TYPE 
.................... #define MODBUS_SERIAL_TYPE MODBUS_RTU 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_INT_SOURCE 
.................... #define MODBUS_SERIAL_INT_SOURCE MODBUS_INT_RDA    // Select between external interrupt 
.................... #endif                                             // or asynchronous serial interrupt 
....................  
.................... #ifndef MODBUS_SERIAL_BAUD 
.................... #define MODBUS_SERIAL_BAUD 9600 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_RX_PIN 
.................... #define MODBUS_SERIAL_RX_PIN       PIN_C7   // Data receive pin 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_TX_PIN 
.................... #define MODBUS_SERIAL_TX_PIN       PIN_C6   // Data transmit pin 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_ENABLE_PIN 
.................... #define MODBUS_SERIAL_ENABLE_PIN   0   // Controls DE pin.  RX low, TX high. 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_RX_ENABLE 
.................... #define MODBUS_SERIAL_RX_ENABLE    0   // Controls RE pin.  Should keep low. 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_TIMEOUT 
....................    #if (MODBUS_SERIAL_TYPE == MODBUS_ASCII) 
....................       #define MODBUS_SERIAL_TIMEOUT    1000000 
....................    #else 
....................       #define MODBUS_SERIAL_TIMEOUT      10000     //in us 
....................    #endif 
.................... #endif 
....................  
.................... #if( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA ) 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART1, bits=8, stop=1, parity=N, stream=MODBUS_SERIAL, errors) 
*
0312:  BTFSS  F9E.5
0314:  BRA    0312
0316:  MOVFF  FAB,17
031A:  MOVFF  FAE,01
031E:  BTFSS  17.1
0320:  BRA    0326
0322:  BCF    FAB.4
0324:  BSF    FAB.4
0326:  RETLW  00
....................    #define RCV_OFF() {disable_interrupts(INT_RDA);} 
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2 ) 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART2, bits=8, stop=1, parity=N, stream=MODBUS_SERIAL, errors) 
....................    #define RCV_OFF() {disable_interrupts(INT_RDA2);} 
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3 ) 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART3, bits=8, stop=1, parity=N, stream=MODBUS_SERIAL, errors) 
....................    #define RCV_OFF() {disable_interrupts(INT_RDA3);} 
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4 ) 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART4, bits=8, stop=1, parity=N, stream=MODBUS_SERIAL, errors) 
....................    #define RCV_OFF() {disable_interrupts(INT_RDA4);} 
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_EXT ) 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, xmit=MODBUS_SERIAL_TX_PIN, rcv=MODBUS_SERIAL_RX_PIN, bits=8, stop=1, parity=N, stream=MODBUS_SERIAL, disable_ints) 
....................    #if defined(__PCD__) 
....................    #define RCV_OFF() {disable_interrupts(INT_EXT0);} 
....................    #else 
....................    #define RCV_OFF() {disable_interrupts(INT_EXT);} 
....................    #endif 
.................... #else 
....................    #error Please define a correct interrupt source 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_RX_BUFFER_SIZE 
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE  64      //size of send/rcv buffer 
.................... #endif 
....................  
.................... #if (MODBUS_TYPE == MODBUS_TYPE_MASTER) 
.................... int32 modbus_serial_wait=MODBUS_SERIAL_TIMEOUT; 
....................  
.................... #define MODBUS_SERIAL_WAIT_FOR_RESPONSE()\ 
.................... {\ 
....................     if(address)\ 
....................     {\ 
....................         while(!modbus_kbhit() && --modbus_serial_wait)\ 
....................             delay_us(1);\ 
....................         if(!modbus_serial_wait)\ 
....................             modbus_rx.error=TIMEOUT;\ 
....................     }\ 
....................     modbus_serial_wait = MODBUS_SERIAL_TIMEOUT;\ 
.................... } 
.................... #endif 
....................  
.................... #if (MODBUS_SERIAL_INT_SOURCE != MODBUS_INT_EXT) 
....................    #if defined(__PCD__) 
....................       #if (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA) 
....................          #word TXSTA=getenv("SFR:U1STA")  
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2) 
....................          #word TXSTA=getenv("SFR:U2STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3) 
....................          #word TXSTA=getenv("SFR:U3STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4) 
....................          #word TXSTA=getenv("SFR:U4STA") 
....................          #bit TRMT=TXSTA.8 
....................       #endif 
....................    #else 
....................       #byte TXSTA=getenv("sfr:TXSTA") 
....................       #bit TRMT=TXSTA.1 
....................    #endif 
....................  
.................... #define WAIT_FOR_HW_BUFFER()\ 
.................... {\ 
....................    while(!TRMT);\ 
.................... }    
.................... #endif 
....................  
.................... int1 modbus_serial_new=0; 
....................  
.................... /******************************************************************** 
.................... These exceptions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to communicate problems with the transmission back 
.................... to the master who can also use these to easily check the exceptions.   
.................... The first exception is the only one that is not part of the protocol  
.................... specification.  The TIMEOUT exception is returned when no slave  
.................... responds to the master's request within the timeout period. 
.................... ********************************************************************/ 
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2,  
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6,  
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11, 
.................... TIMEOUT=12} exception; 
....................  
.................... /******************************************************************** 
.................... These functions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to check the incomming function.  See  
.................... ex_modbus_slave.c for example usage. 
.................... ********************************************************************/ 
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02, 
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04, 
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06, 
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08, 
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C, 
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10, 
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14, 
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16, 
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function; 
....................      
.................... /*Stages of MODBUS reception.  Used to keep our ISR fast enough.*/ 
.................... #if (MODBUS_SERIAL_TYPE==MODBUS_ASCII) 
....................    enum {MODBUS_START=0, MODBUS_GETADDY, MODBUS_GETFUNC, MODBUS_GETDATA, MODBUS_STOP} modbus_serial_state=0; 
.................... #else 
....................    enum {MODBUS_GETADDY=0, MODBUS_GETFUNC=1, MODBUS_GETDATA=2} modbus_serial_state = 0; 
.................... #endif 
....................  
.................... /*Global value holding our current CRC value.*/ 
.................... #if (MODBUS_SERIAL_TYPE==MODBUS_ASCII) 
....................    unsigned int8 modbus_serial_lrc; 
.................... #else 
....................    union 
....................    { 
....................       int8 b[2]; 
....................       int16 d; 
....................    } modbus_serial_crc; 
.................... #endif 
....................  
.................... /******************************************************************** 
.................... Our receive struct.  This is used when receiving data as a master or 
.................... slave.  Once a message is sent to you with your address, you should 
.................... begin processing that message.  Refer to ex_modbus_slave.c to see  
.................... how to properly use this structure. 
.................... ********************************************************************/ 
.................... struct 
.................... { 
....................    int8 address; 
....................    int8 len;                                //number of bytes in the message received 
....................    function func;                           //the function of the message received 
....................    exception error;                         //error recieved, if any 
....................    int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received 
.................... } modbus_rx; 
....................  
.................... /* Table of CRC values for high–order byte */ 
.................... #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
.................... const unsigned char modbus_auchCRCHi[] = { 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40 
.................... }; 
....................  
.................... /* Table of CRC values for low–order byte */ 
.................... const char modbus_auchCRCLo[] = { 
.................... 0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4, 
.................... 0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09, 
.................... 0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD, 
.................... 0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3, 
.................... 0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7, 
.................... 0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A, 
.................... 0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE, 
.................... 0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26, 
.................... 0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2, 
.................... 0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F, 
.................... 0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB, 
.................... 0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5, 
.................... 0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91, 
.................... 0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C, 
.................... 0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88, 
.................... 0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C, 
.................... 0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80, 
.................... 0x40 
.................... }; 
.................... #endif 
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void) 
.................... { 
....................    #if (MODBUS_SERIAL_INT_SOURCE!=MODBUS_INT_EXT) 
....................       while(kbhit(MODBUS_SERIAL)) {fgetc(MODBUS_SERIAL);}  //Clear RX buffer. Clear RDA interrupt flag. Clear overrun error flag. 
*
0878:  BTFSS  F9E.5
087A:  BRA    0880
087C:  RCALL  0312
....................       #if (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA) 
087E:  BRA    0878
....................         clear_interrupt(INT_RDA); 
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA2) 
....................         clear_interrupt(INT_RDA2); 
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA3) 
....................         clear_interrupt(INT_RDA3); 
....................       #else 
....................         clear_interrupt(INT_RDA4); 
....................       #endif 
....................  
....................       #if (MODBUS_SERIAL_RX_ENABLE!=0)  
....................          output_low(MODBUS_SERIAL_RX_ENABLE); 
....................       #endif 
....................  
....................       #if (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA) 
....................         enable_interrupts(INT_RDA); 
0880:  BSF    F9D.5
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA2) 
....................         enable_interrupts(INT_RDA2); 
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA3) 
....................         enable_interrupts(INT_RDA3); 
....................       #else 
....................         enable_interrupts(INT_RDA4); 
....................       #endif 
....................    #else 
....................       #if defined(__PCD__) 
....................          clear_interrupt(INT_EXT0); 
....................       #else 
....................          clear_interrupt(INT_EXT); 
....................       #endif 
....................        
....................       ext_int_edge(H_TO_L); 
....................       
....................       #if (MODBUS_SERIAL_RX_ENABLE!=0)  
....................          output_low(MODBUS_SERIAL_RX_ENABLE); 
....................       #endif 
....................  
....................       #if defined(__PCD__) 
....................          enable_interrupts(INT_EXT0); 
....................       #else 
....................          enable_interrupts(INT_EXT); 
....................       #endif 
....................    #endif 
.................... } 
0882:  GOTO   088C (RETURN)
....................  
.................... // Purpose:    Initialize RS485 communication. Call this before 
.................... //             using any other RS485 functions. 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void modbus_init() 
.................... { 
....................    output_low(MODBUS_SERIAL_ENABLE_PIN); 
0886:  BCF    F94.1
0888:  BCF    F8B.1
....................  
....................    RCV_ON(); 
088A:  BRA    0878
....................  
....................    #if defined(__PCD__) 
....................       #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
....................          setup_timer2(TMR_INTERNAL | TMR_DIV_BY_8,4999); //~4ms interrupts for 20Mhz clock 
....................       #endif 
....................       enable_interrupts(INTR_GLOBAL); 
....................    #else 
....................       #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
....................          setup_timer_2(T2_DIV_BY_16,249,5);  //~4ms interrupts 
088C:  MOVLW  20
088E:  IORLW  06
0890:  MOVWF  FCA
0892:  MOVLW  F9
0894:  MOVWF  FCB
....................       #endif 
....................       enable_interrupts(GLOBAL); 
0896:  MOVLW  C0
0898:  IORWF  FF2,F
....................    #endif 
.................... } 
089A:  GOTO   0A8E (RETURN)
....................  
.................... // Purpose:    Start our timeout timer 
.................... // Inputs:     Enable, used to turn timer on/off 
.................... // Outputs:    None 
.................... // Not used for ASCII mode 
.................... #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
.................... void modbus_enable_timeout(int1 enable) 
.................... { 
....................    disable_interrupts(INT_TIMER2); 
*
02CE:  BCF    F9D.1
....................    if (enable) { 
02D0:  MOVLB  4
02D2:  MOVF   xD0,F
02D4:  BZ    02DC
....................       set_timer2(0); 
02D6:  CLRF   FCC
....................       clear_interrupt(INT_TIMER2); 
02D8:  BCF    F9E.1
....................       enable_interrupts(INT_TIMER2); 
02DA:  BSF    F9D.1
....................    } 
.................... } 
02DC:  MOVLB  0
02DE:  RETLW  00
.................... #endif 
....................  
.................... // Purpose:    Check if we have timed out waiting for a response 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... // Not used for ASCII mode 
.................... #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
....................    #int_timer2 
....................    void modbus_timeout_now(void) 
....................    { 
....................       if((modbus_serial_state == MODBUS_GETDATA) && (modbus_serial_crc.d == 0x0000) && (!modbus_serial_new)) 
02E0:  MOVF   1D,W
02E2:  SUBLW  02
02E4:  BNZ   02FA
02E6:  MOVF   1E,F
02E8:  BNZ   02FA
02EA:  MOVF   1F,F
02EC:  BNZ   02FA
02EE:  BTFSC  1C.0
02F0:  BRA    02FA
....................       { 
....................          modbus_rx.len-=2; 
02F2:  MOVLW  02
02F4:  SUBWF  21,F
....................          modbus_serial_new=TRUE; 
02F6:  BSF    1C.0
....................       } 
....................       else 
02F8:  BRA    02FC
....................          modbus_serial_new=FALSE; 
02FA:  BCF    1C.0
....................     
....................       modbus_serial_crc.d=0xFFFF; 
02FC:  MOVLW  FF
02FE:  MOVWF  1F
0300:  MOVWF  1E
....................       modbus_serial_state=MODBUS_GETADDY; 
0302:  CLRF   1D
....................       modbus_enable_timeout(FALSE); 
0304:  MOVLB  4
0306:  CLRF   xD0
0308:  MOVLB  0
030A:  RCALL  02CE
....................    } 
.................... #endif 
....................  
.................... // Purpose:    Calculate crc of data and updates global crc 
.................... // Inputs:     Character 
.................... // Outputs:    None 
030C:  BCF    F9E.1
030E:  GOTO   006C
.................... void modbus_calc_crc(char data) 
.................... { 
....................    #if (MODBUS_SERIAL_TYPE == MODBUS_ASCII) 
....................       modbus_serial_lrc+=data; 
....................    #else 
....................       unsigned int8 uIndex ; // will index into CRC lookup table 
....................  
....................       uIndex = (modbus_serial_crc.b[1]) ^ data; // calculate the CRC 
*
0328:  MOVF   1F,W
032A:  MOVLB  4
032C:  XORWF  xD0,W
032E:  MOVWF  xD1
....................       modbus_serial_crc.b[1] = (modbus_serial_crc.b[0]) ^ modbus_auchCRCHi[uIndex]; 
0330:  CLRF   03
0332:  MOVF   xD1,W
0334:  MOVFF  FF2,4D2
0338:  BCF    FF2.7
033A:  MOVLB  0
033C:  RCALL  00AE
033E:  MOVLB  4
0340:  BTFSC  xD2.7
0342:  BSF    FF2.7
0344:  MOVWF  01
0346:  MOVF   1E,W
0348:  XORWF  01,W
034A:  MOVWF  1F
....................       modbus_serial_crc.b[0] = modbus_auchCRCLo[uIndex]; 
034C:  CLRF   03
034E:  MOVF   xD1,W
0350:  MOVFF  FF2,4D2
0354:  BCF    FF2.7
0356:  MOVLB  0
0358:  RCALL  01BE
035A:  MOVLB  4
035C:  BTFSC  xD2.7
035E:  BSF    FF2.7
0360:  MOVWF  1E
....................    #endif 
.................... } 
0362:  MOVLB  0
0364:  GOTO   03B2 (RETURN)
....................  
.................... // Purpose:    Puts a character onto the serial line 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_putc(int8 c) 
.................... { 
....................    #if (MODBUS_SERIAL_TYPE==MODBUS_ASCII) 
....................       int8 asciih,asciil; 
....................        
....................       asciih=c>>4; 
....................       if(asciih>9) 
....................          asciih+=0x37; 
....................       else 
....................          asciih+=0x30; 
....................       asciil=c&0xF; 
....................       if(asciil>9) 
....................          asciil+=0x37; 
....................       else 
....................          asciil+=0x30; 
....................       fputc(asciih,MODBUS_SERIAL); 
....................       fputc(asciil,MODBUS_SERIAL); 
....................       modbus_calc_crc(c); 
....................    #else 
....................       fputc(c, MODBUS_SERIAL); 
....................       modbus_calc_crc(c); 
....................       delay_us(1000000/MODBUS_SERIAL_BAUD); //one stop bit.  not exact 
....................    #endif 
.................... } 
....................  
.................... // Purpose:   Interrupt service routine for handling incoming serial data 
.................... // Inputs:    None 
.................... // Outputs:   None 
.................... #if (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA) 
.................... #int_rda 
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA2) 
.................... #int_rda2 
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA3) 
.................... #int_rda3 
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA4) 
.................... #int_rda4 
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_EXT) 
.................... #if defined(__PCD__) 
.................... #int_ext0 
.................... #else 
.................... #int_ext 
.................... #endif 
.................... #else 
.................... #error Please define a correct interrupt source 
.................... #endif 
.................... void incomming_modbus_serial() { 
....................    char c; 
....................    #if (MODBUS_SERIAL_TYPE==MODBUS_ASCII) 
....................       static int1 two_characters=0; 
....................       static int8 datah,datal,data; 
....................    #endif 
....................  
....................    c=fgetc(MODBUS_SERIAL); 
0368:  RCALL  0312
036A:  MOVFF  01,4CF
....................     
....................    if (!modbus_serial_new) 
036E:  BTFSC  1C.0
0370:  BRA    03BC
....................    { 
....................       #if (MODBUS_SERIAL_TYPE==MODBUS_ASCII) 
....................          if(modbus_serial_state == MODBUS_START) 
....................          { 
....................             if(c==':') 
....................                modbus_serial_state++; 
....................          } 
....................          else if(modbus_serial_state == MODBUS_GETADDY) 
....................          { 
....................             if(!two_characters) 
....................             { 
....................                if(c>=0x41) 
....................                   datah=((c-0x37)<<4); 
....................                else 
....................                   datah=((c-0x30)<<4); 
....................                modbus_serial_lrc=0; 
....................             } 
....................             else 
....................             { 
....................                if(c>=0x41) 
....................                   datal=c-0x37; 
....................                else 
....................                   datal=c-0x30; 
....................                data=(datah | datal); 
....................                modbus_rx.address=data; 
....................                modbus_calc_crc(data); 
....................                modbus_serial_state++; 
....................             } 
....................             two_characters++; 
....................          } 
....................          else if(modbus_serial_state == MODBUS_GETFUNC) 
....................          { 
....................             if(!two_characters) 
....................             { 
....................                if(c>=0x41) 
....................                   datah=((c-0x37)<<4); 
....................                else 
....................                   datah=((c-0x30)<<4); 
....................             } 
....................             else 
....................             { 
....................                if(c>=0x41) 
....................                   datal=c-0x37; 
....................                else 
....................                   datal=c-0x30; 
....................                data=(datah | datal); 
....................                modbus_rx.func=data; 
....................                modbus_calc_crc(data); 
....................                modbus_serial_state++; 
....................                modbus_rx.len=0; 
....................                modbus_rx.error=0; 
....................             } 
....................             two_characters++; 
....................          } 
....................          else if(modbus_serial_state == MODBUS_GETDATA) 
....................          { 
....................             if(c=='\r') 
....................             { 
....................                modbus_serial_state++; 
....................                modbus_rx.len--; 
....................                modbus_serial_lrc-=data; 
....................             } 
....................             else if(!two_characters) 
....................             { 
....................                if(c>=0x41) 
....................                   datah=((c-0x37)<<4); 
....................                else 
....................                   datah=((c-0x30)<<4); 
....................                two_characters++; 
....................             } 
....................             else 
....................             { 
....................                if(c>=0x41) 
....................                   datal=c-0x37; 
....................                else 
....................                   datal=c-0x30; 
....................                data=(datah | datal); 
....................                if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) 
....................                   modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1; 
....................                modbus_rx.data[modbus_rx.len]=data; 
....................                modbus_rx.len++; 
....................                modbus_calc_crc(data); 
....................                two_characters++; 
....................             } 
....................          } 
....................          else if(modbus_serial_state==MODBUS_STOP) 
....................          { 
....................             if(c=='\n') 
....................             { 
....................                modbus_serial_lrc=((0xFF-modbus_serial_lrc)+1); 
....................                if(modbus_serial_lrc==data) 
....................                   modbus_serial_new=TRUE; 
....................             } 
....................             modbus_serial_state=MODBUS_START; 
....................             two_characters=0; 
....................          } 
....................       #else 
....................              
....................          if(modbus_serial_state == MODBUS_GETADDY) 
0372:  MOVF   1D,F
0374:  BNZ   0388
....................          { 
....................             modbus_serial_crc.d = 0xFFFF; 
0376:  MOVLW  FF
0378:  MOVWF  1F
037A:  MOVWF  1E
....................             modbus_rx.address = c; 
037C:  MOVFF  4CF,20
....................             modbus_serial_state++; 
0380:  INCF   1D,F
....................             modbus_rx.len = 0; 
0382:  CLRF   21
....................             modbus_rx.error=0; 
0384:  CLRF   23
....................          } 
....................          else if(modbus_serial_state == MODBUS_GETFUNC) 
0386:  BRA    03AC
0388:  DECFSZ 1D,W
038A:  BRA    0394
....................          { 
....................             modbus_rx.func = c; 
038C:  MOVFF  4CF,22
....................             modbus_serial_state++; 
0390:  INCF   1D,F
....................          } 
....................          else if(modbus_serial_state == MODBUS_GETDATA) 
0392:  BRA    03AC
0394:  MOVF   1D,W
0396:  SUBLW  02
0398:  BNZ   03AC
....................          { 
....................             if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) {modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1;} 
....................             modbus_rx.data[modbus_rx.len]=c; 
039A:  MOVLW  24
039C:  ADDWF  21,W
039E:  MOVWF  FE9
03A0:  CLRF   FEA
03A2:  BTFSC  FD8.0
03A4:  INCF   FEA,F
03A6:  MOVFF  4CF,FEF
....................             modbus_rx.len++; 
03AA:  INCF   21,F
....................          } 
....................     
....................          modbus_calc_crc(c); 
03AC:  MOVFF  4CF,4D0
03B0:  BRA    0328
....................          modbus_enable_timeout(TRUE); 
03B2:  MOVLW  01
03B4:  MOVLB  4
03B6:  MOVWF  xD0
03B8:  MOVLB  0
03BA:  RCALL  02CE
....................       #endif 
....................    } 
....................    #if (MODBUS_TYPE == MODBUS_TYPE_MASTER) 
....................       modbus_serial_wait=MODBUS_SERIAL_TIMEOUT; 
03BC:  CLRF   1B
03BE:  CLRF   1A
03C0:  MOVLW  27
03C2:  MOVWF  19
03C4:  MOVLW  10
03C6:  MOVWF  18
....................    #endif 
.................... } 
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... //             4) The length of the data 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
03C8:  BCF    F9E.5
03CA:  GOTO   006C
.................... void modbus_serial_send_start(int8 to, int8 func) 
.................... { 
....................    #if (MODBUS_SERIAL_TYPE==MODBUS_ASCII) 
....................       modbus_serial_lrc=0; 
....................    #else 
....................       modbus_serial_crc.d=0xFFFF; 
....................    #endif 
....................    modbus_serial_new=FALSE; 
....................  
....................    RCV_OFF(); 
....................     
.................... #if (MODBUS_SERIAL_ENABLE_PIN!=0)  
....................    output_high(MODBUS_SERIAL_ENABLE_PIN); 
.................... #endif 
....................  
....................    #if (MODBUS_SERIAL_TYPE==MODBUS_RTU) 
....................       delay_us(3500000/MODBUS_SERIAL_BAUD); //3.5 character delay 
....................    #else 
....................       fputc(':',MODBUS_SERIAL); 
....................    #endif 
....................  
....................    modbus_serial_putc(to); 
....................    modbus_serial_putc(func); 
.................... } 
....................  
.................... void modbus_serial_send_stop() 
.................... { 
....................    #if (MODBUS_SERIAL_TYPE == MODBUS_ASCII) 
....................       int8 i; 
....................        
....................       for(i=0;i<8;i++) 
....................       { 
....................          if(bit_test(modbus_serial_lrc,i)) 
....................             bit_clear(modbus_serial_lrc,i); 
....................          else 
....................             bit_set(modbus_serial_lrc,i); 
....................       } 
....................       modbus_serial_lrc++; 
....................        
....................       modbus_serial_putc(modbus_serial_lrc); 
....................       fputc('\r',MODBUS_SERIAL); 
....................       fputc('\n',MODBUS_SERIAL); 
....................    #else 
....................       int8 crc_low, crc_high; 
....................     
....................       crc_high=modbus_serial_crc.b[1]; 
....................       crc_low=modbus_serial_crc.b[0]; 
....................     
....................       modbus_serial_putc(crc_high); 
....................       modbus_serial_putc(crc_low); 
....................    #endif 
....................     
.................... #if (MODBUS_SERIAL_INT_SOURCE!=MODBUS_INT_EXT) 
....................    WAIT_FOR_HW_BUFFER(); 
.................... #endif 
....................     
....................    #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
....................       delay_us(3500000/MODBUS_SERIAL_BAUD); //3.5 character delay 
....................    #endif 
....................  
....................    RCV_ON(); 
....................  
.................... #if (MODBUS_SERIAL_ENABLE_PIN!=0)  
....................    output_low(MODBUS_SERIAL_ENABLE_PIN); 
.................... #endif 
....................  
....................    #if (MODBUS_SERIAL_TYPE == MODBUS_ASCII) 
....................       modbus_serial_lrc=0; 
....................    #else 
....................       modbus_serial_crc.d=0xFFFF; 
....................    #endif 
.................... } 
....................  
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer 
.................... // Inputs:     None 
.................... // Outputs:    TRUE if a message was received 
.................... //             FALSE if no message is available 
.................... // Note:       Data will be filled in at the modbus_rx struct: 
.................... int1 modbus_kbhit() 
.................... { 
....................    if(!modbus_serial_new) 
....................       return FALSE; 
....................    else if(modbus_rx.func & 0x80)           //did we receive an error? 
....................    { 
....................       modbus_rx.error = modbus_rx.data[0];  //if so grab the error and return true 
....................       modbus_rx.len = 1; 
....................    } 
....................    modbus_serial_new=FALSE; 
....................    return TRUE; 
.................... } 
....................  
.................... #if (MODBUS_TYPE==MODBUS_TYPE_MASTER) 
.................... /*MODBUS Master Functions*/ 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request.  These 
.................... functions take in one of these structs. 
.................... Please refer to the MODBUS protocol specification if you do not 
.................... understand the members of the structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
.................... } modbus_read_sub_request; 
....................  
.................... typedef struct _modbus_write_sub_request 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
....................    int16 data[MODBUS_SERIAL_RX_BUFFER_SIZE-8]; 
.................... } modbus_write_sub_request; 
....................  
....................  
.................... /******************************************************************** 
.................... The following functions are defined in the MODBUS protocol.  Please 
.................... refer to http://www.modbus.org for the purpose of each of these. 
.................... All functions take the slaves address as their first parameter. 
.................... Each function returns the exception code received from the response. 
.................... The function will return 0 if there were no errors in transmission. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_coils(int8 address, int16 start_address, int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................     
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_discrete_input 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_discrete_input(int8 address, int16 start_address, int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................        
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_holding_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_holding_registers(int8 address, int16 start_address, int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................     
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_input_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_input_registers(int8 address, int16 start_address, int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................     
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_single_coil 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Address to write into 
....................            int1       on                 true for on, false for off 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_single_coil(int8 address, int16 output_address, int1 on) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
....................    modbus_serial_putc(make8(output_address,0)); 
....................  
....................    if(on) 
....................        modbus_serial_putc(0xFF); 
....................    else 
....................        modbus_serial_putc(0x00); 
....................     
....................    modbus_serial_putc(0x00); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_single_register 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Address to write into 
....................            int16      reg_value          Value to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_single_register(int8 address, int16 reg_address, int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
....................    modbus_serial_putc(make8(reg_address,0)); 
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
....................    modbus_serial_putc(make8(reg_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................     
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_exception_status 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_exception_status(int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... diagnostics 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Subfunction to send 
....................            int16      data               Data to send, changes based on subfunction 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_diagnostics(int8 address, int16 sub_func, int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... get_comm_event_couter 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_get_comm_event_counter(int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... get_comm_event_log 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_get_comm_event_log(int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start at 
....................            int16      quantity           Amount of coils to write to 
....................            int1*      values             A pointer to an array holding the values to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_multiple_coils(int8 address, int16 start_address, int16 quantity, 
....................                            int8 *values) 
.................... { 
....................    int8 i,count; 
....................     
....................    count = (int8)((quantity/8)); 
....................     
....................    if(quantity%8) 
....................       count++;       
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_putc(count); 
....................  
....................    for(i=0; i < count; ++i)  
....................       modbus_serial_putc(values[i]); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_multiple_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start at 
....................            int16      quantity           Amount of coils to write to 
....................            int16*     values             A pointer to an array holding the data to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_multiple_registers(int8 address, int16 start_address, int16 quantity, 
....................                            int16 *values) 
.................... { 
....................    int8 i,count; 
....................     
....................    count = quantity*2; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................     
....................    modbus_serial_putc(count); 
....................  
....................    for(i=0; i < quantity; ++i) 
....................    { 
....................       modbus_serial_putc(make8(values[i],1)); 
....................       modbus_serial_putc(make8(values[i],0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... report_slave_id 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_report_slave_id(int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_file_record 
.................... Input:     int8                address            Slave Address 
....................            int8                byte_count         Number of bytes to read 
....................            read_sub_request*   request            Structure holding record information 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_file_record(int8 address, int8 byte_count,  
....................                             modbus_read_sub_request *request) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < (byte_count/7); i+=7) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_file_record 
.................... Input:     int8                address            Slave Address 
....................            int8                byte_count         Number of bytes to read 
....................            read_sub_request*   request            Structure holding record/data information 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_file_record(int8 address, int8 byte_count,  
....................                             modbus_write_sub_request *request) 
.................... { 
....................    int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length) &&  
....................             (j < MODBUS_SERIAL_RX_BUFFER_SIZE-8); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... mask_write_register 
.................... Input:     int8       address            Slave Address 
....................            int16      reference_address  Address to mask 
....................            int16      AND_mask           A mask to AND with the data at reference_address 
....................            int16      OR_mask            A mask to OR with the data at reference_address 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_mask_write_register(int8 address, int16 reference_address, 
....................                            int16 AND_mask, int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers 
.................... Input:     int8       address                Slave Address 
....................            int16      read_start             Address to start reading 
....................            int16      read_quantity          Amount of registers to read 
....................            int16      write_start            Address to start writing 
....................            int16      write_quantity         Amount of registers to write 
....................            int16*     write_registers_value  Pointer to an aray us to write 
.................... Output:    exception                         0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_write_multiple_registers(int8 address, int16 read_start, 
....................                                     int16 read_quantity, int16 write_start, 
....................                                     int16 write_quantity, 
....................                                     int16 *write_registers_value) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(read_start,1)); 
....................    modbus_serial_putc(make8(read_start,0)); 
....................  
....................    modbus_serial_putc(make8(read_quantity,1)); 
....................    modbus_serial_putc(make8(read_quantity,0)); 
....................  
....................    modbus_serial_putc(make8(write_start, 1)); 
....................    modbus_serial_putc(make8(write_start, 0)); 
....................  
....................    modbus_serial_putc(make8(write_quantity, 1)); 
....................    modbus_serial_putc(make8(write_quantity, 0)); 
....................  
....................    modbus_serial_putc((int8)(2*write_quantity)); 
....................  
....................    for(i=0; i < write_quantity ; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(write_registers_value[i], 1)); 
....................       modbus_serial_putc(make8(write_registers_value[i+1], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue 
.................... Input:     int8       address           Slave Address 
....................            int16      FIFO_address      FIFO address 
.................... Output:    exception                    0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_FIFO_queue(int8 address, int16 FIFO_address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(FIFO_address, 1)); 
....................    modbus_serial_putc(make8(FIFO_address, 0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... #else 
.................... /*MODBUS Slave Functions*/ 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request_rsp.  These 
.................... functions take in one of these structs.  Please refer to the MODBUS 
.................... protocol specification if you do not understand the members of the 
.................... structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request_rsp 
.................... { 
....................    int8 record_length; 
....................    int8 reference_type; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3]; 
.................... } modbus_read_sub_request_rsp; 
....................  
.................... typedef struct _modbus_write_sub_request_rsp 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8]; 
.................... } modbus_write_sub_request_rsp; 
....................  
....................  
.................... /******************************************************************** 
.................... The following slave functions are defined in the MODBUS protocol. 
.................... Please refer to http://www.modbus.org for the purpose of each of 
.................... these.  All functions take the slaves address as their first 
.................... parameter. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      coil_data          Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_coils_rsp(int8 address, int8 byte_count, int8* coil_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*coil_data); 
....................       coil_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_discrete_input_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_discrete_input_rsp(int8 address, int8 byte_count,  
....................                                     int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_holding_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      reg_data           Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_holding_registers_rsp(int8 address, int8 byte_count,  
....................                                         int16 *reg_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(*reg_data,1)); 
....................       modbus_serial_putc(make8(*reg_data,0)); 
....................       reg_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_input_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_input_registers_rsp(int8 address, int8 byte_count,  
....................                                         int16 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(*input_data,1)); 
....................       modbus_serial_putc(make8(*input_data,0)); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_coil_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Echo of output address received 
....................            int16      output_value       Echo of output value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_coil_rsp(int8 address, int16 output_address,  
....................                                     int16 output_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
....................    modbus_serial_putc(make8(output_address,0)); 
....................  
....................    modbus_serial_putc(make8(output_value,1)); 
....................    modbus_serial_putc(make8(output_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_register_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Echo of register address received 
....................            int16      reg_value          Echo of register value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_register_rsp(int8 address, int16 reg_address,  
....................                                         int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
....................    modbus_serial_putc(make8(reg_address,0)); 
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
....................    modbus_serial_putc(make8(reg_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_exception_status_rsp 
.................... Input:     int8       address            Slave Address 
.................... Output:    void 
.................... */ 
.................... void modbus_read_exception_status_rsp(int8 address, int8 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... diagnostics_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Echo of sub function received 
....................            int16      data               Echo of data received 
.................... Output:    void 
.................... */ 
.................... void modbus_diagnostics_rsp(int8 address, int16 sub_func, int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_counter_rsp(int8 address, int16 status,  
....................                                         int16 event_count) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
....................            int16      message_count      Count of messages 
....................            int8*      events             Pointer to event data 
....................            int8       events_len         Length of event data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_log_rsp(int8 address, int16 status, 
....................                                     int16 event_count, int16 message_count,  
....................                                     int8 *events, int8 events_len) 
.................... { 
....................    int8 i; 
....................      
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................  
....................    modbus_serial_putc(events_len+6); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_putc(make8(message_count, 1)); 
....................    modbus_serial_putc(make8(message_count, 0)); 
....................  
....................    for(i=0; i < events_len; ++i) 
....................    { 
....................       modbus_serial_putc(*events); 
....................       events++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of coils written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_coils_rsp(int8 address, int16 start_address,  
....................                                         int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of registers written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_registers_rsp(int8 address, int16 start_address,  
....................                                             int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... report_slave_id_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       slave_id           Slave Address 
....................            int8       run_status         Are we running? 
....................            int8*      data               Pointer to an array holding the data 
....................            int8       data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_report_slave_id_rsp(int8 address, int8 slave_id, int1 run_status, 
....................                               int8 *data, int8 data_len) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................  
....................    modbus_serial_putc(data_len+2); 
....................    modbus_serial_putc(slave_id); 
....................  
....................    if(run_status) 
....................     modbus_serial_putc(0xFF); 
....................    else 
....................     modbus_serial_putc(0x00); 
....................  
....................    for(i=0; i < data_len; ++i) 
....................    { 
....................       modbus_serial_putc(*data); 
....................       data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Number of bytes to send 
....................            read_sub_request_rsp*    request            Structure holding record/data information 
.................... Output:    void 
.................... */ 
.................... void modbus_read_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_read_sub_request_rsp *request) 
.................... { 
....................    int8 i=0,j; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    while(i < byte_count); 
....................    { 
....................       modbus_serial_putc(request->record_length); 
....................       modbus_serial_putc(request->reference_type); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................  
....................       i += (request->record_length)+1; 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Echo of number of bytes sent 
....................            write_sub_request_rsp*   request            Echo of Structure holding record information 
.................... Output:    void 
.................... */ 
.................... void modbus_write_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_write_sub_request_rsp *request) 
.................... { 
....................    int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... mask_write_register_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       reference_address  Echo of reference address 
....................            int16       AND_mask           Echo of AND mask 
....................            int16       OR_mask            Echo or OR mask 
.................... Output:    void 
.................... */ 
.................... void modbus_mask_write_register_rsp(int8 address, int16 reference_address, 
....................                            int16 AND_mask, int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16*      data               Pointer to an array of data 
....................            int8        data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_read_write_multiple_registers_rsp(int8 address, int8 data_len,  
....................                                                 int16 *data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(data_len*2); 
....................  
....................    for(i=0; i < data_len*2; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       FIFO_len           Length of FIFO in bytes 
....................            int16*      data               Pointer to an array of data 
.................... Output:    void 
.................... */ 
.................... void modbus_read_FIFO_queue_rsp(int8 address, int16 FIFO_len, int16 *data) 
.................... { 
....................    int8 i; 
....................    int16 byte_count; 
....................  
....................    byte_count = ((FIFO_len*2)+2); 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(byte_count, 1)); 
....................    modbus_serial_putc(make8(byte_count, 0)); 
....................  
....................    modbus_serial_putc(make8(FIFO_len, 1)); 
....................    modbus_serial_putc(make8(FIFO_len, 0)); 
....................  
....................    for(i=0; i < FIFO_len; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... void modbus_exception_rsp(int8 address, int16 func, exception error) 
.................... { 
....................    modbus_serial_send_start(address, func|0x80); 
....................    modbus_serial_putc(error); 
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... #endif 
....................  
.................... //#include "lcd.c" 
....................  
.................... #define MODBUS_SLAVE_ADDRESS 0x01 
....................  
.................... // Variables para Pt100 
.................... int8 instruccion=0,address=0,regl=0,regh=0,i=0; 
.................... int16 reg=0; 
....................  
.................... int8 fstate;                     //Guardara el estado del bus I2C 
.................... int8 posicion, buffer[50], txbuf[50],rxbuf[50];     //Buffer de memoria 
....................  
....................  
.................... #INT_SSP 
.................... void ssp_interupt (){ 
....................     
....................    int incoming;                //Variable donde se recibe el byte que manda el maestro 
....................     
....................    fstate = i2c_isr_state(i2cs);    //Lectura del estado del bus I2c la interrupción 
*
03E6:  BTFSC  FC7.5
03E8:  BRA    03F2
03EA:  MOVLB  4
03EC:  CLRF   xC2
03EE:  BTFSC  FC7.2
03F0:  BSF    xC2.7
03F2:  MOVLB  4
03F4:  MOVF   xC2,W
03F6:  INCF   xC2,F
03F8:  MOVWF  x2A
....................  
....................    /* Solicitud de lectura del esclavo por el master */ 
....................    if(fstate == 0x80) {          
03FA:  MOVF   x2A,W
03FC:  SUBLW  80
03FE:  BNZ   041E
....................        //Manda al maestro la información contenida en la posición de memoria que le ha solicitado 
....................       i2c_write (i2cs,txbuf[posicion]); 
0400:  CLRF   03
0402:  MOVF   x2B,W
0404:  ADDLW  5E
0406:  MOVWF  FE9
0408:  MOVLW  04
040A:  ADDWFC 03,W
040C:  MOVWF  FEA
040E:  MOVFF  FEF,4D0
0412:  MOVFF  4D0,4D1
0416:  MOVLB  0
0418:  BRA    03CE
....................    } 
.................... /* Sino está solicitando lectura es que está enviando algo */ 
....................    else {                              //Sino es que hay dato en el bus I2C... 
041A:  BRA    044E
041C:  MOVLB  4
....................       incoming = i2c_read(i2cs);           //... lo lee 
041E:  BCF    FC6.6
0420:  BTFSS  F9E.3
0422:  BRA    0420
0424:  MOVF   FC9,W
0426:  BSF    FC6.4
0428:  MOVWF  xCF
....................       if (fState == 1) {          //Información recibida corresponde a la posicion 
042A:  DECFSZ x2A,W
042C:  BRA    0434
....................          posicion = incoming;          //Se guarda posición 
042E:  MOVFF  4CF,42B
....................       } 
....................       else if (fState == 2) {          //Información recibida corresponde al dato 
0432:  BRA    044C
0434:  MOVF   x2A,W
0436:  SUBLW  02
0438:  BNZ   044C
....................          rxbuf[posicion] = incoming; 
043A:  CLRF   03
043C:  MOVF   x2B,W
043E:  ADDLW  90
0440:  MOVWF  FE9
0442:  MOVLW  04
0444:  ADDWFC 03,W
0446:  MOVWF  FEA
0448:  MOVFF  4CF,FEF
044C:  MOVLB  0
....................       } 
....................   } 
.................... } 
....................  
044E:  BCF    F9E.3
0450:  GOTO   006C
.................... void Lee_Vector(void){ 
....................    instruccion=rxbuf[0]; 
*
08C2:  MOVFF  490,423
....................    address=rxbuf[1]; 
08C6:  MOVFF  491,424
....................    regl=rxbuf[2]; 
08CA:  MOVFF  492,425
....................    regh=rxbuf[3]; 
08CE:  MOVFF  493,426
....................    reg=(regh*256)+regl; 
08D2:  MOVLB  4
08D4:  CLRF   xCB
08D6:  MOVFF  426,4CA
08DA:  MOVLW  01
08DC:  MOVWF  xCD
08DE:  CLRF   xCC
08E0:  MOVLB  0
08E2:  BRA    089E
08E4:  MOVLB  4
08E6:  MOVF   x25,W
08E8:  ADDWF  01,W
08EA:  MOVWF  x28
08EC:  MOVLW  00
08EE:  ADDWFC 02,W
08F0:  MOVWF  x29
.................... } 
08F2:  MOVLB  0
08F4:  RETLW  00
....................  
....................  
.................... /*This function may come in handy for you since MODBUS uses MSB first.*/ 
.................... int8 swap_bits(int8 c) 
.................... { 
....................    return ((c&1)?128:0)|((c&2)?64:0)|((c&4)?32:0)|((c&8)?16:0)|((c&16)?8:0) 
....................           |((c&32)?4:0)|((c&64)?2:0)|((c&128)?1:0); 
.................... } 
....................  
.................... void print_menu() 
.................... { 
....................    DEBUG_MSG("\r\nPick command to send\r\n1. Read all coils.\r\n"); 
....................    DEBUG_MSG("2. Read all inputs.\r\n3. Read all holding registers.\r\n"); 
....................    DEBUG_MSG("4. Read all input registers.\r\n5. Turn coil 6 on.\r\n6. "); 
....................    DEBUG_MSG("Write 0x4444 to register 0x03\r\n7. Set 8 coils using 0x50 as mask\r\n"); 
....................    DEBUG_MSG("8. Set 2 registers to 0x1111, 0x2222\r\n9. Send unknown command\r\n"); 
.................... } 
....................  
.................... void read_all_coils() 
.................... { 
....................    DEBUG_MSG("Coils:\r\n"); 
....................    if(!(modbus_read_coils(MODBUS_SLAVE_ADDRESS,0,8))) 
....................    { 
....................       DEBUG_MSG("Data: "); 
....................       /*Started at 1 since 0 is quantity of coils*/ 
....................       for(i=1; i < (modbus_rx.len); ++i) 
....................          DEBUG_DATA("%X ", modbus_rx.data[i]); 
....................       DEBUG_MSG("\r\n\r\n"); 
....................    } 
....................    else 
....................    { 
....................       DEBUG_DATA("<-**Exception %X**->\r\n\r\n", modbus_rx.error); 
....................    } 
.................... } 
....................  
.................... void read_all_inputs() 
.................... { 
....................    DEBUG_MSG("Inputs:\r\n"); 
....................    if(!(modbus_read_discrete_input(MODBUS_SLAVE_ADDRESS,0,8))) 
....................    { 
....................       DEBUG_MSG("Data: "); 
....................       /*Started at 1 since 0 is quantity of coils*/ 
....................       for(i=1; i < (modbus_rx.len); ++i) 
....................          DEBUG_DATA("%X ", modbus_rx.data[i]); 
....................       DEBUG_MSG("\r\n\r\n"); 
....................    } 
....................    else 
....................    { 
....................       DEBUG_DATA("<-**Exception %X**->\r\n\r\n", modbus_rx.error); 
....................    } 
.................... } 
....................  
.................... void read_all_holding(int8 start,int8 size) 
.................... { 
....................    DEBUG_MSG("Holding Registers:\r\n"); 
....................    if(!(modbus_read_holding_registers(MODBUS_SLAVE_ADDRESS,start,size))) 
....................    { 
....................       DEBUG_MSG("Data: "); 
....................       /*Started at 1 since 0 is quantity of coils*/ 
....................       for(i=1; i < (modbus_rx.len); ++i) 
....................          DEBUG_DATA("%X ", modbus_rx.data[i]); 
....................       DEBUG_MSG("\r\n\r\n"); 
....................       output_bit(PIN_B7,0); 
....................    }  
....................    else 
....................    { 
....................       DEBUG_DATA("<-**Exception %X**->\r\n\r\n", modbus_rx.error); 
....................       output_bit(PIN_B7,1); 
....................    } 
.................... } 
....................  
.................... void read_all_input_reg(int8 start,int8 size) 
.................... { 
....................    DEBUG_MSG("Input Registers:\r\n"); 
....................    if(!(modbus_read_input_registers(MODBUS_SLAVE_ADDRESS,start,size))) 
....................    { 
....................       DEBUG_MSG("Data: "); 
....................       /*Started at 1 since 0 is quantity of coils*/ 
....................       for(i=1; i < (modbus_rx.len); ++i) 
....................          DEBUG_DATA("%X ", modbus_rx.data[i]);        
....................         
....................        DEBUG_MSG("\r\n\r\n"); 
....................  
....................    } 
....................    else 
....................    { 
....................       DEBUG_DATA("<-**Exception %X**->\r\n\r\n", modbus_rx.error); 
....................       output_bit(PIN_B7,1); 
....................    } 
.................... } 
....................  
.................... void write_coil() 
.................... { 
....................    DEBUG_MSG("Writing Single Coil:\r\n"); 
....................    if(!(modbus_write_single_coil(MODBUS_SLAVE_ADDRESS,6,TRUE))) 
....................    { 
....................       DEBUG_MSG("Data: "); 
....................       for(i=0; i < (modbus_rx.len); ++i) 
....................          DEBUG_DATA("%X ", modbus_rx.data[i]); 
....................       DEBUG_MSG("\r\n\r\n"); 
....................    } 
....................    else 
....................    { 
....................       DEBUG_DATA("<-**Exception %X**->\r\n\r\n", modbus_rx.error); 
....................    }    
.................... } 
....................  
.................... void write_reg(int16 address,int16 reg) 
.................... { 
....................    DEBUG_MSG("Writing Single Register:\r\n"); 
....................    if(!(modbus_write_single_register(MODBUS_SLAVE_ADDRESS,address,reg))) 
....................    { 
....................       DEBUG_MSG("Data: "); 
....................       for(i=0; i < (modbus_rx.len); ++i) 
....................          DEBUG_DATA("%X ", modbus_rx.data[i]); 
....................       DEBUG_MSG("\r\n\r\n"); 
....................       output_bit(PIN_B7,0); 
....................    } 
....................    else 
....................    { 
....................       DEBUG_DATA("<-**Exception %X**->\r\n\r\n", modbus_rx.error); 
....................       output_bit(PIN_B7,1); 
....................    } 
.................... } 
....................  
.................... void write_coils() 
.................... { 
....................    int8 coils[1] = { 0x50 }; 
....................    DEBUG_MSG("Writing Multiple Coils:\r\n"); 
....................    if(!(modbus_write_multiple_coils(MODBUS_SLAVE_ADDRESS,0,8,coils))) 
....................    { 
....................       DEBUG_MSG("Data: "); 
....................       for(i=0; i < (modbus_rx.len); ++i) 
....................          DEBUG_DATA("%X ", modbus_rx.data[i]); 
....................       DEBUG_MSG("\r\n\r\n"); 
....................    } 
....................    else 
....................    { 
....................       DEBUG_DATA("<-**Exception %X**->\r\n\r\n", modbus_rx.error); 
....................    }    
.................... } 
....................  
.................... void write_regs() 
.................... { 
....................    int16 reg_array[2] = {0x1111, 0x2222}; 
....................    DEBUG_MSG("Writing Multiple Registers:\r\n"); 
....................    if(!(modbus_write_multiple_registers(MODBUS_SLAVE_ADDRESS,0,2,reg_array))) 
....................    { 
....................       DEBUG_MSG("Data: "); 
....................       for(i=0; i < (modbus_rx.len); ++i) 
....................          DEBUG_DATA("%X ", modbus_rx.data[i]); 
....................       DEBUG_MSG("\r\n\r\n"); 
....................    } 
....................    else 
....................    { 
....................       DEBUG_DATA("<-**Exception %X**->\r\n\r\n", modbus_rx.error); 
....................    }    
.................... } 
....................  
.................... void unknown_func() 
.................... { 
....................    DEBUG_MSG("Trying unknown function\r\n"); 
....................    DEBUG_MSG("Diagnostic:\r\n"); 
....................    if(!(modbus_diagnostics(MODBUS_SLAVE_ADDRESS,0,0))) 
....................    { 
....................       DEBUG_MSG("Data:"); 
....................       for(i=0; i < (modbus_rx.len); ++i) 
....................          DEBUG_DATA("%X ", modbus_rx.data[i]); 
....................       DEBUG_MSG("\r\n\r\n"); 
....................    } 
....................    else 
....................    { 
....................       DEBUG_DATA("<-**Exception %X**->\r\n\r\n", modbus_rx.error); 
....................    } 
.................... } 
....................  
....................  
.................... void main() 
.................... { 
*
09C6:  CLRF   FF8
09C8:  BCF    FD0.7
09CA:  BSF    07.7
09CC:  CLRF   FEA
09CE:  CLRF   FE9
09D0:  BSF    F93.1
09D2:  BSF    F93.0
09D4:  MOVLW  B0
09D6:  MOVWF  FC8
09D8:  MOVLW  36
09DA:  MOVWF  FC6
09DC:  BCF    F93.4
09DE:  BSF    F8A.4
09E0:  BSF    FB8.3
09E2:  MOVLW  A0
09E4:  MOVWF  FAF
09E6:  MOVLW  01
09E8:  MOVWF  FB0
09EA:  MOVLW  A6
09EC:  MOVWF  FAC
09EE:  MOVLW  90
09F0:  MOVWF  FAB
09F2:  CLRF   1B
09F4:  CLRF   1A
09F6:  MOVLW  27
09F8:  MOVWF  19
09FA:  MOVLW  10
09FC:  MOVWF  18
09FE:  BCF    1C.0
0A00:  CLRF   1D
0A02:  MOVLB  4
0A04:  CLRF   x23
0A06:  CLRF   x24
0A08:  CLRF   x25
0A0A:  CLRF   x26
0A0C:  CLRF   x27
0A0E:  CLRF   x29
0A10:  CLRF   x28
0A12:  MOVF   FC1,W
0A14:  ANDLW  C0
0A16:  IORLW  0F
0A18:  MOVWF  FC1
0A1A:  MOVLW  07
0A1C:  MOVWF  FB4
0A1E:  CLRF   17
0A20:  MOVLW  03
0A22:  MOVWF  xC2
0A24:  BCF    xC4.0
0A26:  CLRF   xC5
0A28:  CLRF   xC6
0A2A:  CLRF   xC7
0A2C:  CLRF   xC8
0A2E:  CLRF   xC9
....................    char c; 
....................    short subop=0; 
....................    int8 menu=0,Opcion=0,pagina=0,dir=0,reg=0; 
....................    fState = 0; 
0A30:  CLRF   x2A
....................    for (posicion=0;posicion<0x10;posicion++){ 
0A32:  CLRF   x2B
0A34:  MOVF   x2B,W
0A36:  SUBLW  0F
0A38:  BNC   0A6E
....................       buffer[posicion] = 0x00; 
0A3A:  CLRF   03
0A3C:  MOVF   x2B,W
0A3E:  ADDLW  2C
0A40:  MOVWF  FE9
0A42:  MOVLW  04
0A44:  ADDWFC 03,W
0A46:  MOVWF  FEA
0A48:  CLRF   FEF
....................       txbuf[posicion] = 0x00; 
0A4A:  CLRF   03
0A4C:  MOVF   x2B,W
0A4E:  ADDLW  5E
0A50:  MOVWF  FE9
0A52:  MOVLW  04
0A54:  ADDWFC 03,W
0A56:  MOVWF  FEA
0A58:  CLRF   FEF
....................       rxbuf[posicion] = 0x00; 
0A5A:  CLRF   03
0A5C:  MOVF   x2B,W
0A5E:  ADDLW  90
0A60:  MOVWF  FE9
0A62:  MOVLW  04
0A64:  ADDWFC 03,W
0A66:  MOVWF  FEA
0A68:  CLRF   FEF
....................    } 
0A6A:  INCF   x2B,F
0A6C:  BRA    0A34
....................    //lcd_init(); 
....................    //enable_interrupts(global); 
....................    delay_ms(6); 
0A6E:  MOVLW  06
0A70:  MOVWF  xCA
0A72:  MOVLB  0
0A74:  RCALL  07E8
....................    setup_adc_ports(NO_ANALOGS); 
0A76:  MOVF   FC1,W
0A78:  ANDLW  C0
0A7A:  IORLW  0F
0A7C:  MOVWF  FC1
....................    output_bit(PIN_B3,1); 
0A7E:  BSF    F8A.3
0A80:  BCF    F93.3
....................    DEBUG_MSG("\r\nInitializing..."); 
0A82:  MOVLW  AA
0A84:  MOVWF  FF6
0A86:  MOVLW  07
0A88:  MOVWF  FF7
0A8A:  RCALL  0858
....................    modbus_init(); 
0A8C:  BRA    0886
....................    DEBUG_MSG("...ready\r\n"); 
0A8E:  MOVLW  BC
0A90:  MOVWF  FF6
0A92:  MOVLW  07
0A94:  MOVWF  FF7
0A96:  RCALL  0858
....................    Lee_Vector(); 
0A98:  RCALL  08C2
....................    enable_interrupts(INT_SSP); 
0A9A:  BSF    F9D.3
.................... /* 
....................    lcd_gotoxy(1,1);    
....................    printf(lcd_putc,"Master                "); 
....................    lcd_gotoxy(1,2);    
....................    printf(lcd_putc,"PIC Modbus            "); 
....................    delay_ms(5000); 
....................    printf(lcd_putc,"\f"); 
.................... */ 
....................    while(true){ 
....................       delay_ms(100); 
0A9C:  MOVLW  64
0A9E:  MOVLB  4
0AA0:  MOVWF  xCA
0AA2:  MOVLB  0
0AA4:  RCALL  07E8
....................       pagina++; 
0AA6:  MOVLB  4
0AA8:  INCF   xC7,F
....................       DEBUG_DATA("Address: %02u\r\n ", address); 
0AAA:  MOVLW  C8
0AAC:  MOVWF  FF6
0AAE:  MOVLW  07
0AB0:  MOVWF  FF7
0AB2:  MOVLW  09
0AB4:  MOVWF  xCA
0AB6:  MOVLB  0
0AB8:  RCALL  08F6
0ABA:  MOVFF  424,4CA
0ABE:  MOVLW  01
0AC0:  MOVLB  4
0AC2:  MOVWF  xCB
0AC4:  MOVLB  0
0AC6:  RCALL  094A
0AC8:  MOVLW  0D
0ACA:  MOVLB  4
0ACC:  MOVWF  xCD
0ACE:  MOVLB  0
0AD0:  RCALL  0812
0AD2:  MOVLW  0A
0AD4:  MOVLB  4
0AD6:  MOVWF  xCD
0AD8:  MOVLB  0
0ADA:  RCALL  0812
0ADC:  MOVLW  20
0ADE:  MOVLB  4
0AE0:  MOVWF  xCD
0AE2:  MOVLB  0
0AE4:  RCALL  0812
....................       DEBUG_DATA("Inst: %02u\r\n ", instruccion); 
0AE6:  MOVLW  DA
0AE8:  MOVWF  FF6
0AEA:  MOVLW  07
0AEC:  MOVWF  FF7
0AEE:  MOVLW  06
0AF0:  MOVLB  4
0AF2:  MOVWF  xCA
0AF4:  MOVLB  0
0AF6:  RCALL  08F6
0AF8:  MOVFF  423,4CA
0AFC:  MOVLW  01
0AFE:  MOVLB  4
0B00:  MOVWF  xCB
0B02:  MOVLB  0
0B04:  RCALL  094A
0B06:  MOVLW  0D
0B08:  MOVLB  4
0B0A:  MOVWF  xCD
0B0C:  MOVLB  0
0B0E:  RCALL  0812
0B10:  MOVLW  0A
0B12:  MOVLB  4
0B14:  MOVWF  xCD
0B16:  MOVLB  0
0B18:  RCALL  0812
0B1A:  MOVLW  20
0B1C:  MOVLB  4
0B1E:  MOVWF  xCD
0B20:  MOVLB  0
0B22:  RCALL  0812
....................       Lee_Vector();    
0B24:  RCALL  08C2
....................       txbuf[13]++; 
0B26:  MOVLB  4
0B28:  INCF   x6B,F
....................       //if(instruccion==3) 
....................          //read_all_holding(0,8); 
....................       //if(instruccion==5) 
....................          //write_reg(address,reg); 
....................       /* 
....................       lcd_gotoxy(1,1); 
....................       printf(lcd_putc,"Dir:%03u",dir); 
....................       lcd_gotoxy(1,2);    
....................       printf(lcd_putc,"Reg:%03u",reg); 
....................       */ 
....................       //write_reg(1,pagina); 
....................       /* 
....................       if(menu==0){//Menu Inicial 
....................          if(DOWN){ 
....................             delay_ms(100); 
....................             if(Opcion<4) 
....................                Opcion++; 
....................          } 
....................          if(UP){ 
....................             delay_ms(100); 
....................             if(Opcion>0) 
....................                Opcion--; 
....................          } 
....................          if(Opcion==0){ 
....................             lcd_gotoxy(1,1);    
....................             printf(lcd_putc,">Read COIL          "); 
....................             lcd_gotoxy(1,2);    
....................             printf(lcd_putc," Read Inputs        ");       
....................             lcd_gotoxy(1,3);    
....................             printf(lcd_putc," Read Holding       ");       
....................             lcd_gotoxy(1,4);    
....................             printf(lcd_putc," Read Inputs Reg    ");       
....................          }else if(Opcion==1){ 
....................             lcd_gotoxy(1,1);    
....................             printf(lcd_putc," Read COIL          "); 
....................             lcd_gotoxy(1,2);    
....................             printf(lcd_putc,">Read Inputs        ");       
....................             lcd_gotoxy(1,3);    
....................             printf(lcd_putc," Read Holding       ");       
....................             lcd_gotoxy(1,4);    
....................             printf(lcd_putc," Read Inputs Reg    ");       
....................          }else if(Opcion==2){ 
....................             lcd_gotoxy(1,1); 
....................             printf(lcd_putc," Read COIL          "); 
....................             lcd_gotoxy(1,2);    
....................             printf(lcd_putc," Read Inputs        ");       
....................             lcd_gotoxy(1,3);    
....................             printf(lcd_putc,">Read Holding       ");       
....................             lcd_gotoxy(1,4);    
....................             printf(lcd_putc," Read Inputs Reg    "); 
....................          }else if(Opcion==3){ 
....................             lcd_gotoxy(1,1); 
....................             printf(lcd_putc," Read COIL          "); 
....................             lcd_gotoxy(1,2);    
....................             printf(lcd_putc," Read Inputs        ");       
....................             lcd_gotoxy(1,3);    
....................             printf(lcd_putc," Read Holding       ");       
....................             lcd_gotoxy(1,4);    
....................             printf(lcd_putc,">Read Inputs Reg    ");       
....................          }else if(Opcion==4){ 
....................             lcd_gotoxy(1,1);    
....................             printf(lcd_putc," Read Inputs        ");       
....................             lcd_gotoxy(1,2);    
....................             printf(lcd_putc," Read Holding       ");       
....................             lcd_gotoxy(1,3);    
....................             printf(lcd_putc," Read Inputs Reg    ");  
....................             lcd_gotoxy(1,4);    
....................             printf(lcd_putc,">Write Register     "); 
....................          } 
....................          if(RIGHT){ 
....................             delay_ms(100); 
....................             menu=Opcion+1; 
....................             printf(lcd_putc,"\f"); 
....................          } 
....................       }else if(menu==1){//Read COIL 
....................          read_all_coils(); 
....................       }else if(menu==2){//Read Inputs 
....................          read_all_inputs(); 
....................       }else if(menu==3){//Read Holding 
....................          read_all_holding(0,8); 
....................          lcd_gotoxy(1,1);    
....................          lcd_gotoxy(1,1);    
....................          printf(lcd_putc,"R%u:%05Ld",pagina,make16((int8)modbus_rx.data[pagina+1],(int8)modbus_rx.data[pagina+2])); 
....................          lcd_gotoxy(10,1);    
....................          printf(lcd_putc,"R%u:%05Ld",pagina+1,make16((int8)modbus_rx.data[pagina+3],(int8)modbus_rx.data[pagina+4])); 
....................          lcd_gotoxy(1,2);    
....................          printf(lcd_putc,"R%u:%05Ld",pagina+2,make16((int8)modbus_rx.data[pagina+5],(int8)modbus_rx.data[pagina+6])); 
....................          lcd_gotoxy(10,2);    
....................          printf(lcd_putc,"R%u:%05Ld",pagina+3,make16((int8)modbus_rx.data[pagina+7],(int8)modbus_rx.data[pagina+8])); 
....................          lcd_gotoxy(1,3);    
....................          printf(lcd_putc,"R%u:%05Ld",pagina+3,make16((int8)modbus_rx.data[pagina+9],(int8)modbus_rx.data[pagina+10])); 
....................          lcd_gotoxy(10,3);    
....................          printf(lcd_putc,"R%u:%05Ld",pagina+4,make16((int8)modbus_rx.data[pagina+11],(int8)modbus_rx.data[pagina+12])); 
....................          lcd_gotoxy(1,4);    
....................          printf(lcd_putc,"R%u:%05Ld",pagina+5,make16((int8)modbus_rx.data[pagina+13],(int8)modbus_rx.data[pagina+14])); 
....................          lcd_gotoxy(10,4);    
....................          printf(lcd_putc,"R%u:%05Ld",pagina+6,make16((int8)modbus_rx.data[pagina+15],(int8)modbus_rx.data[pagina+16])); 
....................       }else if(menu==4){//Read Inputs Reg 
....................          if(UP){ 
....................             delay_ms(100); 
....................             if(pagina<4) 
....................                pagina++; 
....................          } 
....................          if(DOWN){ 
....................             delay_ms(100); 
....................             if(pagina>0) 
....................                pagina--; 
....................          } 
....................          read_all_input_reg(pagina+0,8); 
....................          lcd_gotoxy(1,1);    
....................          printf(lcd_putc,"R%u:%05Ld",pagina,make16((int8)modbus_rx.data[pagina+1],(int8)modbus_rx.data[pagina+2])); 
....................          lcd_gotoxy(10,1);    
....................          printf(lcd_putc,"R%u:%05Ld",pagina+1,make16((int8)modbus_rx.data[pagina+3],(int8)modbus_rx.data[pagina+4])); 
....................          lcd_gotoxy(1,2);    
....................          printf(lcd_putc,"R%u:%05Ld",pagina+2,make16((int8)modbus_rx.data[pagina+5],(int8)modbus_rx.data[pagina+6])); 
....................          lcd_gotoxy(10,2);    
....................          printf(lcd_putc,"R%u:%05Ld",pagina+3,make16((int8)modbus_rx.data[pagina+7],(int8)modbus_rx.data[pagina+8])); 
....................          lcd_gotoxy(1,3);    
....................          printf(lcd_putc,"R%u:%05Ld",pagina+3,make16((int8)modbus_rx.data[pagina+9],(int8)modbus_rx.data[pagina+10])); 
....................          lcd_gotoxy(10,3);    
....................          printf(lcd_putc,"R%u:%05Ld",pagina+4,make16((int8)modbus_rx.data[pagina+11],(int8)modbus_rx.data[pagina+12])); 
....................          lcd_gotoxy(1,4);    
....................          printf(lcd_putc,"R%u:%05Ld",pagina+5,make16((int8)modbus_rx.data[pagina+13],(int8)modbus_rx.data[pagina+14])); 
....................          lcd_gotoxy(10,4);    
....................          printf(lcd_putc,"R%u:%05Ld",pagina+6,make16((int8)modbus_rx.data[pagina+15],(int8)modbus_rx.data[pagina+16])); 
....................       }else if(menu==5){//Write Register 
....................          if(LEFT){ 
....................             subop=!subop; 
....................             output_bit(PIN_B7,1); 
....................             delay_ms(1000);             
....................             output_bit(PIN_B7,0); 
....................          } 
....................           
....................          if(UP){ 
....................             delay_ms(100);             
....................                if(!subop) 
....................                   dir++; 
....................                if(subop) 
....................                   reg++; 
....................          } 
....................          if(DOWN){ 
....................             delay_ms(100); 
....................             if(!subop){ 
....................                if(dir>0) 
....................                   dir--; 
....................             } 
....................             if(subop){ 
....................                if(reg>0) 
....................                   reg--; 
....................             } 
....................          } 
....................          lcd_gotoxy(1,1);    
....................          printf(lcd_putc,"Dir:%03u",dir); 
....................          lcd_gotoxy(1,2);    
....................          printf(lcd_putc,"Reg:%03u",reg); 
....................          if(RIGHT){ 
....................             delay_ms(100); 
....................             write_reg(dir,reg); 
....................          } 
....................       } 
....................       */ 
....................    } 
0B2A:  MOVLB  0
0B2C:  BRA    0A9C
.................... } 
0B2E:  SLEEP 

Configuration Fuses:
   Word  1: 0238   XTPLL NOIESO NOFCMEN PLL1 CPUDIV4 USBDIV
   Word  2: 1E39   NOBROWNOUT NOWDT BORV20 NOPUT WDT32768 VREGEN
   Word  3: 0100   NOPBADEN CCP2C1 NOMCLR NOLPT1OSC
   Word  4: 0080   NOSTVREN NODEBUG NOLVP NOXINST
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
