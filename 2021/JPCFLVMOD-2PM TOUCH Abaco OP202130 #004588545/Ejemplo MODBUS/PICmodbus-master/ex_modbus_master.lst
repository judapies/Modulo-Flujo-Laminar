CCS PCH C Compiler, Version 4.104, 5967               02-feb.-21 13:04

               Filename: D:\Laboratorio\Modulo Flujo Laminar\2021\JPCFLVMOD-2PM TOUCH Abaco OP202130 #0045884XX\Ejemplo MODBUS\PICmodbus-master\ex_modbus_master.lst

               ROM used: 6234 bytes (19%)
                         Largest free fragment is 26530
               RAM used: 103 (7%) at main() level
                         127 (8%) worst case
               Stack:    10 worst case (7 in main + 3 for interrupts)

*
0000:  GOTO   178A
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  F9D.1
004A:  GOTO   0054
004E:  BTFSC  F9E.1
0050:  GOTO   0312
0054:  BTFSS  F9D.5
0056:  GOTO   0060
005A:  BTFSC  F9E.5
005C:  GOTO   0388
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVF   04,W
0098:  MOVFF  06,FE0
009C:  MOVFF  05,FD8
00A0:  RETFIE 0
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                        ex_modbus_master.c                       //// 
.................... ////                                                                 //// 
.................... ////    This is a simple test program for a modbus master device.    //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Notes:                                                          //// 
.................... ////                                                                 //// 
.................... //// Testing Example:                                                //// 
.................... //// To test the master code you will need a slave device loaded     //// 
.................... //// with the ex_modbus_slave.c program (Note that you can test it   //// 
.................... //// with PC software as well.  See Communicating with PC Software.) //// 
.................... //// After making the proper connections (refer to wiring diagram)   //// 
.................... //// you should power on the slave device and then power on the      //// 
.................... //// master device.  The master device should begin sending commands //// 
.................... //// out and showing the replies from the slave through the PC       //// 
.................... //// connection.                                                     //// 
.................... ////                                                                 //// 
.................... //// Hardware UART:                                                  //// 
.................... //// If you use a hardware UART, make sure MODBUS_SERIAL_INT_SOURCE  //// 
.................... //// is set to MODBUS_INT_RDA or MODBUS_INT_RDA2 depending on which  //// 
.................... //// UART you are using.  Also, when using a hardware UART you do    ////  
.................... //// not need to specify the TX and RX pins.  The driver figures     ////  
.................... //// them out for you.                                               //// 
.................... ////                                                                 //// 
.................... //// Communicating with PC software:                                 //// 
.................... //// To communicate with a PC, connect the board to your computer    //// 
.................... //// using the serial cable provided with your board.  Then          //// 
.................... //// uncomment the #define USE_WITH_PC 1 line.  In this              //// 
.................... //// configuration the PIC is the master and the PC is the slave.    //// 
.................... ////                                                                 //// 
.................... //// Troubleshooting:                                                //// 
.................... //// If the device seems unresponsive, power cycle the board and     //// 
.................... //// wait 5 seconds.                                                 //// 
.................... ////                                                                 //// 
.................... //// Wiring Diagram:                                                 //// 
.................... //// This is the diagram for the default configuration.  Note that   ////  
.................... //// the external interrupt (INT), PIN B0, is the only pin that can  //// 
.................... //// be used for receiving with software RS232 for PCM and PCH, and  //// 
.................... //// for PCD the exteranl interrupt (INT0), usually PIN F6, is the   //// 
.................... //// only pin that can be used for receiving with software RS232.    //// 
.................... ////                                                                 //// 
.................... ////            PCH and PCM                        PCD               //// 
.................... ////    ----------     ----------       ----------     ----------    //// 
.................... ////    |        |     |        |       |        |     |        |    //// 
.................... ////    | Master |     | Slave  |       | Master |     | Slave  |    //// 
.................... ////    |        |     |        |       |        |     |        |    //// 
.................... ////    |      B1|---->|B0      |       |      D8|---->|F6      |    //// 
.................... ////    |      B0|<----|B1      |       |      F6|<----|D8      |    //// 
.................... ////    ----------     ----------       ----------     ----------    //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2006 Custom Computer Services        //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... //#define USE_WITH_PC 1 
....................  
.................... #include <18f458.h> 
.................... //////// Standard Header file for the PIC18F458 device //////////////// 
.................... #device PIC18F458 
.................... #list 
....................  
.................... #fuses HS, NOWDT 
.................... #use delay(clock=4M) 
*
07B4:  CLRF   FEA
07B6:  MOVLW  76
07B8:  MOVWF  FE9
07BA:  MOVF   FEF,W
07BC:  BZ    07DA
07BE:  MOVLW  01
07C0:  MOVWF  01
07C2:  CLRF   00
07C4:  DECFSZ 00,F
07C6:  BRA    07C4
07C8:  DECFSZ 01,F
07CA:  BRA    07C2
07CC:  MOVLW  4A
07CE:  MOVWF  00
07D0:  DECFSZ 00,F
07D2:  BRA    07D0
07D4:  BRA    07D6
07D6:  DECFSZ FEF,F
07D8:  BRA    07BE
07DA:  RETLW  00
*
0A12:  MOVLW  15
0A14:  SUBWF  x77,F
0A16:  BNC   0A34
0A18:  CLRF   FEA
0A1A:  MOVLW  77
0A1C:  MOVWF  FE9
0A1E:  MOVLW  FC
0A20:  ANDWF  FEF,F
0A22:  BCF    FD8.0
0A24:  RRCF   FEF,F
0A26:  RRCF   FEF,F
0A28:  MOVF   FEF,W
0A2A:  BZ    0A34
0A2C:  BRA    0A30
0A2E:  NOP   
0A30:  DECFSZ FEF,F
0A32:  BRA    0A2E
0A34:  RETLW  00
....................  
....................  
.................... #define MODBUS_TYPE MODBUS_TYPE_MASTER 
.................... #define MODBUS_SERIAL_TYPE MODBUS_RTU     //use MODBUS_ASCII for ASCII mode 
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE 64 
.................... #define MODBUS_SERIAL_BAUD 2400 
....................  
.................... //#ifndef USE_WITH_PC 
.................... //#use rs232(baud=9600, UART1, stream=PC, errors) 
.................... #use RS232(BAUD=9600, BITS=8, PARITY=N, XMIT=PIN_B0, RCV=PIN_B1,stream=PC, errors) 
*
088A:  BCF    F93.0
088C:  BCF    F8A.0
088E:  MOVLW  08
0890:  MOVWF  01
0892:  BRA    0894
0894:  NOP   
0896:  BSF    01.7
0898:  BRA    08B6
089A:  BCF    01.7
089C:  RRCF   x6E,F
089E:  BTFSC  FD8.0
08A0:  BSF    F8A.0
08A2:  BTFSS  FD8.0
08A4:  BCF    F8A.0
08A6:  BSF    01.6
08A8:  BRA    08B6
08AA:  BCF    01.6
08AC:  DECFSZ 01,F
08AE:  BRA    089C
08B0:  BRA    08B2
08B2:  NOP   
08B4:  BSF    F8A.0
08B6:  MOVLW  1C
08B8:  MOVWF  FE9
08BA:  DECFSZ FE9,F
08BC:  BRA    08BA
08BE:  BRA    08C0
08C0:  BTFSC  01.7
08C2:  BRA    089A
08C4:  BTFSC  01.6
08C6:  BRA    08AA
08C8:  RETLW  00
*
09CA:  BSF    F93.1
09CC:  BTFSC  F81.1
09CE:  BRA    09CC
09D0:  MOVLW  08
09D2:  MOVWF  00
09D4:  CLRF   x66
09D6:  BSF    00.7
09D8:  BRA    09F6
09DA:  BCF    00.7
09DC:  BRA    09F6
09DE:  BCF    FD8.0
09E0:  BTFSC  F81.1
09E2:  BSF    FD8.0
09E4:  RRCF   x66,F
09E6:  BSF    00.6
09E8:  BRA    09F6
09EA:  BCF    00.6
09EC:  DECFSZ 00,F
09EE:  BRA    09DE
09F0:  MOVFF  66,01
09F4:  BRA    0A0E
09F6:  MOVLW  1C
09F8:  BTFSC  00.7
09FA:  MOVLW  07
09FC:  MOVWF  01
09FE:  DECFSZ 01,F
0A00:  BRA    09FE
0A02:  NOP   
0A04:  BTFSC  00.7
0A06:  BRA    09DA
0A08:  BTFSC  00.6
0A0A:  BRA    09EA
0A0C:  BRA    09DE
0A0E:  GOTO   1838 (RETURN)
.................... //#define MODBUS_SERIAL_INT_SOURCE MODBUS_INT_EXT 
.................... #define MODBUS_SERIAL_INT_SOURCE MODBUS_INT_RDA 
.................... #define MODBUS_SERIAL_TX_PIN PIN_C6   // Data transmit pin 
.................... #define MODBUS_SERIAL_RX_PIN PIN_C7   // Data receive pin 
.................... //The following should be defined for RS485 communication 
.................... #define MODBUS_SERIAL_ENABLE_PIN   PIN_B2   // Controls DE pin for RS485 
.................... #define MODBUS_SERIAL_RX_ENABLE    0   // Controls RE pin for RS485 
.................... #define DEBUG_MSG(msg) fprintf(PC, msg) 
.................... #define DEBUG_DATA(msg,data) fprintf(PC, msg, data) 
.................... //#else 
.................... //#define MODBUS_SERIAL_INT_SOURCE MODBUS_INT_EXT 
.................... //#define DEBUG_MSG(msg) if(0) 
.................... //#define DEBUG_DATA(msg,data) if(0) 
.................... //#endif 
....................  
.................... #include <modbus.c> 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                      modbus.c                                    //// 
.................... ////                                                                                  //// 
.................... ////                 MODBUS protocol driver for serial communications.                //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// DEFINES:                                                                         //// 
.................... ////                                                                                  //// 
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           //// 
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              //// 
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2,   //// 
.................... ////                                   MODBUS_INT_RDA3,MODBUS_INT_RDA4)               //// 
.................... ////  MODBUS_SERIAL_TYPE            MODBUS_RTU or MODBUS_ASCII                        //// 
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        //// 
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      //// 
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     //// 
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           //// 
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       //// 
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        //// 
.................... ////                                                                                  //// 
.................... ////                                                                                  //// 
.................... //// SHARED API:                                                                      //// 
.................... ////                                                                                  //// 
.................... ////  modbus_init()                                                                   //// 
.................... ////    - Initialize modbus serial communication system                               //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_start(address,func)                                          //// 
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data //// 
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_stop()                                                       //// 
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  //// 
.................... ////                                                                                  //// 
.................... ////  modbus_kbhit()                                                                  //// 
.................... ////    - Used to check if a packet has been received.                                //// 
.................... ////                                                                                  //// 
.................... //// MASTER API:                                                                      //// 
.................... ////  All master API functions return 0 on success.                                   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     //// 
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            //// 
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         //// 
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           //// 
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   //// 
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           //// 
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_exception_status(address)                                 //// 
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             //// 
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_counter(address)                                //// 
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_log(address)                                    //// 
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   //// 
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.//// 
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  //// 
.................... ////                    coils.                                                        //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)/// 
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. //// 
.................... ////    - Special Note: values is a pointer to an int8 array                          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_report_slave_id(address)                                       //// 
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  //// 
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 //// 
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)//// 
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,//// 
.................... ////                            write_start,write_quantity, *write_registers_value)   //// 
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          //// 
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////                                                                                  //// 
.................... //// Slave API:                                                                       //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_coils_rsp(address,byte_count,*coil_data)                       //// 
.................... ////    - Wrapper to respond to 0x01(read coils) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_discrete_input_rsp(address,byte_count,*input_data)             //// 
.................... ////    - Wrapper to respond to 0x02(read discret input) in the MODBUS specification. //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_holding_registers_rsp(address,byte_count,*reg_data)            //// 
.................... ////    - Wrapper to respond to 0x03(read holding regs) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_input_registers_rsp(address,byte_count,*input_data)            //// 
.................... ////    - Wrapper to respond to 0x04(read input regs) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_single_coil_rsp(address,output_address,output_value)          //// 
.................... ////    - Wrapper to respond to 0x05(write single coil) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_single_register_rsp(address,reg_address,reg_value)            //// 
.................... ////    - Wrapper to respond to 0x06(write single reg) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_exception_status_rsp(address, data)                            //// 
.................... ////    - Wrapper to respond to 0x07(read void status) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_diagnostics_rsp(address,sub_func,data)                              //// 
.................... ////    - Wrapper to respond to 0x08(diagnostics) in the MODBUS specification.        //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_get_comm_event_counter_rsp(address,status,event_count)              //// 
.................... ////    - Wrapper to respond to 0x0B(get comm event count) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_get_comm_event_log_rsp(address,status,event_count,message_count,    //// 
.................... ////                                   *events, events_len)                           //// 
.................... ////    - Wrapper to respond to 0x0C(get comm event log) in the MODBUS specification. //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_multiple_coils_rsp(address,start_address,quantity)            //// 
.................... ////    - Wrapper to respond to 0x0F(write multiple coils) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_multiple_registers_rsp(address,start_address,quantity)        //// 
.................... ////    - Wrapper to respond to 0x10(write multiple regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_report_slave_id_rsp(address,slave_id,run_status,*data,data_len)     //// 
.................... ////    - Wrapper to respond to 0x11(report slave id) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_file_record_rsp(address,byte_count,*request)                   //// 
.................... ////    - Wrapper to respond to 0x14(read file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_file_record_rsp(address,byte_count,*request)                  //// 
.................... ////    - Wrapper to respond to 0x15(write file record) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_mask_write_register_rsp(address,reference_address,AND_mask,OR_mask) //// 
.................... ////    - Wrapper to respond to 0x16(read coils) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_write_multiple_registers_rsp(address,*data,data_len)           //// 
.................... ////    - Wrapper to respond to 0x17(read write mult regs) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_FIFO_queue_rsp(address,FIFO_len,*data)                         //// 
.................... ////    - Wrapper to respond to 0x18(read FIFO queue) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_exception_rsp(int8 address, int16 func, exception error)            //// 
.................... ////    - Wrapper to send an exception response.  See exception list below.           //// 
.................... ////                                                                                  //// 
.................... //// Exception List:                                                                  //// 
.................... ////  ILLEGAL_FUNCTION, ILLEGAL_DATA_ADDRESS, ILLEGAL_DATA_VALUE,                     //// 
.................... ////  SLAVE_DEVICE_FAILURE, ACKNOWLEDGE, SLAVE_DEVICE_BUSY, MEMORY_PARITY_ERROR,      //// 
.................... ////  GATEWAY_PATH_UNAVAILABLE, GATEWAY_TARGET_NO_RESPONSE                            //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// Revision history:                                                                //// 
.................... ////  May 8, 2009          Made PCD Compatible                                        //// 
.................... ////  August 21, 2009      Added Modbus ASCII protocol                                //// 
.................... ////  September 25, 2009   Fixed Bug in RCV_ON function                               //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2006 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... /*Some defines so we can use identifiers to set things up*/ 
.................... #define MODBUS_TYPE_MASTER 99999 
.................... #define MODBUS_TYPE_SLAVE  88888 
.................... #define MODBUS_INT_RDA     77777 
.................... #define MODBUS_INT_RDA2    66666 
.................... #define MODBUS_INT_RDA3    44444 
.................... #define MODBUS_INT_RDA4    33333 
.................... #define MODBUS_INT_EXT     55555 
.................... #define MODBUS_RTU         1 
.................... #define MODBUS_ASCII       2 
....................  
.................... #ifndef MODBUS_TYPE 
.................... #define MODBUS_TYPE MODBUS_TYPE_MASTER 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_TYPE 
.................... #define MODBUS_SERIAL_TYPE MODBUS_RTU 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_INT_SOURCE 
.................... #define MODBUS_SERIAL_INT_SOURCE MODBUS_INT_RDA    // Select between external interrupt 
.................... #endif                                             // or asynchronous serial interrupt 
....................  
.................... #ifndef MODBUS_SERIAL_BAUD 
.................... #define MODBUS_SERIAL_BAUD 9600 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_RX_PIN 
.................... #define MODBUS_SERIAL_RX_PIN       PIN_C7   // Data receive pin 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_TX_PIN 
.................... #define MODBUS_SERIAL_TX_PIN       PIN_C6   // Data transmit pin 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_ENABLE_PIN 
.................... #define MODBUS_SERIAL_ENABLE_PIN   0   // Controls DE pin.  RX low, TX high. 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_RX_ENABLE 
.................... #define MODBUS_SERIAL_RX_ENABLE    0   // Controls RE pin.  Should keep low. 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_TIMEOUT 
....................    #if (MODBUS_SERIAL_TYPE == MODBUS_ASCII) 
....................       #define MODBUS_SERIAL_TIMEOUT    1000000 
....................    #else 
....................       #define MODBUS_SERIAL_TIMEOUT      10000     //in us 
....................    #endif 
.................... #endif 
....................  
.................... #if( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA ) 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART1, bits=8, stop=1, parity=N, stream=MODBUS_SERIAL, errors) 
*
0340:  BTFSS  F9E.5
0342:  BRA    0340
0344:  MOVFF  FAB,17
0348:  MOVFF  FAE,01
034C:  BTFSS  17.1
034E:  BRA    0354
0350:  BCF    FAB.4
0352:  BSF    FAB.4
0354:  RETLW  00
*
0A36:  BTFSS  F9E.4
0A38:  BRA    0A36
0A3A:  MOVWF  FAD
0A3C:  GOTO   0A44 (RETURN)
....................    #define RCV_OFF() {disable_interrupts(INT_RDA);} 
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2 ) 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART2, bits=8, stop=1, parity=N, stream=MODBUS_SERIAL, errors) 
....................    #define RCV_OFF() {disable_interrupts(INT_RDA2);} 
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3 ) 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART3, bits=8, stop=1, parity=N, stream=MODBUS_SERIAL, errors) 
....................    #define RCV_OFF() {disable_interrupts(INT_RDA3);} 
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4 ) 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART4, bits=8, stop=1, parity=N, stream=MODBUS_SERIAL, errors) 
....................    #define RCV_OFF() {disable_interrupts(INT_RDA4);} 
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_EXT ) 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, xmit=MODBUS_SERIAL_TX_PIN, rcv=MODBUS_SERIAL_RX_PIN, bits=8, stop=1, parity=N, stream=MODBUS_SERIAL, disable_ints) 
....................    #if defined(__PCD__) 
....................    #define RCV_OFF() {disable_interrupts(INT_EXT0);} 
....................    #else 
....................    #define RCV_OFF() {disable_interrupts(INT_EXT);} 
....................    #endif 
.................... #else 
....................    #error Please define a correct interrupt source 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_RX_BUFFER_SIZE 
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE  64      //size of send/rcv buffer 
.................... #endif 
....................  
.................... #if (MODBUS_TYPE == MODBUS_TYPE_MASTER) 
.................... int32 modbus_serial_wait=MODBUS_SERIAL_TIMEOUT; 
....................  
.................... #define MODBUS_SERIAL_WAIT_FOR_RESPONSE()\ 
.................... {\ 
....................     if(address)\ 
....................     {\ 
....................         while(!modbus_kbhit() && --modbus_serial_wait)\ 
....................             delay_us(1);\ 
....................         if(!modbus_serial_wait)\ 
....................             modbus_rx.error=TIMEOUT;\ 
....................     }\ 
....................     modbus_serial_wait = MODBUS_SERIAL_TIMEOUT;\ 
.................... } 
.................... #endif 
....................  
.................... #if (MODBUS_SERIAL_INT_SOURCE != MODBUS_INT_EXT) 
....................    #if defined(__PCD__) 
....................       #if (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA) 
....................          #word TXSTA=getenv("SFR:U1STA")  
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2) 
....................          #word TXSTA=getenv("SFR:U2STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3) 
....................          #word TXSTA=getenv("SFR:U3STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4) 
....................          #word TXSTA=getenv("SFR:U4STA") 
....................          #bit TRMT=TXSTA.8 
....................       #endif 
....................    #else 
....................       #byte TXSTA=getenv("sfr:TXSTA") 
....................       #bit TRMT=TXSTA.1 
....................    #endif 
....................  
.................... #define WAIT_FOR_HW_BUFFER()\ 
.................... {\ 
....................    while(!TRMT);\ 
.................... }    
.................... #endif 
....................  
.................... int1 modbus_serial_new=0; 
....................  
.................... /******************************************************************** 
.................... These exceptions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to communicate problems with the transmission back 
.................... to the master who can also use these to easily check the exceptions.   
.................... The first exception is the only one that is not part of the protocol  
.................... specification.  The TIMEOUT exception is returned when no slave  
.................... responds to the master's request within the timeout period. 
.................... ********************************************************************/ 
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2,  
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6,  
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11, 
.................... TIMEOUT=12} exception; 
....................  
.................... /******************************************************************** 
.................... These functions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to check the incomming function.  See  
.................... ex_modbus_slave.c for example usage. 
.................... ********************************************************************/ 
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02, 
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04, 
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06, 
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08, 
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C, 
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10, 
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14, 
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16, 
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function; 
....................      
.................... /*Stages of MODBUS reception.  Used to keep our ISR fast enough.*/ 
.................... #if (MODBUS_SERIAL_TYPE==MODBUS_ASCII) 
....................    enum {MODBUS_START=0, MODBUS_GETADDY, MODBUS_GETFUNC, MODBUS_GETDATA, MODBUS_STOP} modbus_serial_state=0; 
.................... #else 
....................    enum {MODBUS_GETADDY=0, MODBUS_GETFUNC=1, MODBUS_GETDATA=2} modbus_serial_state = 0; 
.................... #endif 
....................  
.................... /*Global value holding our current CRC value.*/ 
.................... #if (MODBUS_SERIAL_TYPE==MODBUS_ASCII) 
....................    unsigned int8 modbus_serial_lrc; 
.................... #else 
....................    union 
....................    { 
....................       int8 b[2]; 
....................       int16 d; 
....................    } modbus_serial_crc; 
.................... #endif 
....................  
.................... /******************************************************************** 
.................... Our receive struct.  This is used when receiving data as a master or 
.................... slave.  Once a message is sent to you with your address, you should 
.................... begin processing that message.  Refer to ex_modbus_slave.c to see  
.................... how to properly use this structure. 
.................... ********************************************************************/ 
.................... struct 
.................... { 
....................    int8 address; 
....................    int8 len;                                //number of bytes in the message received 
....................    function func;                           //the function of the message received 
....................    exception error;                         //error recieved, if any 
....................    int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received 
.................... } modbus_rx; 
....................  
.................... /* Table of CRC values for high–order byte */ 
.................... #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
.................... const unsigned char modbus_auchCRCHi[] = { 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40 
.................... }; 
....................  
.................... /* Table of CRC values for low–order byte */ 
.................... const char modbus_auchCRCLo[] = { 
.................... 0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4, 
.................... 0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09, 
.................... 0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD, 
.................... 0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3, 
.................... 0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7, 
.................... 0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A, 
.................... 0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE, 
.................... 0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26, 
.................... 0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2, 
.................... 0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F, 
.................... 0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB, 
.................... 0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5, 
.................... 0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91, 
.................... 0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C, 
.................... 0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88, 
.................... 0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C, 
.................... 0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80, 
.................... 0x40 
.................... }; 
.................... #endif 
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void) 
.................... { 
....................    #if (MODBUS_SERIAL_INT_SOURCE!=MODBUS_INT_EXT) 
....................       while(kbhit(MODBUS_SERIAL)) {fgetc(MODBUS_SERIAL);}  //Clear RX buffer. Clear RDA interrupt flag. Clear overrun error flag. 
*
08EA:  BTFSS  F9E.5
08EC:  BRA    08F2
08EE:  RCALL  0340
....................       #if (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA) 
08F0:  BRA    08EA
....................         clear_interrupt(INT_RDA); 
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA2) 
....................         clear_interrupt(INT_RDA2); 
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA3) 
....................         clear_interrupt(INT_RDA3); 
....................       #else 
....................         clear_interrupt(INT_RDA4); 
....................       #endif 
....................  
....................       #if (MODBUS_SERIAL_RX_ENABLE!=0)  
....................          output_low(MODBUS_SERIAL_RX_ENABLE); 
....................       #endif 
....................  
....................       #if (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA) 
....................         enable_interrupts(INT_RDA); 
08F2:  BSF    F9D.5
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA2) 
....................         enable_interrupts(INT_RDA2); 
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA3) 
....................         enable_interrupts(INT_RDA3); 
....................       #else 
....................         enable_interrupts(INT_RDA4); 
....................       #endif 
....................    #else 
....................       #if defined(__PCD__) 
....................          clear_interrupt(INT_EXT0); 
....................       #else 
....................          clear_interrupt(INT_EXT); 
....................       #endif 
....................        
....................       ext_int_edge(H_TO_L); 
....................       
....................       #if (MODBUS_SERIAL_RX_ENABLE!=0)  
....................          output_low(MODBUS_SERIAL_RX_ENABLE); 
....................       #endif 
....................  
....................       #if defined(__PCD__) 
....................          enable_interrupts(INT_EXT0); 
....................       #else 
....................          enable_interrupts(INT_EXT); 
....................       #endif 
....................    #endif 
.................... } 
08F4:  RETLW  00
....................  
.................... // Purpose:    Initialize RS485 communication. Call this before 
.................... //             using any other RS485 functions. 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void modbus_init() 
.................... { 
....................    output_low(MODBUS_SERIAL_ENABLE_PIN); 
08F6:  BCF    F93.2
08F8:  BCF    F8A.2
....................  
....................    RCV_ON(); 
08FA:  RCALL  08EA
....................  
....................    #if defined(__PCD__) 
....................       #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
....................          setup_timer2(TMR_INTERNAL | TMR_DIV_BY_8,4999); //~4ms interrupts for 20Mhz clock 
....................       #endif 
....................       enable_interrupts(INTR_GLOBAL); 
....................    #else 
....................       #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
....................          setup_timer_2(T2_DIV_BY_16,249,5);  //~4ms interrupts 
08FC:  MOVLW  20
08FE:  IORLW  06
0900:  MOVWF  FCA
0902:  MOVLW  F9
0904:  MOVWF  FCB
....................       #endif 
....................       enable_interrupts(GLOBAL); 
0906:  MOVLW  C0
0908:  IORWF  FF2,F
....................    #endif 
.................... } 
090A:  GOTO   17E6 (RETURN)
....................  
.................... // Purpose:    Start our timeout timer 
.................... // Inputs:     Enable, used to turn timer on/off 
.................... // Outputs:    None 
.................... // Not used for ASCII mode 
.................... #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
.................... void modbus_enable_timeout(int1 enable) 
.................... { 
....................    disable_interrupts(INT_TIMER2); 
*
0304:  BCF    F9D.1
....................    if (enable) { 
0306:  MOVF   x7C,F
0308:  BZ    0310
....................       set_timer2(0); 
030A:  CLRF   FCC
....................       clear_interrupt(INT_TIMER2); 
030C:  BCF    F9E.1
....................       enable_interrupts(INT_TIMER2); 
030E:  BSF    F9D.1
....................    } 
.................... } 
0310:  RETLW  00
.................... #endif 
....................  
.................... // Purpose:    Check if we have timed out waiting for a response 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... // Not used for ASCII mode 
.................... #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
....................    #int_timer2 
....................    void modbus_timeout_now(void) 
....................    { 
....................       if((modbus_serial_state == MODBUS_GETDATA) && (modbus_serial_crc.d == 0x0000) && (!modbus_serial_new)) 
0312:  MOVF   1D,W
0314:  SUBLW  02
0316:  BNZ   032C
0318:  MOVF   1E,F
031A:  BNZ   032C
031C:  MOVF   1F,F
031E:  BNZ   032C
0320:  BTFSC  1C.0
0322:  BRA    032C
....................       { 
....................          modbus_rx.len-=2; 
0324:  MOVLW  02
0326:  SUBWF  21,F
....................          modbus_serial_new=TRUE; 
0328:  BSF    1C.0
....................       } 
....................       else 
032A:  BRA    032E
....................          modbus_serial_new=FALSE; 
032C:  BCF    1C.0
....................     
....................       modbus_serial_crc.d=0xFFFF; 
032E:  MOVLW  FF
0330:  MOVWF  1F
0332:  MOVWF  1E
....................       modbus_serial_state=MODBUS_GETADDY; 
0334:  CLRF   1D
....................       modbus_enable_timeout(FALSE); 
0336:  CLRF   x7C
0338:  RCALL  0304
....................    } 
.................... #endif 
....................  
.................... // Purpose:    Calculate crc of data and updates global crc 
.................... // Inputs:     Character 
.................... // Outputs:    None 
033A:  BCF    F9E.1
033C:  GOTO   0060
.................... void modbus_calc_crc(char data) 
.................... { 
....................    #if (MODBUS_SERIAL_TYPE == MODBUS_ASCII) 
....................       modbus_serial_lrc+=data; 
....................    #else 
....................       unsigned int8 uIndex ; // will index into CRC lookup table 
....................  
....................       uIndex = (modbus_serial_crc.b[1]) ^ data; // calculate the CRC 
*
0356:  MOVF   1F,W
0358:  XORWF  x7C,W
035A:  MOVWF  x7D
....................       modbus_serial_crc.b[1] = (modbus_serial_crc.b[0]) ^ modbus_auchCRCHi[uIndex]; 
035C:  CLRF   03
035E:  MOVF   x7D,W
0360:  MOVFF  FF2,7E
0364:  BCF    FF2.7
0366:  RCALL  00A2
0368:  BTFSC  x7E.7
036A:  BSF    FF2.7
036C:  MOVWF  01
036E:  MOVF   1E,W
0370:  XORWF  01,W
0372:  MOVWF  1F
....................       modbus_serial_crc.b[0] = modbus_auchCRCLo[uIndex]; 
0374:  CLRF   03
0376:  MOVF   x7D,W
0378:  MOVFF  FF2,7E
037C:  BCF    FF2.7
037E:  RCALL  01C4
0380:  BTFSC  x7E.7
0382:  BSF    FF2.7
0384:  MOVWF  1E
....................    #endif 
.................... } 
0386:  RETLW  00
....................  
.................... // Purpose:    Puts a character onto the serial line 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_putc(int8 c) 
.................... { 
....................    #if (MODBUS_SERIAL_TYPE==MODBUS_ASCII) 
....................       int8 asciih,asciil; 
....................        
....................       asciih=c>>4; 
....................       if(asciih>9) 
....................          asciih+=0x37; 
....................       else 
....................          asciih+=0x30; 
....................       asciil=c&0xF; 
....................       if(asciil>9) 
....................          asciil+=0x37; 
....................       else 
....................          asciil+=0x30; 
....................       fputc(asciih,MODBUS_SERIAL); 
....................       fputc(asciil,MODBUS_SERIAL); 
....................       modbus_calc_crc(c); 
....................    #else 
....................       fputc(c, MODBUS_SERIAL); 
*
0A40:  MOVF   x77,W
0A42:  BRA    0A36
0A44:  CLRF   16
0A46:  BTFSC  FF2.7
0A48:  BSF    16.7
0A4A:  BCF    FF2.7
....................       modbus_calc_crc(c); 
0A4C:  MOVFF  77,7C
0A50:  RCALL  0356
0A52:  BTFSC  16.7
0A54:  BSF    FF2.7
....................       delay_us(1000000/MODBUS_SERIAL_BAUD); //one stop bit.  not exact 
0A56:  MOVLW  8A
0A58:  MOVWF  00
0A5A:  DECFSZ 00,F
0A5C:  BRA    0A5A
0A5E:  NOP   
....................    #endif 
.................... } 
0A60:  RETLW  00
....................  
.................... // Purpose:   Interrupt service routine for handling incoming serial data 
.................... // Inputs:    None 
.................... // Outputs:   None 
.................... #if (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA) 
.................... #int_rda 
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA2) 
.................... #int_rda2 
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA3) 
.................... #int_rda3 
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA4) 
.................... #int_rda4 
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_EXT) 
.................... #if defined(__PCD__) 
.................... #int_ext0 
.................... #else 
.................... #int_ext 
.................... #endif 
.................... #else 
.................... #error Please define a correct interrupt source 
.................... #endif 
.................... void incomming_modbus_serial() { 
....................    char c; 
....................    #if (MODBUS_SERIAL_TYPE==MODBUS_ASCII) 
....................       static int1 two_characters=0; 
....................       static int8 datah,datal,data; 
....................    #endif 
....................  
....................    c=fgetc(MODBUS_SERIAL); 
*
0388:  RCALL  0340
038A:  MOVFF  01,7B
....................     
....................    if (!modbus_serial_new) 
038E:  BTFSC  1C.0
0390:  BRA    03E4
....................    { 
....................       #if (MODBUS_SERIAL_TYPE==MODBUS_ASCII) 
....................          if(modbus_serial_state == MODBUS_START) 
....................          { 
....................             if(c==':') 
....................                modbus_serial_state++; 
....................          } 
....................          else if(modbus_serial_state == MODBUS_GETADDY) 
....................          { 
....................             if(!two_characters) 
....................             { 
....................                if(c>=0x41) 
....................                   datah=((c-0x37)<<4); 
....................                else 
....................                   datah=((c-0x30)<<4); 
....................                modbus_serial_lrc=0; 
....................             } 
....................             else 
....................             { 
....................                if(c>=0x41) 
....................                   datal=c-0x37; 
....................                else 
....................                   datal=c-0x30; 
....................                data=(datah | datal); 
....................                modbus_rx.address=data; 
....................                modbus_calc_crc(data); 
....................                modbus_serial_state++; 
....................             } 
....................             two_characters++; 
....................          } 
....................          else if(modbus_serial_state == MODBUS_GETFUNC) 
....................          { 
....................             if(!two_characters) 
....................             { 
....................                if(c>=0x41) 
....................                   datah=((c-0x37)<<4); 
....................                else 
....................                   datah=((c-0x30)<<4); 
....................             } 
....................             else 
....................             { 
....................                if(c>=0x41) 
....................                   datal=c-0x37; 
....................                else 
....................                   datal=c-0x30; 
....................                data=(datah | datal); 
....................                modbus_rx.func=data; 
....................                modbus_calc_crc(data); 
....................                modbus_serial_state++; 
....................                modbus_rx.len=0; 
....................                modbus_rx.error=0; 
....................             } 
....................             two_characters++; 
....................          } 
....................          else if(modbus_serial_state == MODBUS_GETDATA) 
....................          { 
....................             if(c=='\r') 
....................             { 
....................                modbus_serial_state++; 
....................                modbus_rx.len--; 
....................                modbus_serial_lrc-=data; 
....................             } 
....................             else if(!two_characters) 
....................             { 
....................                if(c>=0x41) 
....................                   datah=((c-0x37)<<4); 
....................                else 
....................                   datah=((c-0x30)<<4); 
....................                two_characters++; 
....................             } 
....................             else 
....................             { 
....................                if(c>=0x41) 
....................                   datal=c-0x37; 
....................                else 
....................                   datal=c-0x30; 
....................                data=(datah | datal); 
....................                if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) 
....................                   modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1; 
....................                modbus_rx.data[modbus_rx.len]=data; 
....................                modbus_rx.len++; 
....................                modbus_calc_crc(data); 
....................                two_characters++; 
....................             } 
....................          } 
....................          else if(modbus_serial_state==MODBUS_STOP) 
....................          { 
....................             if(c=='\n') 
....................             { 
....................                modbus_serial_lrc=((0xFF-modbus_serial_lrc)+1); 
....................                if(modbus_serial_lrc==data) 
....................                   modbus_serial_new=TRUE; 
....................             } 
....................             modbus_serial_state=MODBUS_START; 
....................             two_characters=0; 
....................          } 
....................       #else 
....................              
....................          if(modbus_serial_state == MODBUS_GETADDY) 
0392:  MOVF   1D,F
0394:  BNZ   03A8
....................          { 
....................             modbus_serial_crc.d = 0xFFFF; 
0396:  MOVLW  FF
0398:  MOVWF  1F
039A:  MOVWF  1E
....................             modbus_rx.address = c; 
039C:  MOVFF  7B,20
....................             modbus_serial_state++; 
03A0:  INCF   1D,F
....................             modbus_rx.len = 0; 
03A2:  CLRF   21
....................             modbus_rx.error=0; 
03A4:  CLRF   23
....................          } 
....................          else if(modbus_serial_state == MODBUS_GETFUNC) 
03A6:  BRA    03D8
03A8:  DECFSZ 1D,W
03AA:  BRA    03B4
....................          { 
....................             modbus_rx.func = c; 
03AC:  MOVFF  7B,22
....................             modbus_serial_state++; 
03B0:  INCF   1D,F
....................          } 
....................          else if(modbus_serial_state == MODBUS_GETDATA) 
03B2:  BRA    03D8
03B4:  MOVF   1D,W
03B6:  SUBLW  02
03B8:  BNZ   03D8
....................          { 
....................             if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) {modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1;} 
03BA:  MOVF   21,W
03BC:  SUBLW  3F
03BE:  BC    03C4
03C0:  MOVLW  3F
03C2:  MOVWF  21
....................             modbus_rx.data[modbus_rx.len]=c; 
03C4:  CLRF   03
03C6:  MOVF   21,W
03C8:  ADDLW  24
03CA:  MOVWF  FE9
03CC:  MOVLW  00
03CE:  ADDWFC 03,W
03D0:  MOVWF  FEA
03D2:  MOVFF  7B,FEF
....................             modbus_rx.len++; 
03D6:  INCF   21,F
....................          } 
....................     
....................          modbus_calc_crc(c); 
03D8:  MOVFF  7B,7C
03DC:  RCALL  0356
....................          modbus_enable_timeout(TRUE); 
03DE:  MOVLW  01
03E0:  MOVWF  x7C
03E2:  RCALL  0304
....................       #endif 
....................    } 
....................    #if (MODBUS_TYPE == MODBUS_TYPE_MASTER) 
....................       modbus_serial_wait=MODBUS_SERIAL_TIMEOUT; 
03E4:  CLRF   1B
03E6:  CLRF   1A
03E8:  MOVLW  27
03EA:  MOVWF  19
03EC:  MOVLW  10
03EE:  MOVWF  18
....................    #endif 
.................... } 
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... //             4) The length of the data 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
03F0:  BCF    F9E.5
03F2:  GOTO   0060
.................... void modbus_serial_send_start(int8 to, int8 func) 
.................... { 
....................    #if (MODBUS_SERIAL_TYPE==MODBUS_ASCII) 
....................       modbus_serial_lrc=0; 
....................    #else 
....................       modbus_serial_crc.d=0xFFFF; 
*
0A62:  MOVLW  FF
0A64:  MOVWF  1F
0A66:  MOVWF  1E
....................    #endif 
....................    modbus_serial_new=FALSE; 
0A68:  BCF    1C.0
....................  
....................    RCV_OFF(); 
0A6A:  BCF    F9D.5
....................     
.................... #if (MODBUS_SERIAL_ENABLE_PIN!=0)  
....................    output_high(MODBUS_SERIAL_ENABLE_PIN); 
0A6C:  BCF    F93.2
0A6E:  BSF    F8A.2
.................... #endif 
....................  
....................    #if (MODBUS_SERIAL_TYPE==MODBUS_RTU) 
....................       delay_us(3500000/MODBUS_SERIAL_BAUD); //3.5 character delay 
0A70:  MOVLW  01
0A72:  MOVWF  x76
0A74:  RCALL  07B4
0A76:  MOVLW  02
0A78:  MOVWF  x76
0A7A:  MOVLW  E2
0A7C:  MOVWF  x77
0A7E:  RCALL  0A12
0A80:  DECFSZ x76,F
0A82:  BRA    0A7A
....................    #else 
....................       fputc(':',MODBUS_SERIAL); 
....................    #endif 
....................  
....................    modbus_serial_putc(to); 
0A84:  MOVFF  74,77
0A88:  RCALL  0A40
....................    modbus_serial_putc(func); 
0A8A:  MOVFF  75,77
0A8E:  RCALL  0A40
.................... } 
0A90:  RETLW  00
....................  
.................... void modbus_serial_send_stop() 
.................... { 
....................    #if (MODBUS_SERIAL_TYPE == MODBUS_ASCII) 
....................       int8 i; 
....................        
....................       for(i=0;i<8;i++) 
....................       { 
....................          if(bit_test(modbus_serial_lrc,i)) 
....................             bit_clear(modbus_serial_lrc,i); 
....................          else 
....................             bit_set(modbus_serial_lrc,i); 
....................       } 
....................       modbus_serial_lrc++; 
....................        
....................       modbus_serial_putc(modbus_serial_lrc); 
....................       fputc('\r',MODBUS_SERIAL); 
....................       fputc('\n',MODBUS_SERIAL); 
....................    #else 
....................       int8 crc_low, crc_high; 
....................     
....................       crc_high=modbus_serial_crc.b[1]; 
0A92:  MOVFF  1F,75
....................       crc_low=modbus_serial_crc.b[0]; 
0A96:  MOVFF  1E,74
....................     
....................       modbus_serial_putc(crc_high); 
0A9A:  MOVFF  75,77
0A9E:  RCALL  0A40
....................       modbus_serial_putc(crc_low); 
0AA0:  MOVFF  74,77
0AA4:  RCALL  0A40
....................    #endif 
....................     
.................... #if (MODBUS_SERIAL_INT_SOURCE!=MODBUS_INT_EXT) 
....................    WAIT_FOR_HW_BUFFER(); 
0AA6:  BTFSS  FAC.1
0AA8:  BRA    0AA6
.................... #endif 
....................     
....................    #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
....................       delay_us(3500000/MODBUS_SERIAL_BAUD); //3.5 character delay 
0AAA:  MOVLW  01
0AAC:  MOVWF  x76
0AAE:  RCALL  07B4
0AB0:  MOVLW  02
0AB2:  MOVWF  x76
0AB4:  MOVLW  E2
0AB6:  MOVWF  x77
0AB8:  RCALL  0A12
0ABA:  DECFSZ x76,F
0ABC:  BRA    0AB4
....................    #endif 
....................  
....................    RCV_ON(); 
0ABE:  RCALL  08EA
....................  
.................... #if (MODBUS_SERIAL_ENABLE_PIN!=0)  
....................    output_low(MODBUS_SERIAL_ENABLE_PIN); 
0AC0:  BCF    F93.2
0AC2:  BCF    F8A.2
.................... #endif 
....................  
....................    #if (MODBUS_SERIAL_TYPE == MODBUS_ASCII) 
....................       modbus_serial_lrc=0; 
....................    #else 
....................       modbus_serial_crc.d=0xFFFF; 
0AC4:  MOVLW  FF
0AC6:  MOVWF  1F
0AC8:  MOVWF  1E
....................    #endif 
.................... } 
0ACA:  RETLW  00
....................  
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer 
.................... // Inputs:     None 
.................... // Outputs:    TRUE if a message was received 
.................... //             FALSE if no message is available 
.................... // Note:       Data will be filled in at the modbus_rx struct: 
.................... int1 modbus_kbhit() 
.................... { 
....................    if(!modbus_serial_new) 
0ACC:  BTFSC  1C.0
0ACE:  BRA    0AD8
....................       return FALSE; 
0AD0:  MOVLW  00
0AD2:  MOVWF  01
0AD4:  BRA    0AEA
....................    else if(modbus_rx.func & 0x80)           //did we receive an error? 
0AD6:  BRA    0AE4
0AD8:  BTFSS  22.7
0ADA:  BRA    0AE4
....................    { 
....................       modbus_rx.error = modbus_rx.data[0];  //if so grab the error and return true 
0ADC:  MOVFF  24,23
....................       modbus_rx.len = 1; 
0AE0:  MOVLW  01
0AE2:  MOVWF  21
....................    } 
....................    modbus_serial_new=FALSE; 
0AE4:  BCF    1C.0
....................    return TRUE; 
0AE6:  MOVLW  01
0AE8:  MOVWF  01
.................... } 
0AEA:  RETLW  00
....................  
.................... #if (MODBUS_TYPE==MODBUS_TYPE_MASTER) 
.................... /*MODBUS Master Functions*/ 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request.  These 
.................... functions take in one of these structs. 
.................... Please refer to the MODBUS protocol specification if you do not 
.................... understand the members of the structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
.................... } modbus_read_sub_request; 
....................  
.................... typedef struct _modbus_write_sub_request 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
....................    int16 data[MODBUS_SERIAL_RX_BUFFER_SIZE-8]; 
.................... } modbus_write_sub_request; 
....................  
....................  
.................... /******************************************************************** 
.................... The following functions are defined in the MODBUS protocol.  Please 
.................... refer to http://www.modbus.org for the purpose of each of these. 
.................... All functions take the slaves address as their first parameter. 
.................... Each function returns the exception code received from the response. 
.................... The function will return 0 if there were no errors in transmission. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_coils(int8 address, int16 start_address, int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
0AEC:  MOVFF  67,74
0AF0:  MOVLW  01
0AF2:  MOVWF  x75
0AF4:  RCALL  0A62
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
0AF6:  MOVFF  69,6C
0AFA:  MOVFF  69,77
0AFE:  RCALL  0A40
....................    modbus_serial_putc(make8(start_address,0)); 
0B00:  MOVFF  68,6C
0B04:  MOVFF  68,77
0B08:  RCALL  0A40
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
0B0A:  MOVFF  6B,6C
0B0E:  MOVFF  6B,77
0B12:  RCALL  0A40
....................    modbus_serial_putc(make8(quantity,0)); 
0B14:  MOVFF  6A,6C
0B18:  MOVFF  6A,77
0B1C:  RCALL  0A40
....................  
....................    modbus_serial_send_stop(); 
0B1E:  RCALL  0A92
....................     
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
0B20:  MOVF   x67,F
0B22:  BZ    0B62
0B24:  RCALL  0ACC
0B26:  MOVF   01,F
0B28:  BNZ   0B4E
0B2A:  MOVLW  FF
0B2C:  ADDWF  18,F
0B2E:  BTFSS  FD8.0
0B30:  ADDWF  19,F
0B32:  BTFSS  FD8.0
0B34:  ADDWF  1A,F
0B36:  BTFSS  FD8.0
0B38:  ADDWF  1B,F
0B3A:  MOVF   18,F
0B3C:  BNZ   0B4A
0B3E:  MOVF   19,F
0B40:  BNZ   0B4A
0B42:  MOVF   1A,F
0B44:  BNZ   0B4A
0B46:  MOVF   1B,F
0B48:  BZ    0B4E
0B4A:  NOP   
0B4C:  BRA    0B24
0B4E:  MOVF   18,F
0B50:  BNZ   0B62
0B52:  MOVF   19,F
0B54:  BNZ   0B62
0B56:  MOVF   1A,F
0B58:  BNZ   0B62
0B5A:  MOVF   1B,F
0B5C:  BNZ   0B62
0B5E:  MOVLW  0C
0B60:  MOVWF  23
0B62:  CLRF   1B
0B64:  CLRF   1A
0B66:  MOVLW  27
0B68:  MOVWF  19
0B6A:  MOVLW  10
0B6C:  MOVWF  18
....................  
....................    return modbus_rx.error; 
0B6E:  MOVFF  23,01
.................... } 
0B72:  GOTO   0BEC (RETURN)
....................  
.................... /* 
.................... read_discrete_input 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_discrete_input(int8 address, int16 start_address, int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
*
0C60:  MOVFF  67,74
0C64:  MOVLW  02
0C66:  MOVWF  x75
0C68:  RCALL  0A62
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
0C6A:  MOVFF  69,6C
0C6E:  MOVFF  69,77
0C72:  RCALL  0A40
....................    modbus_serial_putc(make8(start_address,0)); 
0C74:  MOVFF  68,6C
0C78:  MOVFF  68,77
0C7C:  RCALL  0A40
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
0C7E:  MOVFF  6B,6C
0C82:  MOVFF  6B,77
0C86:  RCALL  0A40
....................    modbus_serial_putc(make8(quantity,0)); 
0C88:  MOVFF  6A,6C
0C8C:  MOVFF  6A,77
0C90:  RCALL  0A40
....................  
....................    modbus_serial_send_stop(); 
0C92:  RCALL  0A92
....................        
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
0C94:  MOVF   x67,F
0C96:  BZ    0CD6
0C98:  RCALL  0ACC
0C9A:  MOVF   01,F
0C9C:  BNZ   0CC2
0C9E:  MOVLW  FF
0CA0:  ADDWF  18,F
0CA2:  BTFSS  FD8.0
0CA4:  ADDWF  19,F
0CA6:  BTFSS  FD8.0
0CA8:  ADDWF  1A,F
0CAA:  BTFSS  FD8.0
0CAC:  ADDWF  1B,F
0CAE:  MOVF   18,F
0CB0:  BNZ   0CBE
0CB2:  MOVF   19,F
0CB4:  BNZ   0CBE
0CB6:  MOVF   1A,F
0CB8:  BNZ   0CBE
0CBA:  MOVF   1B,F
0CBC:  BZ    0CC2
0CBE:  NOP   
0CC0:  BRA    0C98
0CC2:  MOVF   18,F
0CC4:  BNZ   0CD6
0CC6:  MOVF   19,F
0CC8:  BNZ   0CD6
0CCA:  MOVF   1A,F
0CCC:  BNZ   0CD6
0CCE:  MOVF   1B,F
0CD0:  BNZ   0CD6
0CD2:  MOVLW  0C
0CD4:  MOVWF  23
0CD6:  CLRF   1B
0CD8:  CLRF   1A
0CDA:  MOVLW  27
0CDC:  MOVWF  19
0CDE:  MOVLW  10
0CE0:  MOVWF  18
....................  
....................    return modbus_rx.error; 
0CE2:  MOVFF  23,01
.................... } 
0CE6:  GOTO   0D04 (RETURN)
....................  
.................... /* 
.................... read_holding_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_holding_registers(int8 address, int16 start_address, int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
*
0D78:  MOVFF  67,74
0D7C:  MOVLW  03
0D7E:  MOVWF  x75
0D80:  RCALL  0A62
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
0D82:  MOVFF  69,6C
0D86:  MOVFF  69,77
0D8A:  RCALL  0A40
....................    modbus_serial_putc(make8(start_address,0)); 
0D8C:  MOVFF  68,6C
0D90:  MOVFF  68,77
0D94:  RCALL  0A40
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
0D96:  MOVFF  6B,6C
0D9A:  MOVFF  6B,77
0D9E:  RCALL  0A40
....................    modbus_serial_putc(make8(quantity,0)); 
0DA0:  MOVFF  6A,6C
0DA4:  MOVFF  6A,77
0DA8:  RCALL  0A40
....................  
....................    modbus_serial_send_stop(); 
0DAA:  RCALL  0A92
....................     
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
0DAC:  MOVF   x67,F
0DAE:  BZ    0DEE
0DB0:  RCALL  0ACC
0DB2:  MOVF   01,F
0DB4:  BNZ   0DDA
0DB6:  MOVLW  FF
0DB8:  ADDWF  18,F
0DBA:  BTFSS  FD8.0
0DBC:  ADDWF  19,F
0DBE:  BTFSS  FD8.0
0DC0:  ADDWF  1A,F
0DC2:  BTFSS  FD8.0
0DC4:  ADDWF  1B,F
0DC6:  MOVF   18,F
0DC8:  BNZ   0DD6
0DCA:  MOVF   19,F
0DCC:  BNZ   0DD6
0DCE:  MOVF   1A,F
0DD0:  BNZ   0DD6
0DD2:  MOVF   1B,F
0DD4:  BZ    0DDA
0DD6:  NOP   
0DD8:  BRA    0DB0
0DDA:  MOVF   18,F
0DDC:  BNZ   0DEE
0DDE:  MOVF   19,F
0DE0:  BNZ   0DEE
0DE2:  MOVF   1A,F
0DE4:  BNZ   0DEE
0DE6:  MOVF   1B,F
0DE8:  BNZ   0DEE
0DEA:  MOVLW  0C
0DEC:  MOVWF  23
0DEE:  CLRF   1B
0DF0:  CLRF   1A
0DF2:  MOVLW  27
0DF4:  MOVWF  19
0DF6:  MOVLW  10
0DF8:  MOVWF  18
....................  
....................    return modbus_rx.error; 
0DFA:  MOVFF  23,01
.................... } 
0DFE:  GOTO   0E1C (RETURN)
....................  
.................... /* 
.................... read_input_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_input_registers(int8 address, int16 start_address, int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
*
0E90:  MOVFF  67,74
0E94:  MOVLW  04
0E96:  MOVWF  x75
0E98:  RCALL  0A62
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
0E9A:  MOVFF  69,6C
0E9E:  MOVFF  69,77
0EA2:  RCALL  0A40
....................    modbus_serial_putc(make8(start_address,0)); 
0EA4:  MOVFF  68,6C
0EA8:  MOVFF  68,77
0EAC:  RCALL  0A40
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
0EAE:  MOVFF  6B,6C
0EB2:  MOVFF  6B,77
0EB6:  RCALL  0A40
....................    modbus_serial_putc(make8(quantity,0)); 
0EB8:  MOVFF  6A,6C
0EBC:  MOVFF  6A,77
0EC0:  RCALL  0A40
....................  
....................    modbus_serial_send_stop(); 
0EC2:  RCALL  0A92
....................     
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
0EC4:  MOVF   x67,F
0EC6:  BZ    0F06
0EC8:  RCALL  0ACC
0ECA:  MOVF   01,F
0ECC:  BNZ   0EF2
0ECE:  MOVLW  FF
0ED0:  ADDWF  18,F
0ED2:  BTFSS  FD8.0
0ED4:  ADDWF  19,F
0ED6:  BTFSS  FD8.0
0ED8:  ADDWF  1A,F
0EDA:  BTFSS  FD8.0
0EDC:  ADDWF  1B,F
0EDE:  MOVF   18,F
0EE0:  BNZ   0EEE
0EE2:  MOVF   19,F
0EE4:  BNZ   0EEE
0EE6:  MOVF   1A,F
0EE8:  BNZ   0EEE
0EEA:  MOVF   1B,F
0EEC:  BZ    0EF2
0EEE:  NOP   
0EF0:  BRA    0EC8
0EF2:  MOVF   18,F
0EF4:  BNZ   0F06
0EF6:  MOVF   19,F
0EF8:  BNZ   0F06
0EFA:  MOVF   1A,F
0EFC:  BNZ   0F06
0EFE:  MOVF   1B,F
0F00:  BNZ   0F06
0F02:  MOVLW  0C
0F04:  MOVWF  23
0F06:  CLRF   1B
0F08:  CLRF   1A
0F0A:  MOVLW  27
0F0C:  MOVWF  19
0F0E:  MOVLW  10
0F10:  MOVWF  18
....................  
....................    return modbus_rx.error; 
0F12:  MOVFF  23,01
.................... } 
0F16:  GOTO   0F74 (RETURN)
....................  
.................... /* 
.................... write_single_coil 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Address to write into 
....................            int1       on                 true for on, false for off 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_single_coil(int8 address, int16 output_address, int1 on) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
*
106E:  MOVFF  67,74
1072:  MOVLW  05
1074:  MOVWF  x75
1076:  RCALL  0A62
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
1078:  MOVFF  69,6B
107C:  MOVFF  69,77
1080:  RCALL  0A40
....................    modbus_serial_putc(make8(output_address,0)); 
1082:  MOVFF  68,6B
1086:  MOVFF  68,77
108A:  RCALL  0A40
....................  
....................    if(on) 
108C:  MOVF   x6A,F
108E:  BZ    1098
....................        modbus_serial_putc(0xFF); 
1090:  MOVLW  FF
1092:  MOVWF  x77
1094:  RCALL  0A40
....................    else 
1096:  BRA    109C
....................        modbus_serial_putc(0x00); 
1098:  CLRF   x77
109A:  RCALL  0A40
....................     
....................    modbus_serial_putc(0x00); 
109C:  CLRF   x77
109E:  RCALL  0A40
....................  
....................    modbus_serial_send_stop(); 
10A0:  RCALL  0A92
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
10A2:  MOVF   x67,F
10A4:  BZ    10E4
10A6:  RCALL  0ACC
10A8:  MOVF   01,F
10AA:  BNZ   10D0
10AC:  MOVLW  FF
10AE:  ADDWF  18,F
10B0:  BTFSS  FD8.0
10B2:  ADDWF  19,F
10B4:  BTFSS  FD8.0
10B6:  ADDWF  1A,F
10B8:  BTFSS  FD8.0
10BA:  ADDWF  1B,F
10BC:  MOVF   18,F
10BE:  BNZ   10CC
10C0:  MOVF   19,F
10C2:  BNZ   10CC
10C4:  MOVF   1A,F
10C6:  BNZ   10CC
10C8:  MOVF   1B,F
10CA:  BZ    10D0
10CC:  NOP   
10CE:  BRA    10A6
10D0:  MOVF   18,F
10D2:  BNZ   10E4
10D4:  MOVF   19,F
10D6:  BNZ   10E4
10D8:  MOVF   1A,F
10DA:  BNZ   10E4
10DC:  MOVF   1B,F
10DE:  BNZ   10E4
10E0:  MOVLW  0C
10E2:  MOVWF  23
10E4:  CLRF   1B
10E6:  CLRF   1A
10E8:  MOVLW  27
10EA:  MOVWF  19
10EC:  MOVLW  10
10EE:  MOVWF  18
....................  
....................    return modbus_rx.error; 
10F0:  MOVFF  23,01
.................... } 
10F4:  GOTO   1114 (RETURN)
....................  
.................... /* 
.................... write_single_register 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Address to write into 
....................            int16      reg_value          Value to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_single_register(int8 address, int16 reg_address, int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
*
118C:  MOVFF  67,74
1190:  MOVLW  06
1192:  MOVWF  x75
1194:  RCALL  0A62
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
1196:  MOVFF  69,6C
119A:  MOVFF  69,77
119E:  RCALL  0A40
....................    modbus_serial_putc(make8(reg_address,0)); 
11A0:  MOVFF  68,6C
11A4:  MOVFF  68,77
11A8:  RCALL  0A40
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
11AA:  MOVFF  6B,6C
11AE:  MOVFF  6B,77
11B2:  RCALL  0A40
....................    modbus_serial_putc(make8(reg_value,0)); 
11B4:  MOVFF  6A,6C
11B8:  MOVFF  6A,77
11BC:  RCALL  0A40
....................  
....................    modbus_serial_send_stop(); 
11BE:  RCALL  0A92
....................     
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
11C0:  MOVF   x67,F
11C2:  BZ    1202
11C4:  RCALL  0ACC
11C6:  MOVF   01,F
11C8:  BNZ   11EE
11CA:  MOVLW  FF
11CC:  ADDWF  18,F
11CE:  BTFSS  FD8.0
11D0:  ADDWF  19,F
11D2:  BTFSS  FD8.0
11D4:  ADDWF  1A,F
11D6:  BTFSS  FD8.0
11D8:  ADDWF  1B,F
11DA:  MOVF   18,F
11DC:  BNZ   11EA
11DE:  MOVF   19,F
11E0:  BNZ   11EA
11E2:  MOVF   1A,F
11E4:  BNZ   11EA
11E6:  MOVF   1B,F
11E8:  BZ    11EE
11EA:  NOP   
11EC:  BRA    11C4
11EE:  MOVF   18,F
11F0:  BNZ   1202
11F2:  MOVF   19,F
11F4:  BNZ   1202
11F6:  MOVF   1A,F
11F8:  BNZ   1202
11FA:  MOVF   1B,F
11FC:  BNZ   1202
11FE:  MOVLW  0C
1200:  MOVWF  23
1202:  CLRF   1B
1204:  CLRF   1A
1206:  MOVLW  27
1208:  MOVWF  19
120A:  MOVLW  10
120C:  MOVWF  18
....................  
....................    return modbus_rx.error; 
120E:  MOVFF  23,01
.................... } 
1212:  GOTO   1234 (RETURN)
....................  
.................... /* 
.................... read_exception_status 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_exception_status(int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... diagnostics 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Subfunction to send 
....................            int16      data               Data to send, changes based on subfunction 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_diagnostics(int8 address, int16 sub_func, int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
*
15F8:  MOVFF  67,74
15FC:  MOVLW  08
15FE:  MOVWF  x75
1600:  CALL   0A62
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
1604:  MOVFF  69,6C
1608:  MOVFF  69,77
160C:  CALL   0A40
....................    modbus_serial_putc(make8(sub_func,0)); 
1610:  MOVFF  68,6C
1614:  MOVFF  68,77
1618:  CALL   0A40
....................  
....................    modbus_serial_putc(make8(data,1)); 
161C:  MOVFF  6B,6C
1620:  MOVFF  6B,77
1624:  CALL   0A40
....................    modbus_serial_putc(make8(data,0)); 
1628:  MOVFF  6A,6C
162C:  MOVFF  6A,77
1630:  CALL   0A40
....................  
....................    modbus_serial_send_stop(); 
1634:  CALL   0A92
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
1638:  MOVF   x67,F
163A:  BZ    167C
163C:  CALL   0ACC
1640:  MOVF   01,F
1642:  BNZ   1668
1644:  MOVLW  FF
1646:  ADDWF  18,F
1648:  BTFSS  FD8.0
164A:  ADDWF  19,F
164C:  BTFSS  FD8.0
164E:  ADDWF  1A,F
1650:  BTFSS  FD8.0
1652:  ADDWF  1B,F
1654:  MOVF   18,F
1656:  BNZ   1664
1658:  MOVF   19,F
165A:  BNZ   1664
165C:  MOVF   1A,F
165E:  BNZ   1664
1660:  MOVF   1B,F
1662:  BZ    1668
1664:  NOP   
1666:  BRA    163C
1668:  MOVF   18,F
166A:  BNZ   167C
166C:  MOVF   19,F
166E:  BNZ   167C
1670:  MOVF   1A,F
1672:  BNZ   167C
1674:  MOVF   1B,F
1676:  BNZ   167C
1678:  MOVLW  0C
167A:  MOVWF  23
167C:  CLRF   1B
167E:  CLRF   1A
1680:  MOVLW  27
1682:  MOVWF  19
1684:  MOVLW  10
1686:  MOVWF  18
....................  
....................    return modbus_rx.error; 
1688:  MOVFF  23,01
.................... } 
168C:  GOTO   16B6 (RETURN)
....................  
.................... /* 
.................... get_comm_event_couter 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_get_comm_event_counter(int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... get_comm_event_log 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_get_comm_event_log(int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start at 
....................            int16      quantity           Amount of coils to write to 
....................            int1*      values             A pointer to an array holding the values to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_multiple_coils(int8 address, int16 start_address, int16 quantity, 
....................                            int8 *values) 
.................... { 
....................    int8 i,count; 
....................     
....................    count = (int8)((quantity/8)); 
*
12AC:  RRCF   x6C,W
12AE:  MOVWF  03
12B0:  RRCF   x6B,W
12B2:  MOVWF  02
12B4:  RRCF   03,F
12B6:  RRCF   02,F
12B8:  RRCF   03,F
12BA:  RRCF   02,F
12BC:  MOVLW  1F
12BE:  ANDWF  03,F
12C0:  MOVFF  02,70
....................     
....................    if(quantity%8) 
12C4:  MOVF   x6B,W
12C6:  ANDLW  07
12C8:  MOVWF  00
12CA:  CLRF   03
12CC:  MOVF   00,W
12CE:  IORWF  03,W
12D0:  BZ    12D4
....................       count++;       
12D2:  INCF   x70,F
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
12D4:  MOVFF  68,74
12D8:  MOVLW  0F
12DA:  MOVWF  x75
12DC:  CALL   0A62
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
12E0:  MOVFF  6A,71
12E4:  MOVFF  6A,77
12E8:  CALL   0A40
....................    modbus_serial_putc(make8(start_address,0)); 
12EC:  MOVFF  69,71
12F0:  MOVFF  69,77
12F4:  CALL   0A40
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
12F8:  MOVFF  6C,71
12FC:  MOVFF  6C,77
1300:  CALL   0A40
....................    modbus_serial_putc(make8(quantity,0)); 
1304:  MOVFF  6B,71
1308:  MOVFF  6B,77
130C:  CALL   0A40
....................  
....................    modbus_serial_putc(count); 
1310:  MOVFF  70,77
1314:  CALL   0A40
....................  
....................    for(i=0; i < count; ++i)  
1318:  CLRF   x6F
131A:  MOVF   x70,W
131C:  SUBWF  x6F,W
131E:  BC    133E
....................       modbus_serial_putc(values[i]); 
1320:  CLRF   03
1322:  MOVF   x6F,W
1324:  ADDWF  x6D,W
1326:  MOVWF  FE9
1328:  MOVF   x6E,W
132A:  ADDWFC 03,W
132C:  MOVWF  FEA
132E:  MOVFF  FEF,71
1332:  MOVFF  71,77
1336:  CALL   0A40
133A:  INCF   x6F,F
133C:  BRA    131A
....................  
....................    modbus_serial_send_stop(); 
133E:  CALL   0A92
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
1342:  MOVF   x68,F
1344:  BZ    1386
1346:  CALL   0ACC
134A:  MOVF   01,F
134C:  BNZ   1372
134E:  MOVLW  FF
1350:  ADDWF  18,F
1352:  BTFSS  FD8.0
1354:  ADDWF  19,F
1356:  BTFSS  FD8.0
1358:  ADDWF  1A,F
135A:  BTFSS  FD8.0
135C:  ADDWF  1B,F
135E:  MOVF   18,F
1360:  BNZ   136E
1362:  MOVF   19,F
1364:  BNZ   136E
1366:  MOVF   1A,F
1368:  BNZ   136E
136A:  MOVF   1B,F
136C:  BZ    1372
136E:  NOP   
1370:  BRA    1346
1372:  MOVF   18,F
1374:  BNZ   1386
1376:  MOVF   19,F
1378:  BNZ   1386
137A:  MOVF   1A,F
137C:  BNZ   1386
137E:  MOVF   1B,F
1380:  BNZ   1386
1382:  MOVLW  0C
1384:  MOVWF  23
1386:  CLRF   1B
1388:  CLRF   1A
138A:  MOVLW  27
138C:  MOVWF  19
138E:  MOVLW  10
1390:  MOVWF  18
....................  
....................    return modbus_rx.error; 
1392:  MOVFF  23,01
.................... } 
1396:  GOTO   13C2 (RETURN)
....................  
.................... /* 
.................... write_multiple_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start at 
....................            int16      quantity           Amount of coils to write to 
....................            int16*     values             A pointer to an array holding the data to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_multiple_registers(int8 address, int16 start_address, int16 quantity, 
....................                            int16 *values) 
.................... { 
....................    int8 i,count; 
....................     
....................    count = quantity*2; 
*
1442:  BCF    FD8.0
1444:  RLCF   x6E,W
1446:  MOVWF  02
1448:  RLCF   x6F,W
144A:  MOVFF  02,73
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
144E:  MOVFF  6B,74
1452:  MOVLW  10
1454:  MOVWF  x75
1456:  CALL   0A62
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
145A:  MOVFF  6D,74
145E:  MOVFF  6D,77
1462:  CALL   0A40
....................    modbus_serial_putc(make8(start_address,0)); 
1466:  MOVFF  6C,74
146A:  MOVFF  6C,77
146E:  CALL   0A40
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
1472:  MOVFF  6F,74
1476:  MOVFF  6F,77
147A:  CALL   0A40
....................    modbus_serial_putc(make8(quantity,0)); 
147E:  MOVFF  6E,74
1482:  MOVFF  6E,77
1486:  CALL   0A40
....................     
....................    modbus_serial_putc(count); 
148A:  MOVFF  73,77
148E:  CALL   0A40
....................  
....................    for(i=0; i < quantity; ++i) 
1492:  CLRF   x72
1494:  MOVF   x6F,F
1496:  BNZ   149E
1498:  MOVF   x6E,W
149A:  SUBWF  x72,W
149C:  BC    14EE
....................    { 
....................       modbus_serial_putc(make8(values[i],1)); 
149E:  BCF    FD8.0
14A0:  RLCF   x72,W
14A2:  CLRF   03
14A4:  ADDWF  x70,W
14A6:  MOVWF  FE9
14A8:  MOVF   x71,W
14AA:  ADDWFC 03,W
14AC:  MOVWF  FEA
14AE:  MOVFF  FEC,75
14B2:  MOVF   FED,F
14B4:  MOVFF  FEF,74
14B8:  MOVFF  75,76
14BC:  MOVFF  75,77
14C0:  CALL   0A40
....................       modbus_serial_putc(make8(values[i],0)); 
14C4:  BCF    FD8.0
14C6:  RLCF   x72,W
14C8:  CLRF   03
14CA:  ADDWF  x70,W
14CC:  MOVWF  FE9
14CE:  MOVF   x71,W
14D0:  ADDWFC 03,W
14D2:  MOVWF  FEA
14D4:  MOVFF  FEC,75
14D8:  MOVF   FED,F
14DA:  MOVFF  FEF,74
14DE:  MOVFF  74,76
14E2:  MOVFF  74,77
14E6:  CALL   0A40
....................    } 
14EA:  INCF   x72,F
14EC:  BRA    1494
....................  
....................    modbus_serial_send_stop(); 
14EE:  CALL   0A92
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
14F2:  MOVF   x6B,F
14F4:  BZ    1536
14F6:  CALL   0ACC
14FA:  MOVF   01,F
14FC:  BNZ   1522
14FE:  MOVLW  FF
1500:  ADDWF  18,F
1502:  BTFSS  FD8.0
1504:  ADDWF  19,F
1506:  BTFSS  FD8.0
1508:  ADDWF  1A,F
150A:  BTFSS  FD8.0
150C:  ADDWF  1B,F
150E:  MOVF   18,F
1510:  BNZ   151E
1512:  MOVF   19,F
1514:  BNZ   151E
1516:  MOVF   1A,F
1518:  BNZ   151E
151A:  MOVF   1B,F
151C:  BZ    1522
151E:  NOP   
1520:  BRA    14F6
1522:  MOVF   18,F
1524:  BNZ   1536
1526:  MOVF   19,F
1528:  BNZ   1536
152A:  MOVF   1A,F
152C:  BNZ   1536
152E:  MOVF   1B,F
1530:  BNZ   1536
1532:  MOVLW  0C
1534:  MOVWF  23
1536:  CLRF   1B
1538:  CLRF   1A
153A:  MOVLW  27
153C:  MOVWF  19
153E:  MOVLW  10
1540:  MOVWF  18
....................  
....................    return modbus_rx.error; 
1542:  MOVFF  23,01
.................... } 
1546:  GOTO   1578 (RETURN)
....................  
.................... /* 
.................... report_slave_id 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_report_slave_id(int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_file_record 
.................... Input:     int8                address            Slave Address 
....................            int8                byte_count         Number of bytes to read 
....................            read_sub_request*   request            Structure holding record information 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_file_record(int8 address, int8 byte_count,  
....................                             modbus_read_sub_request *request) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < (byte_count/7); i+=7) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_file_record 
.................... Input:     int8                address            Slave Address 
....................            int8                byte_count         Number of bytes to read 
....................            read_sub_request*   request            Structure holding record/data information 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_file_record(int8 address, int8 byte_count,  
....................                             modbus_write_sub_request *request) 
.................... { 
....................    int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length) &&  
....................             (j < MODBUS_SERIAL_RX_BUFFER_SIZE-8); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... mask_write_register 
.................... Input:     int8       address            Slave Address 
....................            int16      reference_address  Address to mask 
....................            int16      AND_mask           A mask to AND with the data at reference_address 
....................            int16      OR_mask            A mask to OR with the data at reference_address 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_mask_write_register(int8 address, int16 reference_address, 
....................                            int16 AND_mask, int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers 
.................... Input:     int8       address                Slave Address 
....................            int16      read_start             Address to start reading 
....................            int16      read_quantity          Amount of registers to read 
....................            int16      write_start            Address to start writing 
....................            int16      write_quantity         Amount of registers to write 
....................            int16*     write_registers_value  Pointer to an aray us to write 
.................... Output:    exception                         0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_write_multiple_registers(int8 address, int16 read_start, 
....................                                     int16 read_quantity, int16 write_start, 
....................                                     int16 write_quantity, 
....................                                     int16 *write_registers_value) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(read_start,1)); 
....................    modbus_serial_putc(make8(read_start,0)); 
....................  
....................    modbus_serial_putc(make8(read_quantity,1)); 
....................    modbus_serial_putc(make8(read_quantity,0)); 
....................  
....................    modbus_serial_putc(make8(write_start, 1)); 
....................    modbus_serial_putc(make8(write_start, 0)); 
....................  
....................    modbus_serial_putc(make8(write_quantity, 1)); 
....................    modbus_serial_putc(make8(write_quantity, 0)); 
....................  
....................    modbus_serial_putc((int8)(2*write_quantity)); 
....................  
....................    for(i=0; i < write_quantity ; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(write_registers_value[i], 1)); 
....................       modbus_serial_putc(make8(write_registers_value[i+1], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue 
.................... Input:     int8       address           Slave Address 
....................            int16      FIFO_address      FIFO address 
.................... Output:    exception                    0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_FIFO_queue(int8 address, int16 FIFO_address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(FIFO_address, 1)); 
....................    modbus_serial_putc(make8(FIFO_address, 0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... #else 
.................... /*MODBUS Slave Functions*/ 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request_rsp.  These 
.................... functions take in one of these structs.  Please refer to the MODBUS 
.................... protocol specification if you do not understand the members of the 
.................... structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request_rsp 
.................... { 
....................    int8 record_length; 
....................    int8 reference_type; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3]; 
.................... } modbus_read_sub_request_rsp; 
....................  
.................... typedef struct _modbus_write_sub_request_rsp 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8]; 
.................... } modbus_write_sub_request_rsp; 
....................  
....................  
.................... /******************************************************************** 
.................... The following slave functions are defined in the MODBUS protocol. 
.................... Please refer to http://www.modbus.org for the purpose of each of 
.................... these.  All functions take the slaves address as their first 
.................... parameter. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      coil_data          Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_coils_rsp(int8 address, int8 byte_count, int8* coil_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*coil_data); 
....................       coil_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_discrete_input_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_discrete_input_rsp(int8 address, int8 byte_count,  
....................                                     int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_holding_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      reg_data           Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_holding_registers_rsp(int8 address, int8 byte_count,  
....................                                         int16 *reg_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(*reg_data,1)); 
....................       modbus_serial_putc(make8(*reg_data,0)); 
....................       reg_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_input_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_input_registers_rsp(int8 address, int8 byte_count,  
....................                                         int16 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(*input_data,1)); 
....................       modbus_serial_putc(make8(*input_data,0)); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_coil_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Echo of output address received 
....................            int16      output_value       Echo of output value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_coil_rsp(int8 address, int16 output_address,  
....................                                     int16 output_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
....................    modbus_serial_putc(make8(output_address,0)); 
....................  
....................    modbus_serial_putc(make8(output_value,1)); 
....................    modbus_serial_putc(make8(output_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_register_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Echo of register address received 
....................            int16      reg_value          Echo of register value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_register_rsp(int8 address, int16 reg_address,  
....................                                         int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
....................    modbus_serial_putc(make8(reg_address,0)); 
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
....................    modbus_serial_putc(make8(reg_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_exception_status_rsp 
.................... Input:     int8       address            Slave Address 
.................... Output:    void 
.................... */ 
.................... void modbus_read_exception_status_rsp(int8 address, int8 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... diagnostics_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Echo of sub function received 
....................            int16      data               Echo of data received 
.................... Output:    void 
.................... */ 
.................... void modbus_diagnostics_rsp(int8 address, int16 sub_func, int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_counter_rsp(int8 address, int16 status,  
....................                                         int16 event_count) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
....................            int16      message_count      Count of messages 
....................            int8*      events             Pointer to event data 
....................            int8       events_len         Length of event data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_log_rsp(int8 address, int16 status, 
....................                                     int16 event_count, int16 message_count,  
....................                                     int8 *events, int8 events_len) 
.................... { 
....................    int8 i; 
....................      
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................  
....................    modbus_serial_putc(events_len+6); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_putc(make8(message_count, 1)); 
....................    modbus_serial_putc(make8(message_count, 0)); 
....................  
....................    for(i=0; i < events_len; ++i) 
....................    { 
....................       modbus_serial_putc(*events); 
....................       events++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of coils written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_coils_rsp(int8 address, int16 start_address,  
....................                                         int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of registers written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_registers_rsp(int8 address, int16 start_address,  
....................                                             int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... report_slave_id_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       slave_id           Slave Address 
....................            int8       run_status         Are we running? 
....................            int8*      data               Pointer to an array holding the data 
....................            int8       data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_report_slave_id_rsp(int8 address, int8 slave_id, int1 run_status, 
....................                               int8 *data, int8 data_len) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................  
....................    modbus_serial_putc(data_len+2); 
....................    modbus_serial_putc(slave_id); 
....................  
....................    if(run_status) 
....................     modbus_serial_putc(0xFF); 
....................    else 
....................     modbus_serial_putc(0x00); 
....................  
....................    for(i=0; i < data_len; ++i) 
....................    { 
....................       modbus_serial_putc(*data); 
....................       data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Number of bytes to send 
....................            read_sub_request_rsp*    request            Structure holding record/data information 
.................... Output:    void 
.................... */ 
.................... void modbus_read_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_read_sub_request_rsp *request) 
.................... { 
....................    int8 i=0,j; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    while(i < byte_count); 
....................    { 
....................       modbus_serial_putc(request->record_length); 
....................       modbus_serial_putc(request->reference_type); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................  
....................       i += (request->record_length)+1; 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Echo of number of bytes sent 
....................            write_sub_request_rsp*   request            Echo of Structure holding record information 
.................... Output:    void 
.................... */ 
.................... void modbus_write_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_write_sub_request_rsp *request) 
.................... { 
....................    int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... mask_write_register_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       reference_address  Echo of reference address 
....................            int16       AND_mask           Echo of AND mask 
....................            int16       OR_mask            Echo or OR mask 
.................... Output:    void 
.................... */ 
.................... void modbus_mask_write_register_rsp(int8 address, int16 reference_address, 
....................                            int16 AND_mask, int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16*      data               Pointer to an array of data 
....................            int8        data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_read_write_multiple_registers_rsp(int8 address, int8 data_len,  
....................                                                 int16 *data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(data_len*2); 
....................  
....................    for(i=0; i < data_len*2; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       FIFO_len           Length of FIFO in bytes 
....................            int16*      data               Pointer to an array of data 
.................... Output:    void 
.................... */ 
.................... void modbus_read_FIFO_queue_rsp(int8 address, int16 FIFO_len, int16 *data) 
.................... { 
....................    int8 i; 
....................    int16 byte_count; 
....................  
....................    byte_count = ((FIFO_len*2)+2); 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(byte_count, 1)); 
....................    modbus_serial_putc(make8(byte_count, 0)); 
....................  
....................    modbus_serial_putc(make8(FIFO_len, 1)); 
....................    modbus_serial_putc(make8(FIFO_len, 0)); 
....................  
....................    for(i=0; i < FIFO_len; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... void modbus_exception_rsp(int8 address, int16 func, exception error) 
.................... { 
....................    modbus_serial_send_start(address, func|0x80); 
....................    modbus_serial_putc(error); 
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... #endif 
....................  
.................... #include "lcd.c" 
.................... /* 
.................... LCD 16x2 4bit communication 
....................  
.................... RD2 -> RS 
.................... RD3 -> E 
.................... RD4 -> D4 
.................... RD5 -> D5 
.................... RD6 -> D6 
.................... RD7 -> D7 
....................  
.................... */ 
....................  
.................... struct lcd_pin_map { 
....................            boolean rw; 
....................            boolean unused; 
....................            boolean rs ; 
.................... 	       boolean enable; 
....................         int     data : 4; 
....................         } lcd_4bit; 
....................  
....................  
.................... #byte lcd_4bit = 0xF83                          // on to port d (at address 8) 
....................  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #define lcd_line_two 0x40    // LCD RAM address for the second line 
....................  
....................  
.................... byte CONST LCD_INIT_STRING[4] = {0x20 | (lcd_type << 2), 0xc, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
....................  
....................                              // The following are used for setting 
....................                              // the I/O port direction register. 
....................  
.................... STRUCT lcd_pin_map const LCD_WRITE = {0,0,0,0,0}; // For write mode all pins are out 
....................  
....................  
.................... void lcd_send_nibble( byte n ) { 
....................       lcd_4bit.data = n; 
*
07DC:  SWAPF  x72,W
07DE:  ANDLW  F0
07E0:  MOVWF  00
07E2:  MOVLW  0F
07E4:  ANDWF  F83,W
07E6:  IORWF  00,W
07E8:  MOVWF  F83
....................       delay_cycles(100); 
07EA:  MOVLW  21
07EC:  MOVWF  00
07EE:  DECFSZ 00,F
07F0:  BRA    07EE
....................       lcd_4bit.enable = 1; 
07F2:  BSF    F83.3
....................       delay_us(2); 
07F4:  BRA    07F6
....................       lcd_4bit.enable = 0; 
07F6:  BCF    F83.3
.................... } 
07F8:  RETLW  00
....................  
....................  
.................... void lcd_send_byte( byte address, byte n ) { 
....................       lcd_4bit.rs = 0; 
07FA:  BCF    F83.2
....................       lcd_4bit.rs = address; 
07FC:  BTFSS  x6F.0
07FE:  BCF    F83.2
0800:  BTFSC  x6F.0
0802:  BSF    F83.2
....................       delay_cycles(100); 
0804:  MOVLW  21
0806:  MOVWF  00
0808:  DECFSZ 00,F
080A:  BRA    0808
....................       lcd_4bit.rw = 0; 
080C:  BCF    F83.0
....................       delay_cycles(100); 
080E:  MOVLW  21
0810:  MOVWF  00
0812:  DECFSZ 00,F
0814:  BRA    0812
....................       lcd_4bit.enable = 0; 
0816:  BCF    F83.3
....................       lcd_send_nibble(n >> 4); 
0818:  SWAPF  x70,W
081A:  MOVWF  x71
081C:  MOVLW  0F
081E:  ANDWF  x71,F
0820:  MOVFF  71,72
0824:  RCALL  07DC
....................       lcd_send_nibble(n & 0xf); 
0826:  MOVF   x70,W
0828:  ANDLW  0F
082A:  MOVWF  x71
082C:  MOVWF  x72
082E:  RCALL  07DC
.................... } 
0830:  RETLW  00
....................  
....................  
.................... void lcd_init() { 
....................     byte i; 
....................    set_tris_d(LCD_WRITE); 
0832:  MOVLW  00
0834:  MOVWF  F95
....................     lcd_4bit.rs = 0; 
0836:  BCF    F83.2
....................     lcd_4bit.rw = 0; 
0838:  BCF    F83.0
....................     lcd_4bit.enable = 0; 
083A:  BCF    F83.3
....................     delay_ms(15); 
083C:  MOVLW  0F
083E:  MOVWF  x76
0840:  RCALL  07B4
....................     for(i=1;i<=3;++i) { 
0842:  MOVLW  01
0844:  MOVWF  x66
0846:  MOVF   x66,W
0848:  SUBLW  03
084A:  BNC   085C
....................        lcd_send_nibble(3); 
084C:  MOVLW  03
084E:  MOVWF  x72
0850:  RCALL  07DC
....................        delay_ms(5); 
0852:  MOVLW  05
0854:  MOVWF  x76
0856:  RCALL  07B4
....................     } 
0858:  INCF   x66,F
085A:  BRA    0846
....................     lcd_send_nibble(2); 
085C:  MOVLW  02
085E:  MOVWF  x72
0860:  RCALL  07DC
....................     for(i=0;i<=3;++i) 
0862:  CLRF   x66
0864:  MOVF   x66,W
0866:  SUBLW  03
0868:  BNC   0886
....................        lcd_send_byte(0,LCD_INIT_STRING[i]); 
086A:  CLRF   03
086C:  MOVF   x66,W
086E:  MOVFF  FF2,67
0872:  BCF    FF2.7
0874:  RCALL  02E6
0876:  BTFSC  x67.7
0878:  BSF    FF2.7
087A:  MOVWF  x67
087C:  CLRF   x6F
087E:  MOVWF  x70
0880:  RCALL  07FA
0882:  INCF   x66,F
0884:  BRA    0864
.................... } 
0886:  GOTO   17C6 (RETURN)
....................  
....................  
.................... void lcd_gotoxy( byte x, byte y) { 
....................    byte address; 
....................  
....................    if(y!=1) 
*
090E:  DECFSZ x6C,W
0910:  BRA    0914
0912:  BRA    091A
....................      address=lcd_line_two; 
0914:  MOVLW  40
0916:  MOVWF  x6D
....................    else 
0918:  BRA    091C
....................      address=0; 
091A:  CLRF   x6D
....................    address+=x-1; 
091C:  MOVLW  01
091E:  SUBWF  x6B,W
0920:  ADDWF  x6D,F
....................    lcd_send_byte(0,0x80|address); 
0922:  MOVF   x6D,W
0924:  IORLW  80
0926:  MOVWF  x6E
0928:  CLRF   x6F
092A:  MOVWF  x70
092C:  RCALL  07FA
.................... } 
092E:  RETLW  00
....................  
.................... void lcd_putc( char c) { 
....................    switch (c) { 
0930:  MOVF   x6A,W
0932:  XORLW  0C
0934:  BZ    0940
0936:  XORLW  06
0938:  BZ    0950
093A:  XORLW  02
093C:  BZ    095C
093E:  BRA    0966
....................      case '\f'   : lcd_send_byte(0,1); 
0940:  CLRF   x6F
0942:  MOVLW  01
0944:  MOVWF  x70
0946:  RCALL  07FA
....................                    delay_ms(2); 
0948:  MOVLW  02
094A:  MOVWF  x76
094C:  RCALL  07B4
....................                                            break; 
094E:  BRA    0972
....................      case '\n'   : lcd_gotoxy(1,2);        break; 
0950:  MOVLW  01
0952:  MOVWF  x6B
0954:  MOVLW  02
0956:  MOVWF  x6C
0958:  RCALL  090E
095A:  BRA    0972
....................      case '\b'   : lcd_send_byte(0,0x10);  break; 
095C:  CLRF   x6F
095E:  MOVLW  10
0960:  MOVWF  x70
0962:  RCALL  07FA
0964:  BRA    0972
....................      default     : lcd_send_byte(1,c);     break; 
0966:  MOVLW  01
0968:  MOVWF  x6F
096A:  MOVFF  6A,70
096E:  RCALL  07FA
0970:  BRA    0972
....................    } 
.................... } 
0972:  RETLW  00
....................  
....................  
....................  
....................  
.................... #define MODBUS_SLAVE_ADDRESS 0x80 
....................  
.................... int i; 
....................  
.................... /*This function may come in handy for you since MODBUS uses MSB first.*/ 
.................... int8 swap_bits(int8 c) 
.................... { 
....................    return ((c&1)?128:0)|((c&2)?64:0)|((c&4)?32:0)|((c&8)?16:0)|((c&16)?8:0) 
....................           |((c&32)?4:0)|((c&64)?2:0)|((c&128)?1:0); 
.................... } 
....................  
.................... void print_menu() 
.................... { 
....................    DEBUG_MSG("\r\nPick command to send\r\n1. Read all coils.\r\n"); 
*
0994:  MOVLW  F6
0996:  MOVWF  FF6
0998:  MOVLW  03
099A:  MOVWF  FF7
099C:  RCALL  08CA
....................    DEBUG_MSG("2. Read all inputs.\r\n3. Read all holding registers.\r\n"); 
099E:  MOVLW  24
09A0:  MOVWF  FF6
09A2:  MOVLW  04
09A4:  MOVWF  FF7
09A6:  RCALL  08CA
....................    DEBUG_MSG("4. Read all input registers.\r\n5. Turn coil 6 on.\r\n6. "); 
09A8:  MOVLW  5A
09AA:  MOVWF  FF6
09AC:  MOVLW  04
09AE:  MOVWF  FF7
09B0:  RCALL  08CA
....................    DEBUG_MSG("Write 0x4444 to register 0x03\r\n7. Set 8 coils using 0x50 as mask\r\n"); 
09B2:  MOVLW  90
09B4:  MOVWF  FF6
09B6:  MOVLW  04
09B8:  MOVWF  FF7
09BA:  RCALL  08CA
....................    DEBUG_MSG("8. Set 2 registers to 0x1111, 0x2222\r\n9. Send unknown command\r\n"); 
09BC:  MOVLW  D4
09BE:  MOVWF  FF6
09C0:  MOVLW  04
09C2:  MOVWF  FF7
09C4:  RCALL  08CA
.................... } 
09C6:  GOTO   1834 (RETURN)
....................  
.................... void read_all_coils() 
.................... { 
....................    DEBUG_MSG("Coils:\r\n"); 
*
0BD2:  MOVLW  14
0BD4:  MOVWF  FF6
0BD6:  MOVLW  05
0BD8:  MOVWF  FF7
0BDA:  RCALL  08CA
....................    if(!(modbus_read_coils(MODBUS_SLAVE_ADDRESS,0,8))) 
0BDC:  MOVLW  80
0BDE:  MOVWF  x67
0BE0:  CLRF   x69
0BE2:  CLRF   x68
0BE4:  CLRF   x6B
0BE6:  MOVLW  08
0BE8:  MOVWF  x6A
0BEA:  BRA    0AEC
0BEC:  MOVF   01,F
0BEE:  BNZ   0C36
....................    { 
....................       DEBUG_MSG("Data: "); 
0BF0:  MOVLW  1E
0BF2:  MOVWF  FF6
0BF4:  MOVLW  05
0BF6:  MOVWF  FF7
0BF8:  RCALL  08CA
....................       /*Started at 1 since 0 is quantity of coils*/ 
....................       for(i=1; i < (modbus_rx.len); ++i) 
0BFA:  MOVLW  01
0BFC:  MOVWF  x64
0BFE:  MOVF   21,W
0C00:  SUBWF  x64,W
0C02:  BC    0C2A
....................          DEBUG_DATA("%X ", modbus_rx.data[i]); 
0C04:  CLRF   03
0C06:  MOVF   x64,W
0C08:  ADDLW  24
0C0A:  MOVWF  FE9
0C0C:  MOVLW  00
0C0E:  ADDWFC 03,W
0C10:  MOVWF  FEA
0C12:  MOVFF  FEF,67
0C16:  MOVFF  67,6C
0C1A:  MOVLW  37
0C1C:  MOVWF  x6D
0C1E:  RCALL  0B76
0C20:  MOVLW  20
0C22:  MOVWF  x6E
0C24:  RCALL  088A
0C26:  INCF   x64,F
0C28:  BRA    0BFE
....................       DEBUG_MSG("\r\n\r\n"); 
0C2A:  MOVLW  26
0C2C:  MOVWF  FF6
0C2E:  MOVLW  05
0C30:  MOVWF  FF7
0C32:  RCALL  08CA
....................    } 
....................    else 
0C34:  BRA    0C5C
....................    { 
....................       DEBUG_DATA("<-**Exception %X**->\r\n\r\n", modbus_rx.error); 
0C36:  MOVLW  2C
0C38:  MOVWF  FF6
0C3A:  MOVLW  05
0C3C:  MOVWF  FF7
0C3E:  MOVLW  0E
0C40:  MOVWF  x6B
0C42:  RCALL  0BB4
0C44:  MOVFF  23,6C
0C48:  MOVLW  37
0C4A:  MOVWF  x6D
0C4C:  RCALL  0B76
0C4E:  MOVLW  3C
0C50:  MOVWF  FF6
0C52:  MOVLW  05
0C54:  MOVWF  FF7
0C56:  MOVLW  08
0C58:  MOVWF  x6B
0C5A:  RCALL  0BB4
....................    } 
.................... } 
0C5C:  GOTO   103E (RETURN)
....................  
.................... void read_all_inputs() 
.................... { 
....................    DEBUG_MSG("Inputs:\r\n"); 
*
0CEA:  MOVLW  46
0CEC:  MOVWF  FF6
0CEE:  MOVLW  05
0CF0:  MOVWF  FF7
0CF2:  RCALL  08CA
....................    if(!(modbus_read_discrete_input(MODBUS_SLAVE_ADDRESS,0,8))) 
0CF4:  MOVLW  80
0CF6:  MOVWF  x67
0CF8:  CLRF   x69
0CFA:  CLRF   x68
0CFC:  CLRF   x6B
0CFE:  MOVLW  08
0D00:  MOVWF  x6A
0D02:  BRA    0C60
0D04:  MOVF   01,F
0D06:  BNZ   0D4E
....................    { 
....................       DEBUG_MSG("Data: "); 
0D08:  MOVLW  50
0D0A:  MOVWF  FF6
0D0C:  MOVLW  05
0D0E:  MOVWF  FF7
0D10:  RCALL  08CA
....................       /*Started at 1 since 0 is quantity of coils*/ 
....................       for(i=1; i < (modbus_rx.len); ++i) 
0D12:  MOVLW  01
0D14:  MOVWF  x64
0D16:  MOVF   21,W
0D18:  SUBWF  x64,W
0D1A:  BC    0D42
....................          DEBUG_DATA("%X ", modbus_rx.data[i]); 
0D1C:  CLRF   03
0D1E:  MOVF   x64,W
0D20:  ADDLW  24
0D22:  MOVWF  FE9
0D24:  MOVLW  00
0D26:  ADDWFC 03,W
0D28:  MOVWF  FEA
0D2A:  MOVFF  FEF,67
0D2E:  MOVFF  67,6C
0D32:  MOVLW  37
0D34:  MOVWF  x6D
0D36:  RCALL  0B76
0D38:  MOVLW  20
0D3A:  MOVWF  x6E
0D3C:  RCALL  088A
0D3E:  INCF   x64,F
0D40:  BRA    0D16
....................       DEBUG_MSG("\r\n\r\n"); 
0D42:  MOVLW  58
0D44:  MOVWF  FF6
0D46:  MOVLW  05
0D48:  MOVWF  FF7
0D4A:  RCALL  08CA
....................    } 
....................    else 
0D4C:  BRA    0D74
....................    { 
....................       DEBUG_DATA("<-**Exception %X**->\r\n\r\n", modbus_rx.error); 
0D4E:  MOVLW  5E
0D50:  MOVWF  FF6
0D52:  MOVLW  05
0D54:  MOVWF  FF7
0D56:  MOVLW  0E
0D58:  MOVWF  x6B
0D5A:  RCALL  0BB4
0D5C:  MOVFF  23,6C
0D60:  MOVLW  37
0D62:  MOVWF  x6D
0D64:  RCALL  0B76
0D66:  MOVLW  6E
0D68:  MOVWF  FF6
0D6A:  MOVLW  05
0D6C:  MOVWF  FF7
0D6E:  MOVLW  08
0D70:  MOVWF  x6B
0D72:  RCALL  0BB4
....................    } 
.................... } 
0D74:  GOTO   103E (RETURN)
....................  
.................... void read_all_holding() 
.................... { 
....................    DEBUG_MSG("Holding Registers:\r\n"); 
*
0E02:  MOVLW  78
0E04:  MOVWF  FF6
0E06:  MOVLW  05
0E08:  MOVWF  FF7
0E0A:  RCALL  08CA
....................    if(!(modbus_read_holding_registers(MODBUS_SLAVE_ADDRESS,0,8))) 
0E0C:  MOVLW  80
0E0E:  MOVWF  x67
0E10:  CLRF   x69
0E12:  CLRF   x68
0E14:  CLRF   x6B
0E16:  MOVLW  08
0E18:  MOVWF  x6A
0E1A:  BRA    0D78
0E1C:  MOVF   01,F
0E1E:  BNZ   0E66
....................    { 
....................       DEBUG_MSG("Data: "); 
0E20:  MOVLW  8E
0E22:  MOVWF  FF6
0E24:  MOVLW  05
0E26:  MOVWF  FF7
0E28:  RCALL  08CA
....................       /*Started at 1 since 0 is quantity of coils*/ 
....................       for(i=1; i < (modbus_rx.len); ++i) 
0E2A:  MOVLW  01
0E2C:  MOVWF  x64
0E2E:  MOVF   21,W
0E30:  SUBWF  x64,W
0E32:  BC    0E5A
....................          DEBUG_DATA("%X ", modbus_rx.data[i]); 
0E34:  CLRF   03
0E36:  MOVF   x64,W
0E38:  ADDLW  24
0E3A:  MOVWF  FE9
0E3C:  MOVLW  00
0E3E:  ADDWFC 03,W
0E40:  MOVWF  FEA
0E42:  MOVFF  FEF,67
0E46:  MOVFF  67,6C
0E4A:  MOVLW  37
0E4C:  MOVWF  x6D
0E4E:  RCALL  0B76
0E50:  MOVLW  20
0E52:  MOVWF  x6E
0E54:  RCALL  088A
0E56:  INCF   x64,F
0E58:  BRA    0E2E
....................       DEBUG_MSG("\r\n\r\n"); 
0E5A:  MOVLW  96
0E5C:  MOVWF  FF6
0E5E:  MOVLW  05
0E60:  MOVWF  FF7
0E62:  RCALL  08CA
....................    }  
....................    else 
0E64:  BRA    0E8C
....................    { 
....................       DEBUG_DATA("<-**Exception %X**->\r\n\r\n", modbus_rx.error); 
0E66:  MOVLW  9C
0E68:  MOVWF  FF6
0E6A:  MOVLW  05
0E6C:  MOVWF  FF7
0E6E:  MOVLW  0E
0E70:  MOVWF  x6B
0E72:  RCALL  0BB4
0E74:  MOVFF  23,6C
0E78:  MOVLW  37
0E7A:  MOVWF  x6D
0E7C:  RCALL  0B76
0E7E:  MOVLW  AC
0E80:  MOVWF  FF6
0E82:  MOVLW  05
0E84:  MOVWF  FF7
0E86:  MOVLW  08
0E88:  MOVWF  x6B
0E8A:  RCALL  0BB4
....................    } 
.................... } 
0E8C:  GOTO   103E (RETURN)
....................  
.................... void read_all_input_reg() 
.................... { 
....................    DEBUG_MSG("Input Registers:\r\n"); 
*
0F5A:  MOVLW  B6
0F5C:  MOVWF  FF6
0F5E:  MOVLW  05
0F60:  MOVWF  FF7
0F62:  RCALL  08CA
....................    if(!(modbus_read_input_registers(MODBUS_SLAVE_ADDRESS,0,8))) 
0F64:  MOVLW  80
0F66:  MOVWF  x67
0F68:  CLRF   x69
0F6A:  CLRF   x68
0F6C:  CLRF   x6B
0F6E:  MOVLW  08
0F70:  MOVWF  x6A
0F72:  BRA    0E90
0F74:  MOVF   01,F
0F76:  BNZ   0FF6
....................    { 
....................       DEBUG_MSG("Data: "); 
0F78:  MOVLW  CA
0F7A:  MOVWF  FF6
0F7C:  MOVLW  05
0F7E:  MOVWF  FF7
0F80:  RCALL  08CA
....................       /*Started at 1 since 0 is quantity of coils*/ 
....................          lcd_gotoxy(1,1);    
0F82:  MOVLW  01
0F84:  MOVWF  x6B
0F86:  MOVWF  x6C
0F88:  RCALL  090E
....................          printf(lcd_putc,"data array:             "); 
0F8A:  MOVLW  D2
0F8C:  MOVWF  FF6
0F8E:  MOVLW  05
0F90:  MOVWF  FF7
0F92:  RCALL  0974
....................          lcd_gotoxy(1,2); 
0F94:  MOVLW  01
0F96:  MOVWF  x6B
0F98:  MOVLW  02
0F9A:  MOVWF  x6C
0F9C:  RCALL  090E
....................       for(i=1; i < (modbus_rx.len); ++i){ 
0F9E:  MOVLW  01
0FA0:  MOVWF  x64
0FA2:  MOVF   21,W
0FA4:  SUBWF  x64,W
0FA6:  BC    0FEA
....................          DEBUG_DATA("%X ", modbus_rx.data[i]); 
0FA8:  CLRF   03
0FAA:  MOVF   x64,W
0FAC:  ADDLW  24
0FAE:  MOVWF  FE9
0FB0:  MOVLW  00
0FB2:  ADDWFC 03,W
0FB4:  MOVWF  FEA
0FB6:  MOVFF  FEF,67
0FBA:  MOVFF  67,6C
0FBE:  MOVLW  37
0FC0:  MOVWF  x6D
0FC2:  RCALL  0B76
0FC4:  MOVLW  20
0FC6:  MOVWF  x6E
0FC8:  RCALL  088A
....................        printf(lcd_putc,"%X",modbus_rx.data[i]); 
0FCA:  CLRF   03
0FCC:  MOVF   x64,W
0FCE:  ADDLW  24
0FD0:  MOVWF  FE9
0FD2:  MOVLW  00
0FD4:  ADDWFC 03,W
0FD6:  MOVWF  FEA
0FD8:  MOVFF  FEF,67
0FDC:  MOVFF  67,68
0FE0:  MOVLW  37
0FE2:  MOVWF  x69
0FE4:  BRA    0F1A
....................       }  
0FE6:  INCF   x64,F
0FE8:  BRA    0FA2
....................        DEBUG_MSG("\r\n\r\n"); 
0FEA:  MOVLW  EC
0FEC:  MOVWF  FF6
0FEE:  MOVLW  05
0FF0:  MOVWF  FF7
0FF2:  RCALL  08CA
....................  
....................    } 
....................    else 
0FF4:  BRA    101C
....................    { 
....................       DEBUG_DATA("<-**Exception %X**->\r\n\r\n", modbus_rx.error); 
0FF6:  MOVLW  F2
0FF8:  MOVWF  FF6
0FFA:  MOVLW  05
0FFC:  MOVWF  FF7
0FFE:  MOVLW  0E
1000:  MOVWF  x6B
1002:  RCALL  0BB4
1004:  MOVFF  23,6C
1008:  MOVLW  37
100A:  MOVWF  x6D
100C:  RCALL  0B76
100E:  MOVLW  02
1010:  MOVWF  FF6
1012:  MOVLW  06
1014:  MOVWF  FF7
1016:  MOVLW  08
1018:  MOVWF  x6B
101A:  RCALL  0BB4
....................    } 
.................... } 
101C:  GOTO   103E (RETURN)
....................  
.................... void write_coil() 
.................... { 
....................    DEBUG_MSG("Writing Single Coil:\r\n"); 
*
10F8:  MOVLW  0C
10FA:  MOVWF  FF6
10FC:  MOVLW  06
10FE:  MOVWF  FF7
1100:  CALL   08CA
....................    if(!(modbus_write_single_coil(MODBUS_SLAVE_ADDRESS,6,TRUE))) 
1104:  MOVLW  80
1106:  MOVWF  x67
1108:  CLRF   x69
110A:  MOVLW  06
110C:  MOVWF  x68
110E:  MOVLW  01
1110:  MOVWF  x6A
1112:  BRA    106E
1114:  MOVF   01,F
1116:  BNZ   1162
....................    { 
....................       DEBUG_MSG("Data: "); 
1118:  MOVLW  24
111A:  MOVWF  FF6
111C:  MOVLW  06
111E:  MOVWF  FF7
1120:  CALL   08CA
....................       for(i=0; i < (modbus_rx.len); ++i) 
1124:  CLRF   x64
1126:  MOVF   21,W
1128:  SUBWF  x64,W
112A:  BC    1154
....................          DEBUG_DATA("%X ", modbus_rx.data[i]); 
112C:  CLRF   03
112E:  MOVF   x64,W
1130:  ADDLW  24
1132:  MOVWF  FE9
1134:  MOVLW  00
1136:  ADDWFC 03,W
1138:  MOVWF  FEA
113A:  MOVFF  FEF,67
113E:  MOVFF  67,6C
1142:  MOVLW  37
1144:  MOVWF  x6D
1146:  RCALL  0B76
1148:  MOVLW  20
114A:  MOVWF  x6E
114C:  CALL   088A
1150:  INCF   x64,F
1152:  BRA    1126
....................       DEBUG_MSG("\r\n\r\n"); 
1154:  MOVLW  2C
1156:  MOVWF  FF6
1158:  MOVLW  06
115A:  MOVWF  FF7
115C:  CALL   08CA
....................    } 
....................    else 
1160:  BRA    1188
....................    { 
....................       DEBUG_DATA("<-**Exception %X**->\r\n\r\n", modbus_rx.error); 
1162:  MOVLW  32
1164:  MOVWF  FF6
1166:  MOVLW  06
1168:  MOVWF  FF7
116A:  MOVLW  0E
116C:  MOVWF  x6B
116E:  RCALL  0BB4
1170:  MOVFF  23,6C
1174:  MOVLW  37
1176:  MOVWF  x6D
1178:  RCALL  0B76
117A:  MOVLW  42
117C:  MOVWF  FF6
117E:  MOVLW  06
1180:  MOVWF  FF7
1182:  MOVLW  08
1184:  MOVWF  x6B
1186:  RCALL  0BB4
....................    }    
.................... } 
1188:  GOTO   1758 (RETURN)
....................  
.................... void write_reg() 
.................... { 
....................    DEBUG_MSG("Writing Single Register:\r\n"); 
*
1216:  MOVLW  4C
1218:  MOVWF  FF6
121A:  MOVLW  06
121C:  MOVWF  FF7
121E:  CALL   08CA
....................    if(!(modbus_write_single_register(MODBUS_SLAVE_ADDRESS,3,0x4444))) 
1222:  MOVLW  80
1224:  MOVWF  x67
1226:  CLRF   x69
1228:  MOVLW  03
122A:  MOVWF  x68
122C:  MOVLW  44
122E:  MOVWF  x6B
1230:  MOVWF  x6A
1232:  BRA    118C
1234:  MOVF   01,F
1236:  BNZ   1282
....................    { 
....................       DEBUG_MSG("Data: "); 
1238:  MOVLW  68
123A:  MOVWF  FF6
123C:  MOVLW  06
123E:  MOVWF  FF7
1240:  CALL   08CA
....................       for(i=0; i < (modbus_rx.len); ++i) 
1244:  CLRF   x64
1246:  MOVF   21,W
1248:  SUBWF  x64,W
124A:  BC    1274
....................          DEBUG_DATA("%X ", modbus_rx.data[i]); 
124C:  CLRF   03
124E:  MOVF   x64,W
1250:  ADDLW  24
1252:  MOVWF  FE9
1254:  MOVLW  00
1256:  ADDWFC 03,W
1258:  MOVWF  FEA
125A:  MOVFF  FEF,67
125E:  MOVFF  67,6C
1262:  MOVLW  37
1264:  MOVWF  x6D
1266:  RCALL  0B76
1268:  MOVLW  20
126A:  MOVWF  x6E
126C:  CALL   088A
1270:  INCF   x64,F
1272:  BRA    1246
....................       DEBUG_MSG("\r\n\r\n"); 
1274:  MOVLW  70
1276:  MOVWF  FF6
1278:  MOVLW  06
127A:  MOVWF  FF7
127C:  CALL   08CA
....................    } 
....................    else 
1280:  BRA    12A8
....................    { 
....................       DEBUG_DATA("<-**Exception %X**->\r\n\r\n", modbus_rx.error); 
1282:  MOVLW  76
1284:  MOVWF  FF6
1286:  MOVLW  06
1288:  MOVWF  FF7
128A:  MOVLW  0E
128C:  MOVWF  x6B
128E:  RCALL  0BB4
1290:  MOVFF  23,6C
1294:  MOVLW  37
1296:  MOVWF  x6D
1298:  RCALL  0B76
129A:  MOVLW  86
129C:  MOVWF  FF6
129E:  MOVLW  06
12A0:  MOVWF  FF7
12A2:  MOVLW  08
12A4:  MOVWF  x6B
12A6:  RCALL  0BB4
....................    } 
.................... } 
12A8:  GOTO   1758 (RETURN)
....................  
.................... void write_coils() 
.................... { 
....................    int8 coils[1] = { 0x50 }; 
*
139A:  CLRF   x68
139C:  MOVLW  50
139E:  MOVWF  x67
....................    DEBUG_MSG("Writing Multiple Coils:\r\n"); 
13A0:  MOVLW  90
13A2:  MOVWF  FF6
13A4:  MOVLW  06
13A6:  MOVWF  FF7
13A8:  CALL   08CA
....................    if(!(modbus_write_multiple_coils(MODBUS_SLAVE_ADDRESS,0,8,coils))) 
13AC:  MOVLW  80
13AE:  MOVWF  x68
13B0:  CLRF   x6A
13B2:  CLRF   x69
13B4:  CLRF   x6C
13B6:  MOVLW  08
13B8:  MOVWF  x6B
13BA:  CLRF   x6E
13BC:  MOVLW  67
13BE:  MOVWF  x6D
13C0:  BRA    12AC
13C2:  MOVF   01,F
13C4:  BNZ   1412
....................    { 
....................       DEBUG_MSG("Data: "); 
13C6:  MOVLW  AA
13C8:  MOVWF  FF6
13CA:  MOVLW  06
13CC:  MOVWF  FF7
13CE:  CALL   08CA
....................       for(i=0; i < (modbus_rx.len); ++i) 
13D2:  CLRF   x64
13D4:  MOVF   21,W
13D6:  SUBWF  x64,W
13D8:  BC    1404
....................          DEBUG_DATA("%X ", modbus_rx.data[i]); 
13DA:  CLRF   03
13DC:  MOVF   x64,W
13DE:  ADDLW  24
13E0:  MOVWF  FE9
13E2:  MOVLW  00
13E4:  ADDWFC 03,W
13E6:  MOVWF  FEA
13E8:  MOVFF  FEF,68
13EC:  MOVFF  68,6C
13F0:  MOVLW  37
13F2:  MOVWF  x6D
13F4:  CALL   0B76
13F8:  MOVLW  20
13FA:  MOVWF  x6E
13FC:  CALL   088A
1400:  INCF   x64,F
1402:  BRA    13D4
....................       DEBUG_MSG("\r\n\r\n"); 
1404:  MOVLW  B2
1406:  MOVWF  FF6
1408:  MOVLW  06
140A:  MOVWF  FF7
140C:  CALL   08CA
....................    } 
....................    else 
1410:  BRA    143E
....................    { 
....................       DEBUG_DATA("<-**Exception %X**->\r\n\r\n", modbus_rx.error); 
1412:  MOVLW  B8
1414:  MOVWF  FF6
1416:  MOVLW  06
1418:  MOVWF  FF7
141A:  MOVLW  0E
141C:  MOVWF  x6B
141E:  CALL   0BB4
1422:  MOVFF  23,6C
1426:  MOVLW  37
1428:  MOVWF  x6D
142A:  CALL   0B76
142E:  MOVLW  C8
1430:  MOVWF  FF6
1432:  MOVLW  06
1434:  MOVWF  FF7
1436:  MOVLW  08
1438:  MOVWF  x6B
143A:  CALL   0BB4
....................    }    
.................... } 
143E:  GOTO   1758 (RETURN)
....................  
.................... void write_regs() 
.................... { 
....................    int16 reg_array[2] = {0x1111, 0x2222}; 
*
154A:  MOVLW  11
154C:  MOVWF  x67
154E:  MOVWF  x68
1550:  MOVLW  22
1552:  MOVWF  x69
1554:  MOVWF  x6A
....................    DEBUG_MSG("Writing Multiple Registers:\r\n"); 
1556:  MOVLW  D2
1558:  MOVWF  FF6
155A:  MOVLW  06
155C:  MOVWF  FF7
155E:  CALL   08CA
....................    if(!(modbus_write_multiple_registers(MODBUS_SLAVE_ADDRESS,0,2,reg_array))) 
1562:  MOVLW  80
1564:  MOVWF  x6B
1566:  CLRF   x6D
1568:  CLRF   x6C
156A:  CLRF   x6F
156C:  MOVLW  02
156E:  MOVWF  x6E
1570:  CLRF   x71
1572:  MOVLW  67
1574:  MOVWF  x70
1576:  BRA    1442
1578:  MOVF   01,F
157A:  BNZ   15C8
....................    { 
....................       DEBUG_MSG("Data: "); 
157C:  MOVLW  F0
157E:  MOVWF  FF6
1580:  MOVLW  06
1582:  MOVWF  FF7
1584:  CALL   08CA
....................       for(i=0; i < (modbus_rx.len); ++i) 
1588:  CLRF   x64
158A:  MOVF   21,W
158C:  SUBWF  x64,W
158E:  BC    15BA
....................          DEBUG_DATA("%X ", modbus_rx.data[i]); 
1590:  CLRF   03
1592:  MOVF   x64,W
1594:  ADDLW  24
1596:  MOVWF  FE9
1598:  MOVLW  00
159A:  ADDWFC 03,W
159C:  MOVWF  FEA
159E:  MOVFF  FEF,6B
15A2:  MOVFF  6B,6C
15A6:  MOVLW  37
15A8:  MOVWF  x6D
15AA:  CALL   0B76
15AE:  MOVLW  20
15B0:  MOVWF  x6E
15B2:  CALL   088A
15B6:  INCF   x64,F
15B8:  BRA    158A
....................       DEBUG_MSG("\r\n\r\n"); 
15BA:  MOVLW  F8
15BC:  MOVWF  FF6
15BE:  MOVLW  06
15C0:  MOVWF  FF7
15C2:  CALL   08CA
....................    } 
....................    else 
15C6:  BRA    15F4
....................    { 
....................       DEBUG_DATA("<-**Exception %X**->\r\n\r\n", modbus_rx.error); 
15C8:  MOVLW  FE
15CA:  MOVWF  FF6
15CC:  MOVLW  06
15CE:  MOVWF  FF7
15D0:  MOVLW  0E
15D2:  MOVWF  x6B
15D4:  CALL   0BB4
15D8:  MOVFF  23,6C
15DC:  MOVLW  37
15DE:  MOVWF  x6D
15E0:  CALL   0B76
15E4:  MOVLW  0E
15E6:  MOVWF  FF6
15E8:  MOVLW  07
15EA:  MOVWF  FF7
15EC:  MOVLW  08
15EE:  MOVWF  x6B
15F0:  CALL   0BB4
....................    }    
.................... } 
15F4:  GOTO   1758 (RETURN)
....................  
.................... void unknown_func() 
.................... { 
....................    DEBUG_MSG("Trying unknown function\r\n"); 
*
1690:  MOVLW  18
1692:  MOVWF  FF6
1694:  MOVLW  07
1696:  MOVWF  FF7
1698:  CALL   08CA
....................    DEBUG_MSG("Diagnostic:\r\n"); 
169C:  MOVLW  32
169E:  MOVWF  FF6
16A0:  MOVLW  07
16A2:  MOVWF  FF7
16A4:  CALL   08CA
....................    if(!(modbus_diagnostics(MODBUS_SLAVE_ADDRESS,0,0))) 
16A8:  MOVLW  80
16AA:  MOVWF  x67
16AC:  CLRF   x69
16AE:  CLRF   x68
16B0:  CLRF   x6B
16B2:  CLRF   x6A
16B4:  BRA    15F8
16B6:  MOVF   01,F
16B8:  BNZ   1706
....................    { 
....................       DEBUG_MSG("Data:"); 
16BA:  MOVLW  40
16BC:  MOVWF  FF6
16BE:  MOVLW  07
16C0:  MOVWF  FF7
16C2:  CALL   08CA
....................       for(i=0; i < (modbus_rx.len); ++i) 
16C6:  CLRF   x64
16C8:  MOVF   21,W
16CA:  SUBWF  x64,W
16CC:  BC    16F8
....................          DEBUG_DATA("%X ", modbus_rx.data[i]); 
16CE:  CLRF   03
16D0:  MOVF   x64,W
16D2:  ADDLW  24
16D4:  MOVWF  FE9
16D6:  MOVLW  00
16D8:  ADDWFC 03,W
16DA:  MOVWF  FEA
16DC:  MOVFF  FEF,67
16E0:  MOVFF  67,6C
16E4:  MOVLW  37
16E6:  MOVWF  x6D
16E8:  CALL   0B76
16EC:  MOVLW  20
16EE:  MOVWF  x6E
16F0:  CALL   088A
16F4:  INCF   x64,F
16F6:  BRA    16C8
....................       DEBUG_MSG("\r\n\r\n"); 
16F8:  MOVLW  46
16FA:  MOVWF  FF6
16FC:  MOVLW  07
16FE:  MOVWF  FF7
1700:  CALL   08CA
....................    } 
....................    else 
1704:  BRA    1732
....................    { 
....................       DEBUG_DATA("<-**Exception %X**->\r\n\r\n", modbus_rx.error); 
1706:  MOVLW  4C
1708:  MOVWF  FF6
170A:  MOVLW  07
170C:  MOVWF  FF7
170E:  MOVLW  0E
1710:  MOVWF  x6B
1712:  CALL   0BB4
1716:  MOVFF  23,6C
171A:  MOVLW  37
171C:  MOVWF  x6D
171E:  CALL   0B76
1722:  MOVLW  5C
1724:  MOVWF  FF6
1726:  MOVLW  07
1728:  MOVWF  FF7
172A:  MOVLW  08
172C:  MOVWF  x6B
172E:  CALL   0BB4
....................    } 
.................... } 
1732:  GOTO   1758 (RETURN)
....................  
.................... void parse_read(char c) 
.................... { 
....................    switch(c) 
....................    { 
*
1020:  MOVLW  31
1022:  SUBWF  x66,W
1024:  ADDLW  FC
1026:  BC    103E
1028:  ADDLW  04
102A:  GOTO   1042
....................       case '1': 
....................          read_all_coils(); 
102E:  BRA    0BD2
....................          break;  
1030:  BRA    103E
....................       case '2': 
....................          read_all_inputs(); 
1032:  BRA    0CEA
....................          break;  
1034:  BRA    103E
....................       case '3': 
....................          read_all_holding(); 
1036:  BRA    0E02
....................          break;  
1038:  BRA    103E
....................       case '4': 
....................          read_all_input_reg(); 
103A:  BRA    0F5A
....................          break;  
103C:  BRA    103E
....................    } 
.................... } 
103E:  GOTO   1854 (RETURN)
....................  
.................... void parse_write(char c) 
.................... { 
....................    switch(c) 
....................    { 
*
1736:  MOVLW  35
1738:  SUBWF  x66,W
173A:  ADDLW  FB
173C:  BC    1758
173E:  ADDLW  05
1740:  GOTO   175C
....................       case '5': 
....................          write_coil(); 
1744:  BRA    10F8
....................          break;             
1746:  BRA    1758
....................       case '6': 
....................          write_reg(); 
1748:  BRA    1216
....................          break; 
174A:  BRA    1758
....................       case '7': 
....................          write_coils(); 
174C:  BRA    139A
....................          break;  
174E:  BRA    1758
....................       case '8': 
....................          write_regs(); 
1750:  BRA    154A
....................          break;  
1752:  BRA    1758
....................       case '9': 
....................          unknown_func(); 
1754:  BRA    1690
....................          break; 
1756:  BRA    1758
....................    } 
.................... } 
1758:  GOTO   185A (RETURN)
....................  
.................... void main() 
.................... { 
*
178A:  CLRF   FF8
178C:  BCF    FD0.7
178E:  BSF    07.7
1790:  CLRF   FEA
1792:  CLRF   FE9
1794:  BCF    F93.0
1796:  BSF    F8A.0
1798:  MOVLW  19
179A:  MOVWF  FAF
179C:  MOVLW  A2
179E:  MOVWF  FAC
17A0:  MOVLW  90
17A2:  MOVWF  FAB
17A4:  CLRF   1B
17A6:  CLRF   1A
17A8:  MOVLW  27
17AA:  MOVWF  19
17AC:  MOVLW  10
17AE:  MOVWF  18
17B0:  BCF    1C.0
17B2:  CLRF   1D
17B4:  BSF    FC1.0
17B6:  BSF    FC1.1
17B8:  BSF    FC1.2
17BA:  BCF    FC1.3
17BC:  MOVLW  07
17BE:  MOVWF  FB4
17C0:  CLRF   17
....................    char c; 
....................    lcd_init(); 
17C2:  GOTO   0832
....................       delay_ms(6); 
17C6:  MOVLW  06
17C8:  MOVWF  x76
17CA:  CALL   07B4
....................    setup_adc_ports(NO_ANALOGS); 
17CE:  BSF    FC1.0
17D0:  BSF    FC1.1
17D2:  BSF    FC1.2
17D4:  BCF    FC1.3
....................     
....................    DEBUG_MSG("\r\nInitializing..."); 
17D6:  MOVLW  66
17D8:  MOVWF  FF6
17DA:  MOVLW  07
17DC:  MOVWF  FF7
17DE:  CALL   08CA
....................    modbus_init(); 
17E2:  GOTO   08F6
....................    DEBUG_MSG("...ready\r\n"); 
17E6:  MOVLW  78
17E8:  MOVWF  FF6
17EA:  MOVLW  07
17EC:  MOVWF  FF7
17EE:  CALL   08CA
....................  
....................    lcd_gotoxy(1,1);    
17F2:  MOVLW  01
17F4:  MOVWF  x6B
17F6:  MOVWF  x6C
17F8:  CALL   090E
....................    printf(lcd_putc,"Master                "); 
17FC:  MOVLW  84
17FE:  MOVWF  FF6
1800:  MOVLW  07
1802:  MOVWF  FF7
1804:  CALL   0974
....................    lcd_gotoxy(1,2);    
1808:  MOVLW  01
180A:  MOVWF  x6B
180C:  MOVLW  02
180E:  MOVWF  x6C
1810:  CALL   090E
....................    printf(lcd_putc,"PIC Modbus            "); 
1814:  MOVLW  9C
1816:  MOVWF  FF6
1818:  MOVLW  07
181A:  MOVWF  FF7
181C:  CALL   0974
....................        delay_ms(5000); 
1820:  MOVLW  14
1822:  MOVWF  x66
1824:  MOVLW  FA
1826:  MOVWF  x76
1828:  CALL   07B4
182C:  DECFSZ x66,F
182E:  BRA    1824
....................  
.................... #ifndef USE_WITH_PC 
....................    do{ 
....................       print_menu(); 
1830:  GOTO   0994
....................       c = getc(PC); 
1834:  GOTO   09CA
1838:  MOVFF  01,65
....................        
....................       fprintf(PC,"\r\n"); 
183C:  MOVLW  0D
183E:  MOVWF  x6E
1840:  CALL   088A
1844:  MOVLW  0A
1846:  MOVWF  x6E
1848:  CALL   088A
....................       parse_read(c); 
184C:  MOVFF  65,66
1850:  GOTO   1020
....................       parse_write(c);  //Split between two functions due to segment size issues 
1854:  MOVFF  65,66
1858:  BRA    1736
....................        
....................    } while(TRUE); 
.................... #else 
....................    read_all_coils(); 
....................    read_all_inputs(); 
....................    read_all_holding(); 
....................    read_all_input_reg(); 
....................    write_coils(); 
....................    write_regs(); 
....................    write_coil(); 
....................    write_reg(); 
....................    read_all_coils(); 
....................    read_all_holding(); 
....................    unknown_func(); 
.................... #endif 
....................  
.................... } 
185A:  BRA    1830
185C:  SLEEP 

Configuration Fuses:
   Word  1: 2200   HS NOOSCSEN
   Word  2: 0E0E   BROWNOUT WDT128 NOWDT BORV20 PUT
   Word  3: 0000  
   Word  4: 0081   STVREN NODEBUG NOLVP
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTB NOWRTC
   Word  7: 400F   NOEBTR NOEBTRB
