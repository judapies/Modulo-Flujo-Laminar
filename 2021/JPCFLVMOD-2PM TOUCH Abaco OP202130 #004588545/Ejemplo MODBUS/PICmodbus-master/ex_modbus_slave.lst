CCS PCM C Compiler, Version 4.104, 5967               04-feb.-21 11:13

               Filename: D:\Laboratorio\Modulo Flujo Laminar\2021\JPCFLVMOD-2PM TOUCH Abaco OP202130 #0045884XX\Ejemplo MODBUS\PICmodbus-master\ex_modbus_slave.lst

               ROM used: 2098 words (51%)
                         Largest free fragment is 1187
               RAM used: 135 (53%) at main() level
                         162 (64%) worst case
               Stack:    8 worst case (5 in main + 3 for interrupts)

*
0000:  MOVLW  08
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  25
0008:  MOVF   7F,W
0009:  MOVWF  24
000A:  MOVF   0A,W
000B:  MOVWF  2B
000C:  CLRF   0A
000D:  SWAPF  24,F
000E:  MOVF   04,W
000F:  MOVWF  26
0010:  MOVF   20,W
0011:  MOVWF  27
0012:  MOVF   21,W
0013:  MOVWF  28
0014:  MOVF   22,W
0015:  MOVWF  29
0016:  MOVF   23,W
0017:  MOVWF  2A
0018:  BCF    03.7
0019:  BCF    03.5
001A:  MOVLW  8C
001B:  MOVWF  04
001C:  BTFSS  00.5
001D:  GOTO   020
001E:  BTFSC  0C.5
001F:  GOTO   037
0020:  MOVLW  8C
0021:  MOVWF  04
0022:  BTFSS  00.1
0023:  GOTO   026
0024:  BTFSC  0C.1
0025:  GOTO   039
0026:  MOVF   26,W
0027:  MOVWF  04
0028:  MOVF   27,W
0029:  MOVWF  20
002A:  MOVF   28,W
002B:  MOVWF  21
002C:  MOVF   29,W
002D:  MOVWF  22
002E:  MOVF   2A,W
002F:  MOVWF  23
0030:  MOVF   2B,W
0031:  MOVWF  0A
0032:  SWAPF  25,W
0033:  MOVWF  03
0034:  SWAPF  7F,F
0035:  SWAPF  7F,W
0036:  RETFIE
0037:  BCF    0A.3
0038:  GOTO   28E
0039:  BCF    0A.3
003A:  GOTO   255
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                         ex_modbus_slave.c                       //// 
.................... ////                                                                 //// 
.................... ////    This is a simple test program for a modbus slave device.     //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Notes:                                                          //// 
.................... ////                                                                 //// 
.................... //// Testing Example:                                                //// 
.................... //// To test the slave code you will need a master device loaded     //// 
.................... //// with the ex_modbus_master.c program (Note that you can test it  //// 
.................... //// with PC software as well.  See Communicating with PC Software.) //// 
.................... //// After making the proper connections (refer to wiring diagram)   //// 
.................... //// you should power on the slave device and then power on the      //// 
.................... //// master device.  The master device should begin sending commands //// 
.................... //// out and showing the replies from the slave through the PC       //// 
.................... //// connection.                                                     //// 
.................... ////                                                                 //// 
.................... //// Hardware UART:                                                  //// 
.................... //// If you use a hardware UART, make sure MODBUS_SERIAL_INT_SOURCE  //// 
.................... //// is set to MODBUS_INT_RDA, MODBUS_INT_RDA2, MODBUS_INT_RDA3, or  //// 
.................... //// MODBUS_INT_RDA4 depending on which UART you are using.  Also,   //// 
.................... //// when using a hardware UART you do not need to specify the TX    //// 
.................... //// and RX pins.  The driver figures them out for you.              //// 
.................... ////                                                                 //// 
.................... //// Communicating with PC software:                                 //// 
.................... //// To communicate with a PC, connect the board to your computer    //// 
.................... //// using the serial cable provided with your board.  Then          //// 
.................... //// uncomment the #define USE_WITH_PC 1 line.  In this              //// 
.................... //// configuration the PC is the master and the PIC is the slave.    //// 
.................... ////                                                                 //// 
.................... //// Troubleshooting:                                                //// 
.................... //// If the device seems unresponsive, power cycle the board and     //// 
.................... //// wait 5 seconds.                                                 //// 
.................... ////                                                                 //// 
.................... //// Wiring Diagram:                                                 //// 
.................... //// This is the diagram for the default configuration.  Note that   ////  
.................... //// the external interrupt (INT), PIN B0, is the only pin that can  //// 
.................... //// be used for receiving with software RS232 for PCM and PCH, and  //// 
.................... //// for PCD the exteranl interrupt (INT0), usually PIN F6, is the   //// 
.................... //// only pin that can be used for receiving with software RS232.    //// 
.................... ////                                                                 //// 
.................... ////            PCH and PCM                        PCD               //// 
.................... ////    ----------     ----------       ----------     ----------    //// 
.................... ////    |        |     |        |       |        |     |        |    //// 
.................... ////    | Master |     | Slave  |       | Master |     | Slave  |    //// 
.................... ////    |        |     |        |       |        |     |        |    //// 
.................... ////    |      B1|---->|B0      |       |      D8|---->|F6      |    //// 
.................... ////    |      B0|<----|B1      |       |      F6|<----|D8      |    //// 
.................... ////    ----------     ----------       ----------     ----------    //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2006 Custom Computer Services        //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... //#define USE_WITH_PC 1 
....................  
.................... #include <16F690.h> 
.................... //////// Standard Header file for the PIC16F690 device //////////////// 
.................... #device PIC16F690 
.................... #list 
....................  
.................... #DEVICE  *=16 ADC=10 
.................... #fuses   NOPROTECT,INTRC,NOWDT,PUT,NOBROWNOUT,MCLR 
.................... //#fuses XT,NOWDT 
.................... #use delay(clock=4M) 
....................  
....................  
.................... //#include "lcd.c" 
....................  
.................... #define MODBUS_TYPE MODBUS_TYPE_SLAVE 
.................... #define MODBUS_SERIAL_TYPE MODBUS_RTU     //use MODBUS_ASCII for ASCII mode 
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE 64 
.................... #define MODBUS_SERIAL_BAUD 9600 
....................  
.................... #ifndef USE_WITH_PC 
.................... #define MODBUS_SERIAL_INT_SOURCE MODBUS_INT_RDA   //MODBUS_INT_EXT 
.................... #if defined(__PCD__) 
.................... #define MODBUS_SERIAL_TX_PIN PIN_D8   // Data transmit pin 
.................... #define MODBUS_SERIAL_RX_PIN PIN_F6   // Data receive pin 
.................... //The following should be defined for RS485 communication 
.................... //#define MODBUS_SERIAL_ENABLE_PIN   0   // Controls DE pin for RS485 
.................... //#define MODBUS_SERIAL_RX_ENABLE    0   // Controls RE pin for RS485 
.................... #else 
.................... #define MODBUS_SERIAL_TX_PIN PIN_B7   // Data transmit pin 
.................... #define MODBUS_SERIAL_RX_PIN PIN_B5   // Data receive pin 
.................... //The following should be defined for RS485 communication 
.................... #define MODBUS_SERIAL_ENABLE_PIN   PIN_B4   // Controls DE pin for RS485 
.................... #define MODBUS_SERIAL_RX_ENABLE    0    // Controls RE pin for RS485 
.................... #endif 
.................... #else 
.................... #define MODBUS_SERIAL_INT_SOURCE MODBUS_INT_RDA 
.................... #endif 
....................  
.................... #include <modbus.c> 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                      modbus.c                                    //// 
.................... ////                                                                                  //// 
.................... ////                 MODBUS protocol driver for serial communications.                //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// DEFINES:                                                                         //// 
.................... ////                                                                                  //// 
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           //// 
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              //// 
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2,   //// 
.................... ////                                   MODBUS_INT_RDA3,MODBUS_INT_RDA4)               //// 
.................... ////  MODBUS_SERIAL_TYPE            MODBUS_RTU or MODBUS_ASCII                        //// 
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        //// 
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      //// 
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     //// 
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           //// 
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       //// 
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        //// 
.................... ////                                                                                  //// 
.................... ////                                                                                  //// 
.................... //// SHARED API:                                                                      //// 
.................... ////                                                                                  //// 
.................... ////  modbus_init()                                                                   //// 
.................... ////    - Initialize modbus serial communication system                               //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_start(address,func)                                          //// 
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data //// 
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_stop()                                                       //// 
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  //// 
.................... ////                                                                                  //// 
.................... ////  modbus_kbhit()                                                                  //// 
.................... ////    - Used to check if a packet has been received.                                //// 
.................... ////                                                                                  //// 
.................... //// MASTER API:                                                                      //// 
.................... ////  All master API functions return 0 on success.                                   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     //// 
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            //// 
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         //// 
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           //// 
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   //// 
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           //// 
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_exception_status(address)                                 //// 
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             //// 
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_counter(address)                                //// 
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_log(address)                                    //// 
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   //// 
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.//// 
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  //// 
.................... ////                    coils.                                                        //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)/// 
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. //// 
.................... ////    - Special Note: values is a pointer to an int8 array                          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_report_slave_id(address)                                       //// 
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  //// 
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 //// 
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)//// 
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,//// 
.................... ////                            write_start,write_quantity, *write_registers_value)   //// 
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          //// 
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////                                                                                  //// 
.................... //// Slave API:                                                                       //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_coils_rsp(address,byte_count,*coil_data)                       //// 
.................... ////    - Wrapper to respond to 0x01(read coils) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_discrete_input_rsp(address,byte_count,*input_data)             //// 
.................... ////    - Wrapper to respond to 0x02(read discret input) in the MODBUS specification. //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_holding_registers_rsp(address,byte_count,*reg_data)            //// 
.................... ////    - Wrapper to respond to 0x03(read holding regs) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_input_registers_rsp(address,byte_count,*input_data)            //// 
.................... ////    - Wrapper to respond to 0x04(read input regs) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_single_coil_rsp(address,output_address,output_value)          //// 
.................... ////    - Wrapper to respond to 0x05(write single coil) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_single_register_rsp(address,reg_address,reg_value)            //// 
.................... ////    - Wrapper to respond to 0x06(write single reg) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_exception_status_rsp(address, data)                            //// 
.................... ////    - Wrapper to respond to 0x07(read void status) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_diagnostics_rsp(address,sub_func,data)                              //// 
.................... ////    - Wrapper to respond to 0x08(diagnostics) in the MODBUS specification.        //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_get_comm_event_counter_rsp(address,status,event_count)              //// 
.................... ////    - Wrapper to respond to 0x0B(get comm event count) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_get_comm_event_log_rsp(address,status,event_count,message_count,    //// 
.................... ////                                   *events, events_len)                           //// 
.................... ////    - Wrapper to respond to 0x0C(get comm event log) in the MODBUS specification. //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_multiple_coils_rsp(address,start_address,quantity)            //// 
.................... ////    - Wrapper to respond to 0x0F(write multiple coils) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_multiple_registers_rsp(address,start_address,quantity)        //// 
.................... ////    - Wrapper to respond to 0x10(write multiple regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_report_slave_id_rsp(address,slave_id,run_status,*data,data_len)     //// 
.................... ////    - Wrapper to respond to 0x11(report slave id) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_file_record_rsp(address,byte_count,*request)                   //// 
.................... ////    - Wrapper to respond to 0x14(read file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_file_record_rsp(address,byte_count,*request)                  //// 
.................... ////    - Wrapper to respond to 0x15(write file record) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_mask_write_register_rsp(address,reference_address,AND_mask,OR_mask) //// 
.................... ////    - Wrapper to respond to 0x16(read coils) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_write_multiple_registers_rsp(address,*data,data_len)           //// 
.................... ////    - Wrapper to respond to 0x17(read write mult regs) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_FIFO_queue_rsp(address,FIFO_len,*data)                         //// 
.................... ////    - Wrapper to respond to 0x18(read FIFO queue) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_exception_rsp(int8 address, int16 func, exception error)            //// 
.................... ////    - Wrapper to send an exception response.  See exception list below.           //// 
.................... ////                                                                                  //// 
.................... //// Exception List:                                                                  //// 
.................... ////  ILLEGAL_FUNCTION, ILLEGAL_DATA_ADDRESS, ILLEGAL_DATA_VALUE,                     //// 
.................... ////  SLAVE_DEVICE_FAILURE, ACKNOWLEDGE, SLAVE_DEVICE_BUSY, MEMORY_PARITY_ERROR,      //// 
.................... ////  GATEWAY_PATH_UNAVAILABLE, GATEWAY_TARGET_NO_RESPONSE                            //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// Revision history:                                                                //// 
.................... ////  May 8, 2009          Made PCD Compatible                                        //// 
.................... ////  August 21, 2009      Added Modbus ASCII protocol                                //// 
.................... ////  September 25, 2009   Fixed Bug in RCV_ON function                               //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2006 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... /*Some defines so we can use identifiers to set things up*/ 
.................... #define MODBUS_TYPE_MASTER 99999 
.................... #define MODBUS_TYPE_SLAVE  88888 
.................... #define MODBUS_INT_RDA     77777 
.................... #define MODBUS_INT_RDA2    66666 
.................... #define MODBUS_INT_RDA3    44444 
.................... #define MODBUS_INT_RDA4    33333 
.................... #define MODBUS_INT_EXT     55555 
.................... #define MODBUS_RTU         1 
.................... #define MODBUS_ASCII       2 
....................  
.................... #ifndef MODBUS_TYPE 
.................... #define MODBUS_TYPE MODBUS_TYPE_MASTER 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_TYPE 
.................... #define MODBUS_SERIAL_TYPE MODBUS_RTU 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_INT_SOURCE 
.................... #define MODBUS_SERIAL_INT_SOURCE MODBUS_INT_RDA    // Select between external interrupt 
.................... #endif                                             // or asynchronous serial interrupt 
....................  
.................... #ifndef MODBUS_SERIAL_BAUD 
.................... #define MODBUS_SERIAL_BAUD 9600 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_RX_PIN 
.................... #define MODBUS_SERIAL_RX_PIN       PIN_C7   // Data receive pin 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_TX_PIN 
.................... #define MODBUS_SERIAL_TX_PIN       PIN_C6   // Data transmit pin 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_ENABLE_PIN 
.................... #define MODBUS_SERIAL_ENABLE_PIN   0   // Controls DE pin.  RX low, TX high. 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_RX_ENABLE 
.................... #define MODBUS_SERIAL_RX_ENABLE    0   // Controls RE pin.  Should keep low. 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_TIMEOUT 
....................    #if (MODBUS_SERIAL_TYPE == MODBUS_ASCII) 
....................       #define MODBUS_SERIAL_TIMEOUT    1000000 
....................    #else 
....................       #define MODBUS_SERIAL_TIMEOUT      10000     //in us 
....................    #endif 
.................... #endif 
....................  
.................... #if( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA ) 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART1, bits=8, stop=1, parity=N, stream=MODBUS_SERIAL, errors) 
*
0271:  BTFSS  0C.5
0272:  GOTO   271
0273:  MOVF   18,W
0274:  MOVWF  2D
0275:  MOVF   1A,W
0276:  MOVWF  21
0277:  BTFSS  2D.1
0278:  GOTO   27B
0279:  BCF    18.4
027A:  BSF    18.4
027B:  RETURN
....................    #define RCV_OFF() {disable_interrupts(INT_RDA);} 
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2 ) 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART2, bits=8, stop=1, parity=N, stream=MODBUS_SERIAL, errors) 
....................    #define RCV_OFF() {disable_interrupts(INT_RDA2);} 
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3 ) 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART3, bits=8, stop=1, parity=N, stream=MODBUS_SERIAL, errors) 
....................    #define RCV_OFF() {disable_interrupts(INT_RDA3);} 
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4 ) 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART4, bits=8, stop=1, parity=N, stream=MODBUS_SERIAL, errors) 
....................    #define RCV_OFF() {disable_interrupts(INT_RDA4);} 
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_EXT ) 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, xmit=MODBUS_SERIAL_TX_PIN, rcv=MODBUS_SERIAL_RX_PIN, bits=8, stop=1, parity=N, stream=MODBUS_SERIAL, disable_ints) 
....................    #if defined(__PCD__) 
....................    #define RCV_OFF() {disable_interrupts(INT_EXT0);} 
....................    #else 
....................    #define RCV_OFF() {disable_interrupts(INT_EXT);} 
....................    #endif 
.................... #else 
....................    #error Please define a correct interrupt source 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_RX_BUFFER_SIZE 
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE  64      //size of send/rcv buffer 
.................... #endif 
....................  
.................... #if (MODBUS_TYPE == MODBUS_TYPE_MASTER) 
.................... int32 modbus_serial_wait=MODBUS_SERIAL_TIMEOUT; 
....................  
.................... #define MODBUS_SERIAL_WAIT_FOR_RESPONSE()\ 
.................... {\ 
....................     if(address)\ 
....................     {\ 
....................         while(!modbus_kbhit() && --modbus_serial_wait)\ 
....................             delay_us(1);\ 
....................         if(!modbus_serial_wait)\ 
....................             modbus_rx.error=TIMEOUT;\ 
....................     }\ 
....................     modbus_serial_wait = MODBUS_SERIAL_TIMEOUT;\ 
.................... } 
.................... #endif 
....................  
.................... #if (MODBUS_SERIAL_INT_SOURCE != MODBUS_INT_EXT) 
....................    #if defined(__PCD__) 
....................       #if (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA) 
....................          #word TXSTA=getenv("SFR:U1STA")  
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2) 
....................          #word TXSTA=getenv("SFR:U2STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3) 
....................          #word TXSTA=getenv("SFR:U3STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4) 
....................          #word TXSTA=getenv("SFR:U4STA") 
....................          #bit TRMT=TXSTA.8 
....................       #endif 
....................    #else 
....................       #byte TXSTA=getenv("sfr:TXSTA") 
....................       #bit TRMT=TXSTA.1 
....................    #endif 
....................  
.................... #define WAIT_FOR_HW_BUFFER()\ 
.................... {\ 
....................    while(!TRMT);\ 
.................... }    
.................... #endif 
....................  
.................... int1 modbus_serial_new=0; 
....................  
.................... /******************************************************************** 
.................... These exceptions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to communicate problems with the transmission back 
.................... to the master who can also use these to easily check the exceptions.   
.................... The first exception is the only one that is not part of the protocol  
.................... specification.  The TIMEOUT exception is returned when no slave  
.................... responds to the master's request within the timeout period. 
.................... ********************************************************************/ 
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2,  
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6,  
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11, 
.................... TIMEOUT=12} exception; 
....................  
.................... /******************************************************************** 
.................... These functions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to check the incomming function.  See  
.................... ex_modbus_slave.c for example usage. 
.................... ********************************************************************/ 
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02, 
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04, 
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06, 
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08, 
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C, 
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10, 
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14, 
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16, 
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function; 
....................      
.................... /*Stages of MODBUS reception.  Used to keep our ISR fast enough.*/ 
.................... #if (MODBUS_SERIAL_TYPE==MODBUS_ASCII) 
....................    enum {MODBUS_START=0, MODBUS_GETADDY, MODBUS_GETFUNC, MODBUS_GETDATA, MODBUS_STOP} modbus_serial_state=0; 
.................... #else 
....................    enum {MODBUS_GETADDY=0, MODBUS_GETFUNC=1, MODBUS_GETDATA=2} modbus_serial_state = 0; 
.................... #endif 
....................  
.................... /*Global value holding our current CRC value.*/ 
.................... #if (MODBUS_SERIAL_TYPE==MODBUS_ASCII) 
....................    unsigned int8 modbus_serial_lrc; 
.................... #else 
....................    union 
....................    { 
....................       int8 b[2]; 
....................       int16 d; 
....................    } modbus_serial_crc; 
.................... #endif 
....................  
.................... /******************************************************************** 
.................... Our receive struct.  This is used when receiving data as a master or 
.................... slave.  Once a message is sent to you with your address, you should 
.................... begin processing that message.  Refer to ex_modbus_slave.c to see  
.................... how to properly use this structure. 
.................... ********************************************************************/ 
.................... struct 
.................... { 
....................    int8 address; 
....................    int8 len;                                //number of bytes in the message received 
....................    function func;                           //the function of the message received 
....................    exception error;                         //error recieved, if any 
....................    int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received 
.................... } modbus_rx; 
....................  
.................... /* Table of CRC values for high–order byte */ 
.................... #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
.................... const unsigned char modbus_auchCRCHi[] = { 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40 
.................... }; 
....................  
.................... /* Table of CRC values for low–order byte */ 
.................... const char modbus_auchCRCLo[] = { 
.................... 0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4, 
.................... 0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09, 
.................... 0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD, 
.................... 0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3, 
.................... 0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7, 
.................... 0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A, 
.................... 0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE, 
.................... 0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26, 
.................... 0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2, 
.................... 0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F, 
.................... 0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB, 
.................... 0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5, 
.................... 0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91, 
.................... 0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C, 
.................... 0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88, 
.................... 0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C, 
.................... 0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80, 
.................... 0x40 
.................... }; 
.................... #endif 
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void) 
.................... { 
....................    #if (MODBUS_SERIAL_INT_SOURCE!=MODBUS_INT_EXT) 
....................       while(kbhit(MODBUS_SERIAL)) {fgetc(MODBUS_SERIAL);}  //Clear RX buffer. Clear RDA interrupt flag. Clear overrun error flag. 
*
02CB:  BTFSS  0C.5
02CC:  GOTO   2CF
02CD:  CALL   271
....................       #if (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA) 
02CE:  GOTO   2CB
....................         clear_interrupt(INT_RDA); 
02CF:  BCF    0C.5
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA2) 
....................         clear_interrupt(INT_RDA2); 
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA3) 
....................         clear_interrupt(INT_RDA3); 
....................       #else 
....................         clear_interrupt(INT_RDA4); 
....................       #endif 
....................  
....................       #if (MODBUS_SERIAL_RX_ENABLE!=0)  
....................          output_low(MODBUS_SERIAL_RX_ENABLE); 
....................       #endif 
....................  
....................       #if (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA) 
....................         enable_interrupts(INT_RDA); 
02D0:  BSF    03.5
02D1:  BSF    0C.5
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA2) 
....................         enable_interrupts(INT_RDA2); 
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA3) 
....................         enable_interrupts(INT_RDA3); 
....................       #else 
....................         enable_interrupts(INT_RDA4); 
....................       #endif 
....................    #else 
....................       #if defined(__PCD__) 
....................          clear_interrupt(INT_EXT0); 
....................       #else 
....................          clear_interrupt(INT_EXT); 
....................       #endif 
....................        
....................       ext_int_edge(H_TO_L); 
....................       
....................       #if (MODBUS_SERIAL_RX_ENABLE!=0)  
....................          output_low(MODBUS_SERIAL_RX_ENABLE); 
....................       #endif 
....................  
....................       #if defined(__PCD__) 
....................          enable_interrupts(INT_EXT0); 
....................       #else 
....................          enable_interrupts(INT_EXT); 
....................       #endif 
....................    #endif 
.................... } 
02D2:  BCF    03.5
02D3:  RETURN
....................  
.................... // Purpose:    Initialize RS485 communication. Call this before 
.................... //             using any other RS485 functions. 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void modbus_init() 
.................... { 
....................    output_low(MODBUS_SERIAL_ENABLE_PIN); 
02D4:  BSF    03.5
02D5:  BCF    06.4
02D6:  BCF    03.5
02D7:  BCF    06.4
....................  
....................    RCV_ON(); 
02D8:  CALL   2CB
....................  
....................    #if defined(__PCD__) 
....................       #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
....................          setup_timer2(TMR_INTERNAL | TMR_DIV_BY_8,4999); //~4ms interrupts for 20Mhz clock 
....................       #endif 
....................       enable_interrupts(INTR_GLOBAL); 
....................    #else 
....................       #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
....................          setup_timer_2(T2_DIV_BY_16,249,5);  //~4ms interrupts 
02D9:  MOVLW  20
02DA:  MOVWF  21
02DB:  IORLW  06
02DC:  MOVWF  12
02DD:  MOVLW  F9
02DE:  BSF    03.5
02DF:  MOVWF  12
....................       #endif 
....................       enable_interrupts(GLOBAL); 
02E0:  MOVLW  C0
02E1:  BCF    03.5
02E2:  IORWF  0B,F
....................    #endif 
.................... } 
02E3:  BSF    0A.3
02E4:  GOTO   070 (RETURN)
....................  
.................... // Purpose:    Start our timeout timer 
.................... // Inputs:     Enable, used to turn timer on/off 
.................... // Outputs:    None 
.................... // Not used for ASCII mode 
.................... #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
.................... void modbus_enable_timeout(int1 enable) 
.................... { 
....................    disable_interrupts(INT_TIMER2); 
*
0249:  BSF    03.5
024A:  BCF    0C.1
....................    if (enable) { 
024B:  MOVF   5C,F
024C:  BTFSC  03.2
024D:  GOTO   253
....................       set_timer2(0); 
024E:  BCF    03.5
024F:  CLRF   11
....................       clear_interrupt(INT_TIMER2); 
0250:  BCF    0C.1
....................       enable_interrupts(INT_TIMER2); 
0251:  BSF    03.5
0252:  BSF    0C.1
....................    } 
.................... } 
0253:  BCF    03.5
0254:  RETURN
.................... #endif 
....................  
.................... // Purpose:    Check if we have timed out waiting for a response 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... // Not used for ASCII mode 
.................... #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
....................    #int_timer2 
....................    void modbus_timeout_now(void) 
....................    { 
....................       if((modbus_serial_state == MODBUS_GETDATA) && (modbus_serial_crc.d == 0x0000) && (!modbus_serial_new)) 
0255:  MOVF   2F,W
0256:  SUBLW  02
0257:  BTFSS  03.2
0258:  GOTO   265
0259:  MOVF   30,F
025A:  BTFSS  03.2
025B:  GOTO   265
025C:  MOVF   31,F
025D:  BTFSS  03.2
025E:  GOTO   265
025F:  BTFSC  2E.0
0260:  GOTO   265
....................       { 
....................          modbus_rx.len-=2; 
0261:  MOVLW  02
0262:  SUBWF  33,F
....................          modbus_serial_new=TRUE; 
0263:  BSF    2E.0
....................       } 
....................       else 
0264:  GOTO   266
....................          modbus_serial_new=FALSE; 
0265:  BCF    2E.0
....................     
....................       modbus_serial_crc.d=0xFFFF; 
0266:  MOVLW  FF
0267:  MOVWF  31
0268:  MOVWF  30
....................       modbus_serial_state=MODBUS_GETADDY; 
0269:  CLRF   2F
....................       modbus_enable_timeout(FALSE); 
026A:  BSF    03.5
026B:  CLRF   5C
026C:  BCF    03.5
026D:  CALL   249
....................    } 
.................... #endif 
....................  
.................... // Purpose:    Calculate crc of data and updates global crc 
.................... // Inputs:     Character 
.................... // Outputs:    None 
026E:  BCF    0C.1
026F:  BCF    0A.3
0270:  GOTO   026
.................... void modbus_calc_crc(char data) 
.................... { 
....................    #if (MODBUS_SERIAL_TYPE == MODBUS_ASCII) 
....................       modbus_serial_lrc+=data; 
....................    #else 
....................       unsigned int8 uIndex ; // will index into CRC lookup table 
....................  
....................       uIndex = (modbus_serial_crc.b[1]) ^ data; // calculate the CRC 
*
027C:  MOVF   31,W
027D:  BSF    03.5
027E:  XORWF  60,W
027F:  MOVWF  61
....................       modbus_serial_crc.b[1] = (modbus_serial_crc.b[0]) ^ modbus_auchCRCHi[uIndex]; 
0280:  MOVF   61,W
0281:  BCF    03.5
0282:  CALL   03B
0283:  MOVWF  21
0284:  MOVF   30,W
0285:  XORWF  21,W
0286:  MOVWF  31
....................       modbus_serial_crc.b[0] = modbus_auchCRCLo[uIndex]; 
0287:  BSF    03.5
0288:  MOVF   61,W
0289:  BCF    03.5
028A:  CALL   142
028B:  MOVWF  21
028C:  MOVWF  30
....................    #endif 
.................... } 
028D:  RETURN
....................  
.................... // Purpose:    Puts a character onto the serial line 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_putc(int8 c) 
.................... { 
....................    #if (MODBUS_SERIAL_TYPE==MODBUS_ASCII) 
....................       int8 asciih,asciil; 
....................        
....................       asciih=c>>4; 
....................       if(asciih>9) 
....................          asciih+=0x37; 
....................       else 
....................          asciih+=0x30; 
....................       asciil=c&0xF; 
....................       if(asciil>9) 
....................          asciil+=0x37; 
....................       else 
....................          asciil+=0x30; 
....................       fputc(asciih,MODBUS_SERIAL); 
....................       fputc(asciil,MODBUS_SERIAL); 
....................       modbus_calc_crc(c); 
....................    #else 
....................       fputc(c, MODBUS_SERIAL); 
*
02F6:  BSF    03.5
02F7:  MOVF   58,W
02F8:  BCF    03.5
02F9:  BTFSS  0C.4
02FA:  GOTO   2F9
02FB:  MOVWF  19
02FC:  CLRF   2C
02FD:  BTFSC  0B.7
02FE:  BSF    2C.7
02FF:  BCF    0B.7
....................       modbus_calc_crc(c); 
0300:  BSF    03.5
0301:  MOVF   58,W
0302:  MOVWF  60
0303:  BCF    03.5
0304:  CALL   27C
0305:  BTFSC  2C.7
0306:  BSF    0B.7
....................       delay_us(1000000/MODBUS_SERIAL_BAUD); //one stop bit.  not exact 
0307:  MOVLW  22
0308:  MOVWF  20
0309:  DECFSZ 20,F
030A:  GOTO   309
030B:  NOP
....................    #endif 
.................... } 
030C:  RETURN
....................  
.................... // Purpose:   Interrupt service routine for handling incoming serial data 
.................... // Inputs:    None 
.................... // Outputs:   None 
.................... #if (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA) 
.................... #int_rda 
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA2) 
.................... #int_rda2 
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA3) 
.................... #int_rda3 
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA4) 
.................... #int_rda4 
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_EXT) 
.................... #if defined(__PCD__) 
.................... #int_ext0 
.................... #else 
.................... #int_ext 
.................... #endif 
.................... #else 
.................... #error Please define a correct interrupt source 
.................... #endif 
.................... void incomming_modbus_serial() { 
....................    char c; 
....................    #if (MODBUS_SERIAL_TYPE==MODBUS_ASCII) 
....................       static int1 two_characters=0; 
....................       static int8 datah,datal,data; 
....................    #endif 
....................  
....................    c=fgetc(MODBUS_SERIAL); 
*
028E:  CALL   271
028F:  MOVF   21,W
0290:  BSF    03.5
0291:  MOVWF  5B
....................     
....................    if (!modbus_serial_new) 
0292:  BCF    03.5
0293:  BTFSC  2E.0
0294:  GOTO   2C8
....................    { 
....................       #if (MODBUS_SERIAL_TYPE==MODBUS_ASCII) 
....................          if(modbus_serial_state == MODBUS_START) 
....................          { 
....................             if(c==':') 
....................                modbus_serial_state++; 
....................          } 
....................          else if(modbus_serial_state == MODBUS_GETADDY) 
....................          { 
....................             if(!two_characters) 
....................             { 
....................                if(c>=0x41) 
....................                   datah=((c-0x37)<<4); 
....................                else 
....................                   datah=((c-0x30)<<4); 
....................                modbus_serial_lrc=0; 
....................             } 
....................             else 
....................             { 
....................                if(c>=0x41) 
....................                   datal=c-0x37; 
....................                else 
....................                   datal=c-0x30; 
....................                data=(datah | datal); 
....................                modbus_rx.address=data; 
....................                modbus_calc_crc(data); 
....................                modbus_serial_state++; 
....................             } 
....................             two_characters++; 
....................          } 
....................          else if(modbus_serial_state == MODBUS_GETFUNC) 
....................          { 
....................             if(!two_characters) 
....................             { 
....................                if(c>=0x41) 
....................                   datah=((c-0x37)<<4); 
....................                else 
....................                   datah=((c-0x30)<<4); 
....................             } 
....................             else 
....................             { 
....................                if(c>=0x41) 
....................                   datal=c-0x37; 
....................                else 
....................                   datal=c-0x30; 
....................                data=(datah | datal); 
....................                modbus_rx.func=data; 
....................                modbus_calc_crc(data); 
....................                modbus_serial_state++; 
....................                modbus_rx.len=0; 
....................                modbus_rx.error=0; 
....................             } 
....................             two_characters++; 
....................          } 
....................          else if(modbus_serial_state == MODBUS_GETDATA) 
....................          { 
....................             if(c=='\r') 
....................             { 
....................                modbus_serial_state++; 
....................                modbus_rx.len--; 
....................                modbus_serial_lrc-=data; 
....................             } 
....................             else if(!two_characters) 
....................             { 
....................                if(c>=0x41) 
....................                   datah=((c-0x37)<<4); 
....................                else 
....................                   datah=((c-0x30)<<4); 
....................                two_characters++; 
....................             } 
....................             else 
....................             { 
....................                if(c>=0x41) 
....................                   datal=c-0x37; 
....................                else 
....................                   datal=c-0x30; 
....................                data=(datah | datal); 
....................                if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) 
....................                   modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1; 
....................                modbus_rx.data[modbus_rx.len]=data; 
....................                modbus_rx.len++; 
....................                modbus_calc_crc(data); 
....................                two_characters++; 
....................             } 
....................          } 
....................          else if(modbus_serial_state==MODBUS_STOP) 
....................          { 
....................             if(c=='\n') 
....................             { 
....................                modbus_serial_lrc=((0xFF-modbus_serial_lrc)+1); 
....................                if(modbus_serial_lrc==data) 
....................                   modbus_serial_new=TRUE; 
....................             } 
....................             modbus_serial_state=MODBUS_START; 
....................             two_characters=0; 
....................          } 
....................       #else 
....................              
....................          if(modbus_serial_state == MODBUS_GETADDY) 
0295:  MOVF   2F,F
0296:  BTFSS  03.2
0297:  GOTO   2A3
....................          { 
....................             modbus_serial_crc.d = 0xFFFF; 
0298:  MOVLW  FF
0299:  MOVWF  31
029A:  MOVWF  30
....................             modbus_rx.address = c; 
029B:  BSF    03.5
029C:  MOVF   5B,W
029D:  BCF    03.5
029E:  MOVWF  32
....................             modbus_serial_state++; 
029F:  INCF   2F,F
....................             modbus_rx.len = 0; 
02A0:  CLRF   33
....................             modbus_rx.error=0; 
02A1:  CLRF   35
....................          } 
....................          else if(modbus_serial_state == MODBUS_GETFUNC) 
02A2:  GOTO   2BE
02A3:  DECFSZ 2F,W
02A4:  GOTO   2AB
....................          { 
....................             modbus_rx.func = c; 
02A5:  BSF    03.5
02A6:  MOVF   5B,W
02A7:  BCF    03.5
02A8:  MOVWF  34
....................             modbus_serial_state++; 
02A9:  INCF   2F,F
....................          } 
....................          else if(modbus_serial_state == MODBUS_GETDATA) 
02AA:  GOTO   2BE
02AB:  MOVF   2F,W
02AC:  SUBLW  02
02AD:  BTFSS  03.2
02AE:  GOTO   2BE
....................          { 
....................             if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) {modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1;} 
02AF:  MOVF   33,W
02B0:  SUBLW  3F
02B1:  BTFSC  03.0
02B2:  GOTO   2B5
02B3:  MOVLW  3F
02B4:  MOVWF  33
....................             modbus_rx.data[modbus_rx.len]=c; 
02B5:  MOVLW  36
02B6:  ADDWF  33,W
02B7:  MOVWF  04
02B8:  BCF    03.7
02B9:  BSF    03.5
02BA:  MOVF   5B,W
02BB:  MOVWF  00
....................             modbus_rx.len++; 
02BC:  BCF    03.5
02BD:  INCF   33,F
....................          } 
....................     
....................          modbus_calc_crc(c); 
02BE:  BSF    03.5
02BF:  MOVF   5B,W
02C0:  MOVWF  60
02C1:  BCF    03.5
02C2:  CALL   27C
....................          modbus_enable_timeout(TRUE); 
02C3:  MOVLW  01
02C4:  BSF    03.5
02C5:  MOVWF  5C
02C6:  BCF    03.5
02C7:  CALL   249
....................       #endif 
....................    } 
....................    #if (MODBUS_TYPE == MODBUS_TYPE_MASTER) 
....................       modbus_serial_wait=MODBUS_SERIAL_TIMEOUT; 
....................    #endif 
.................... } 
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... //             4) The length of the data 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
02C8:  BCF    0C.5
02C9:  BCF    0A.3
02CA:  GOTO   026
.................... void modbus_serial_send_start(int8 to, int8 func) 
.................... { 
....................    #if (MODBUS_SERIAL_TYPE==MODBUS_ASCII) 
....................       modbus_serial_lrc=0; 
....................    #else 
....................       modbus_serial_crc.d=0xFFFF; 
*
030D:  MOVLW  FF
030E:  MOVWF  31
030F:  MOVWF  30
....................    #endif 
....................    modbus_serial_new=FALSE; 
0310:  BCF    2E.0
....................  
....................    RCV_OFF(); 
0311:  BSF    03.5
0312:  BCF    0C.5
....................     
.................... #if (MODBUS_SERIAL_ENABLE_PIN!=0)  
....................    output_high(MODBUS_SERIAL_ENABLE_PIN); 
0313:  BCF    06.4
0314:  BCF    03.5
0315:  BSF    06.4
.................... #endif 
....................  
....................    #if (MODBUS_SERIAL_TYPE==MODBUS_RTU) 
....................       delay_us(3500000/MODBUS_SERIAL_BAUD); //3.5 character delay 
0316:  MOVLW  79
0317:  MOVWF  20
0318:  DECFSZ 20,F
0319:  GOTO   318
....................    #else 
....................       fputc(':',MODBUS_SERIAL); 
....................    #endif 
....................  
....................    modbus_serial_putc(to); 
031A:  BSF    03.5
031B:  MOVF   56,W
031C:  MOVWF  58
031D:  BCF    03.5
031E:  CALL   2F6
....................    modbus_serial_putc(func); 
031F:  BSF    03.5
0320:  MOVF   57,W
0321:  MOVWF  58
0322:  BCF    03.5
0323:  CALL   2F6
.................... } 
0324:  RETURN
....................  
.................... void modbus_serial_send_stop() 
.................... { 
....................    #if (MODBUS_SERIAL_TYPE == MODBUS_ASCII) 
....................       int8 i; 
....................        
....................       for(i=0;i<8;i++) 
....................       { 
....................          if(bit_test(modbus_serial_lrc,i)) 
....................             bit_clear(modbus_serial_lrc,i); 
....................          else 
....................             bit_set(modbus_serial_lrc,i); 
....................       } 
....................       modbus_serial_lrc++; 
....................        
....................       modbus_serial_putc(modbus_serial_lrc); 
....................       fputc('\r',MODBUS_SERIAL); 
....................       fputc('\n',MODBUS_SERIAL); 
....................    #else 
....................       int8 crc_low, crc_high; 
....................     
....................       crc_high=modbus_serial_crc.b[1]; 
0325:  MOVF   31,W
0326:  BSF    03.5
0327:  MOVWF  57
....................       crc_low=modbus_serial_crc.b[0]; 
0328:  BCF    03.5
0329:  MOVF   30,W
032A:  BSF    03.5
032B:  MOVWF  56
....................     
....................       modbus_serial_putc(crc_high); 
032C:  MOVF   57,W
032D:  MOVWF  58
032E:  BCF    03.5
032F:  CALL   2F6
....................       modbus_serial_putc(crc_low); 
0330:  BSF    03.5
0331:  MOVF   56,W
0332:  MOVWF  58
0333:  BCF    03.5
0334:  CALL   2F6
....................    #endif 
....................     
.................... #if (MODBUS_SERIAL_INT_SOURCE!=MODBUS_INT_EXT) 
....................    WAIT_FOR_HW_BUFFER(); 
0335:  BSF    03.5
0336:  BTFSS  18.1
0337:  GOTO   336
.................... #endif 
....................     
....................    #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
....................       delay_us(3500000/MODBUS_SERIAL_BAUD); //3.5 character delay 
0338:  MOVLW  79
0339:  BCF    03.5
033A:  MOVWF  20
033B:  DECFSZ 20,F
033C:  GOTO   33B
....................    #endif 
....................  
....................    RCV_ON(); 
033D:  CALL   2CB
....................  
.................... #if (MODBUS_SERIAL_ENABLE_PIN!=0)  
....................    output_low(MODBUS_SERIAL_ENABLE_PIN); 
033E:  BSF    03.5
033F:  BCF    06.4
0340:  BCF    03.5
0341:  BCF    06.4
.................... #endif 
....................  
....................    #if (MODBUS_SERIAL_TYPE == MODBUS_ASCII) 
....................       modbus_serial_lrc=0; 
....................    #else 
....................       modbus_serial_crc.d=0xFFFF; 
0342:  MOVLW  FF
0343:  MOVWF  31
0344:  MOVWF  30
....................    #endif 
.................... } 
0345:  RETURN
....................  
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer 
.................... // Inputs:     None 
.................... // Outputs:    TRUE if a message was received 
.................... //             FALSE if no message is available 
.................... // Note:       Data will be filled in at the modbus_rx struct: 
.................... int1 modbus_kbhit() 
.................... { 
....................    if(!modbus_serial_new) 
*
02E5:  BTFSC  2E.0
02E6:  GOTO   2EB
....................       return FALSE; 
02E7:  MOVLW  00
02E8:  MOVWF  21
02E9:  GOTO   2F4
....................    else if(modbus_rx.func & 0x80)           //did we receive an error? 
02EA:  GOTO   2F1
02EB:  BTFSS  34.7
02EC:  GOTO   2F1
....................    { 
....................       modbus_rx.error = modbus_rx.data[0];  //if so grab the error and return true 
02ED:  MOVF   36,W
02EE:  MOVWF  35
....................       modbus_rx.len = 1; 
02EF:  MOVLW  01
02F0:  MOVWF  33
....................    } 
....................    modbus_serial_new=FALSE; 
02F1:  BCF    2E.0
....................    return TRUE; 
02F2:  MOVLW  01
02F3:  MOVWF  21
.................... } 
02F4:  BSF    0A.3
02F5:  GOTO   0C6 (RETURN)
....................  
.................... #if (MODBUS_TYPE==MODBUS_TYPE_MASTER) 
.................... /*MODBUS Master Functions*/ 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request.  These 
.................... functions take in one of these structs. 
.................... Please refer to the MODBUS protocol specification if you do not 
.................... understand the members of the structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
.................... } modbus_read_sub_request; 
....................  
.................... typedef struct _modbus_write_sub_request 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
....................    int16 data[MODBUS_SERIAL_RX_BUFFER_SIZE-8]; 
.................... } modbus_write_sub_request; 
....................  
....................  
.................... /******************************************************************** 
.................... The following functions are defined in the MODBUS protocol.  Please 
.................... refer to http://www.modbus.org for the purpose of each of these. 
.................... All functions take the slaves address as their first parameter. 
.................... Each function returns the exception code received from the response. 
.................... The function will return 0 if there were no errors in transmission. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_coils(int8 address, int16 start_address, int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................     
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_discrete_input 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_discrete_input(int8 address, int16 start_address, int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................        
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_holding_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_holding_registers(int8 address, int16 start_address, int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................     
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_input_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_input_registers(int8 address, int16 start_address, int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................     
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_single_coil 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Address to write into 
....................            int1       on                 true for on, false for off 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_single_coil(int8 address, int16 output_address, int1 on) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
....................    modbus_serial_putc(make8(output_address,0)); 
....................  
....................    if(on) 
....................        modbus_serial_putc(0xFF); 
....................    else 
....................        modbus_serial_putc(0x00); 
....................     
....................    modbus_serial_putc(0x00); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_single_register 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Address to write into 
....................            int16      reg_value          Value to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_single_register(int8 address, int16 reg_address, int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
....................    modbus_serial_putc(make8(reg_address,0)); 
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
....................    modbus_serial_putc(make8(reg_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................     
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_exception_status 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_exception_status(int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... diagnostics 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Subfunction to send 
....................            int16      data               Data to send, changes based on subfunction 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_diagnostics(int8 address, int16 sub_func, int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... get_comm_event_couter 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_get_comm_event_counter(int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... get_comm_event_log 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_get_comm_event_log(int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start at 
....................            int16      quantity           Amount of coils to write to 
....................            int1*      values             A pointer to an array holding the values to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_multiple_coils(int8 address, int16 start_address, int16 quantity, 
....................                            int8 *values) 
.................... { 
....................    int8 i,count; 
....................     
....................    count = (int8)((quantity/8)); 
....................     
....................    if(quantity%8) 
....................       count++;       
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_putc(count); 
....................  
....................    for(i=0; i < count; ++i)  
....................       modbus_serial_putc(values[i]); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_multiple_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start at 
....................            int16      quantity           Amount of coils to write to 
....................            int16*     values             A pointer to an array holding the data to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_multiple_registers(int8 address, int16 start_address, int16 quantity, 
....................                            int16 *values) 
.................... { 
....................    int8 i,count; 
....................     
....................    count = quantity*2; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................     
....................    modbus_serial_putc(count); 
....................  
....................    for(i=0; i < quantity; ++i) 
....................    { 
....................       modbus_serial_putc(make8(values[i],1)); 
....................       modbus_serial_putc(make8(values[i],0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... report_slave_id 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_report_slave_id(int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_file_record 
.................... Input:     int8                address            Slave Address 
....................            int8                byte_count         Number of bytes to read 
....................            read_sub_request*   request            Structure holding record information 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_file_record(int8 address, int8 byte_count,  
....................                             modbus_read_sub_request *request) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < (byte_count/7); i+=7) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_file_record 
.................... Input:     int8                address            Slave Address 
....................            int8                byte_count         Number of bytes to read 
....................            read_sub_request*   request            Structure holding record/data information 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_file_record(int8 address, int8 byte_count,  
....................                             modbus_write_sub_request *request) 
.................... { 
....................    int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length) &&  
....................             (j < MODBUS_SERIAL_RX_BUFFER_SIZE-8); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... mask_write_register 
.................... Input:     int8       address            Slave Address 
....................            int16      reference_address  Address to mask 
....................            int16      AND_mask           A mask to AND with the data at reference_address 
....................            int16      OR_mask            A mask to OR with the data at reference_address 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_mask_write_register(int8 address, int16 reference_address, 
....................                            int16 AND_mask, int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers 
.................... Input:     int8       address                Slave Address 
....................            int16      read_start             Address to start reading 
....................            int16      read_quantity          Amount of registers to read 
....................            int16      write_start            Address to start writing 
....................            int16      write_quantity         Amount of registers to write 
....................            int16*     write_registers_value  Pointer to an aray us to write 
.................... Output:    exception                         0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_write_multiple_registers(int8 address, int16 read_start, 
....................                                     int16 read_quantity, int16 write_start, 
....................                                     int16 write_quantity, 
....................                                     int16 *write_registers_value) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(read_start,1)); 
....................    modbus_serial_putc(make8(read_start,0)); 
....................  
....................    modbus_serial_putc(make8(read_quantity,1)); 
....................    modbus_serial_putc(make8(read_quantity,0)); 
....................  
....................    modbus_serial_putc(make8(write_start, 1)); 
....................    modbus_serial_putc(make8(write_start, 0)); 
....................  
....................    modbus_serial_putc(make8(write_quantity, 1)); 
....................    modbus_serial_putc(make8(write_quantity, 0)); 
....................  
....................    modbus_serial_putc((int8)(2*write_quantity)); 
....................  
....................    for(i=0; i < write_quantity ; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(write_registers_value[i], 1)); 
....................       modbus_serial_putc(make8(write_registers_value[i+1], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue 
.................... Input:     int8       address           Slave Address 
....................            int16      FIFO_address      FIFO address 
.................... Output:    exception                    0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_FIFO_queue(int8 address, int16 FIFO_address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(FIFO_address, 1)); 
....................    modbus_serial_putc(make8(FIFO_address, 0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... #else 
.................... /*MODBUS Slave Functions*/ 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request_rsp.  These 
.................... functions take in one of these structs.  Please refer to the MODBUS 
.................... protocol specification if you do not understand the members of the 
.................... structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request_rsp 
.................... { 
....................    int8 record_length; 
....................    int8 reference_type; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3]; 
.................... } modbus_read_sub_request_rsp; 
....................  
.................... typedef struct _modbus_write_sub_request_rsp 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8]; 
.................... } modbus_write_sub_request_rsp; 
....................  
....................  
.................... /******************************************************************** 
.................... The following slave functions are defined in the MODBUS protocol. 
.................... Please refer to http://www.modbus.org for the purpose of each of 
.................... these.  All functions take the slaves address as their first 
.................... parameter. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      coil_data          Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_coils_rsp(int8 address, int8 byte_count, int8* coil_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*coil_data); 
....................       coil_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_discrete_input_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_discrete_input_rsp(int8 address, int8 byte_count,  
....................                                     int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
*
0359:  BSF    03.5
035A:  MOVF   4D,W
035B:  MOVWF  56
035C:  MOVLW  02
035D:  MOVWF  57
035E:  BCF    03.5
035F:  CALL   30D
....................  
....................    modbus_serial_putc(byte_count); 
0360:  BSF    03.5
0361:  MOVF   4E,W
0362:  MOVWF  58
0363:  BCF    03.5
0364:  CALL   2F6
....................  
....................    for(i=0; i < byte_count; ++i) 
0365:  BSF    03.5
0366:  CLRF   51
0367:  MOVF   4E,W
0368:  SUBWF  51,W
0369:  BTFSC  03.0
036A:  GOTO   381
....................    { 
....................       modbus_serial_putc(*input_data); 
036B:  MOVF   50,W
036C:  BCF    03.5
036D:  MOVWF  23
036E:  BSF    03.5
036F:  MOVF   4F,W
0370:  MOVWF  04
0371:  BCF    03.7
0372:  BCF    03.5
0373:  BTFSC  23.0
0374:  BSF    03.7
0375:  MOVF   00,W
0376:  BSF    03.5
0377:  MOVWF  52
0378:  MOVWF  58
0379:  BCF    03.5
037A:  CALL   2F6
....................       input_data++; 
037B:  BSF    03.5
037C:  INCF   4F,F
037D:  BTFSC  03.2
037E:  INCF   50,F
....................    } 
037F:  INCF   51,F
0380:  GOTO   367
....................  
....................    modbus_serial_send_stop(); 
0381:  BCF    03.5
0382:  CALL   325
.................... } 
0383:  RETURN
....................  
.................... /* 
.................... read_holding_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      reg_data           Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_holding_registers_rsp(int8 address, int8 byte_count,  
....................                                         int16 *reg_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
0384:  BSF    03.5
0385:  MOVF   50,W
0386:  MOVWF  56
0387:  MOVLW  03
0388:  MOVWF  57
0389:  BCF    03.5
038A:  CALL   30D
....................  
....................    modbus_serial_putc(byte_count); 
038B:  BSF    03.5
038C:  MOVF   51,W
038D:  MOVWF  58
038E:  BCF    03.5
038F:  CALL   2F6
....................  
....................    for(i=0; i < byte_count; i+=2) 
0390:  BSF    03.5
0391:  CLRF   54
0392:  MOVF   51,W
0393:  SUBWF  54,W
0394:  BTFSC  03.0
0395:  GOTO   3CA
....................    { 
....................       modbus_serial_putc(make8(*reg_data,1)); 
0396:  MOVF   53,W
0397:  BCF    03.5
0398:  MOVWF  23
0399:  BSF    03.5
039A:  MOVF   52,W
039B:  MOVWF  04
039C:  BCF    03.7
039D:  BCF    03.5
039E:  BTFSC  23.0
039F:  BSF    03.7
03A0:  INCF   04,F
03A1:  MOVF   00,W
03A2:  BSF    03.5
03A3:  MOVWF  56
03A4:  DECF   04,F
03A5:  MOVF   00,W
03A6:  MOVWF  55
03A7:  MOVF   56,W
03A8:  MOVWF  57
03A9:  MOVWF  58
03AA:  BCF    03.5
03AB:  CALL   2F6
....................       modbus_serial_putc(make8(*reg_data,0)); 
03AC:  BSF    03.5
03AD:  MOVF   53,W
03AE:  BCF    03.5
03AF:  MOVWF  23
03B0:  BSF    03.5
03B1:  MOVF   52,W
03B2:  MOVWF  04
03B3:  BCF    03.7
03B4:  BCF    03.5
03B5:  BTFSC  23.0
03B6:  BSF    03.7
03B7:  INCF   04,F
03B8:  MOVF   00,W
03B9:  BSF    03.5
03BA:  MOVWF  56
03BB:  DECF   04,F
03BC:  MOVF   00,W
03BD:  MOVWF  55
03BE:  MOVWF  57
03BF:  MOVWF  58
03C0:  BCF    03.5
03C1:  CALL   2F6
....................       reg_data++; 
03C2:  MOVLW  02
03C3:  BSF    03.5
03C4:  ADDWF  52,F
03C5:  BTFSC  03.0
03C6:  INCF   53,F
....................    } 
03C7:  MOVLW  02
03C8:  ADDWF  54,F
03C9:  GOTO   392
....................  
....................    modbus_serial_send_stop(); 
03CA:  BCF    03.5
03CB:  CALL   325
.................... } 
03CC:  BSF    0A.3
03CD:  GOTO   1A6 (RETURN)
....................  
.................... /* 
.................... read_input_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_input_registers_rsp(int8 address, int8 byte_count,  
....................                                         int16 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
03CE:  BSF    03.5
03CF:  MOVF   50,W
03D0:  MOVWF  56
03D1:  MOVLW  04
03D2:  MOVWF  57
03D3:  BCF    03.5
03D4:  CALL   30D
....................  
....................    modbus_serial_putc(byte_count); 
03D5:  BSF    03.5
03D6:  MOVF   51,W
03D7:  MOVWF  58
03D8:  BCF    03.5
03D9:  CALL   2F6
....................  
....................    for(i=0; i < byte_count; i+=2) 
03DA:  BSF    03.5
03DB:  CLRF   54
03DC:  MOVF   51,W
03DD:  SUBWF  54,W
03DE:  BTFSC  03.0
03DF:  GOTO   414
....................    { 
....................       modbus_serial_putc(make8(*input_data,1)); 
03E0:  MOVF   53,W
03E1:  BCF    03.5
03E2:  MOVWF  23
03E3:  BSF    03.5
03E4:  MOVF   52,W
03E5:  MOVWF  04
03E6:  BCF    03.7
03E7:  BCF    03.5
03E8:  BTFSC  23.0
03E9:  BSF    03.7
03EA:  INCF   04,F
03EB:  MOVF   00,W
03EC:  BSF    03.5
03ED:  MOVWF  56
03EE:  DECF   04,F
03EF:  MOVF   00,W
03F0:  MOVWF  55
03F1:  MOVF   56,W
03F2:  MOVWF  57
03F3:  MOVWF  58
03F4:  BCF    03.5
03F5:  CALL   2F6
....................       modbus_serial_putc(make8(*input_data,0)); 
03F6:  BSF    03.5
03F7:  MOVF   53,W
03F8:  BCF    03.5
03F9:  MOVWF  23
03FA:  BSF    03.5
03FB:  MOVF   52,W
03FC:  MOVWF  04
03FD:  BCF    03.7
03FE:  BCF    03.5
03FF:  BTFSC  23.0
0400:  BSF    03.7
0401:  INCF   04,F
0402:  MOVF   00,W
0403:  BSF    03.5
0404:  MOVWF  56
0405:  DECF   04,F
0406:  MOVF   00,W
0407:  MOVWF  55
0408:  MOVWF  57
0409:  MOVWF  58
040A:  BCF    03.5
040B:  CALL   2F6
....................       input_data++; 
040C:  MOVLW  02
040D:  BSF    03.5
040E:  ADDWF  52,F
040F:  BTFSC  03.0
0410:  INCF   53,F
....................    } 
0411:  MOVLW  02
0412:  ADDWF  54,F
0413:  GOTO   3DC
....................  
....................    modbus_serial_send_stop(); 
0414:  BCF    03.5
0415:  CALL   325
.................... } 
0416:  BSF    0A.3
0417:  GOTO   1A5 (RETURN)
....................  
.................... /* 
.................... write_single_coil_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Echo of output address received 
....................            int16      output_value       Echo of output value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_coil_rsp(int8 address, int16 output_address,  
....................                                     int16 output_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
0418:  BSF    03.5
0419:  MOVF   4F,W
041A:  MOVWF  56
041B:  MOVLW  05
041C:  MOVWF  57
041D:  BCF    03.5
041E:  CALL   30D
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
041F:  BSF    03.5
0420:  MOVF   51,W
0421:  MOVWF  54
0422:  MOVWF  58
0423:  BCF    03.5
0424:  CALL   2F6
....................    modbus_serial_putc(make8(output_address,0)); 
0425:  BSF    03.5
0426:  MOVF   50,W
0427:  MOVWF  54
0428:  MOVWF  58
0429:  BCF    03.5
042A:  CALL   2F6
....................  
....................    modbus_serial_putc(make8(output_value,1)); 
042B:  BSF    03.5
042C:  MOVF   53,W
042D:  MOVWF  54
042E:  MOVWF  58
042F:  BCF    03.5
0430:  CALL   2F6
....................    modbus_serial_putc(make8(output_value,0)); 
0431:  BSF    03.5
0432:  MOVF   52,W
0433:  MOVWF  54
0434:  MOVWF  58
0435:  BCF    03.5
0436:  CALL   2F6
....................  
....................    modbus_serial_send_stop(); 
0437:  CALL   325
.................... } 
0438:  BSF    0A.3
0439:  GOTO   20A (RETURN)
....................  
.................... /* 
.................... write_single_register_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Echo of register address received 
....................            int16      reg_value          Echo of register value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_register_rsp(int8 address, int16 reg_address,  
....................                                         int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
043A:  BSF    03.5
043B:  MOVF   51,W
043C:  MOVWF  56
043D:  MOVLW  06
043E:  MOVWF  57
043F:  BCF    03.5
0440:  CALL   30D
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
0441:  BSF    03.5
0442:  MOVF   53,W
0443:  MOVWF  56
0444:  MOVWF  58
0445:  BCF    03.5
0446:  CALL   2F6
....................    modbus_serial_putc(make8(reg_address,0)); 
0447:  BSF    03.5
0448:  MOVF   52,W
0449:  MOVWF  56
044A:  MOVWF  58
044B:  BCF    03.5
044C:  CALL   2F6
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
044D:  BSF    03.5
044E:  MOVF   55,W
044F:  MOVWF  56
0450:  MOVWF  58
0451:  BCF    03.5
0452:  CALL   2F6
....................    modbus_serial_putc(make8(reg_value,0)); 
0453:  BSF    03.5
0454:  MOVF   54,W
0455:  MOVWF  56
0456:  MOVWF  58
0457:  BCF    03.5
0458:  CALL   2F6
....................  
....................    modbus_serial_send_stop(); 
0459:  CALL   325
.................... } 
045A:  BSF    0A.3
045B:  GOTO   24C (RETURN)
....................  
.................... /* 
.................... read_exception_status_rsp 
.................... Input:     int8       address            Slave Address 
.................... Output:    void 
.................... */ 
.................... void modbus_read_exception_status_rsp(int8 address, int8 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... diagnostics_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Echo of sub function received 
....................            int16      data               Echo of data received 
.................... Output:    void 
.................... */ 
.................... void modbus_diagnostics_rsp(int8 address, int16 sub_func, int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_counter_rsp(int8 address, int16 status,  
....................                                         int16 event_count) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
....................            int16      message_count      Count of messages 
....................            int8*      events             Pointer to event data 
....................            int8       events_len         Length of event data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_log_rsp(int8 address, int16 status, 
....................                                     int16 event_count, int16 message_count,  
....................                                     int8 *events, int8 events_len) 
.................... { 
....................    int8 i; 
....................      
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................  
....................    modbus_serial_putc(events_len+6); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_putc(make8(message_count, 1)); 
....................    modbus_serial_putc(make8(message_count, 0)); 
....................  
....................    for(i=0; i < events_len; ++i) 
....................    { 
....................       modbus_serial_putc(*events); 
....................       events++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of coils written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_coils_rsp(int8 address, int16 start_address,  
....................                                         int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
*
0491:  BSF    03.5
0492:  MOVF   51,W
0493:  MOVWF  56
0494:  MOVLW  0F
0495:  MOVWF  57
0496:  BCF    03.5
0497:  CALL   30D
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
0498:  BSF    03.5
0499:  MOVF   53,W
049A:  MOVWF  56
049B:  MOVWF  58
049C:  BCF    03.5
049D:  CALL   2F6
....................    modbus_serial_putc(make8(start_address,0)); 
049E:  BSF    03.5
049F:  MOVF   52,W
04A0:  MOVWF  56
04A1:  MOVWF  58
04A2:  BCF    03.5
04A3:  CALL   2F6
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
04A4:  BSF    03.5
04A5:  MOVF   55,W
04A6:  MOVWF  56
04A7:  MOVWF  58
04A8:  BCF    03.5
04A9:  CALL   2F6
....................    modbus_serial_putc(make8(quantity,0)); 
04AA:  BSF    03.5
04AB:  MOVF   54,W
04AC:  MOVWF  56
04AD:  MOVWF  58
04AE:  BCF    03.5
04AF:  CALL   2F6
....................  
....................    modbus_serial_send_stop(); 
04B0:  CALL   325
.................... } 
04B1:  BSF    0A.3
04B2:  GOTO   2D8 (RETURN)
....................  
.................... /* 
.................... write_multiple_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of registers written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_registers_rsp(int8 address, int16 start_address,  
....................                                             int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
04B3:  BSF    03.5
04B4:  MOVF   51,W
04B5:  MOVWF  56
04B6:  MOVLW  10
04B7:  MOVWF  57
04B8:  BCF    03.5
04B9:  CALL   30D
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
04BA:  BSF    03.5
04BB:  MOVF   53,W
04BC:  MOVWF  56
04BD:  MOVWF  58
04BE:  BCF    03.5
04BF:  CALL   2F6
....................    modbus_serial_putc(make8(start_address,0)); 
04C0:  BSF    03.5
04C1:  MOVF   52,W
04C2:  MOVWF  56
04C3:  MOVWF  58
04C4:  BCF    03.5
04C5:  CALL   2F6
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
04C6:  BSF    03.5
04C7:  MOVF   55,W
04C8:  MOVWF  56
04C9:  MOVWF  58
04CA:  BCF    03.5
04CB:  CALL   2F6
....................    modbus_serial_putc(make8(quantity,0)); 
04CC:  BSF    03.5
04CD:  MOVF   54,W
04CE:  MOVWF  56
04CF:  MOVWF  58
04D0:  BCF    03.5
04D1:  CALL   2F6
....................  
....................    modbus_serial_send_stop(); 
04D2:  CALL   325
.................... } 
04D3:  BSF    0A.3
04D4:  GOTO   348 (RETURN)
....................  
.................... /* 
.................... report_slave_id_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       slave_id           Slave Address 
....................            int8       run_status         Are we running? 
....................            int8*      data               Pointer to an array holding the data 
....................            int8       data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_report_slave_id_rsp(int8 address, int8 slave_id, int1 run_status, 
....................                               int8 *data, int8 data_len) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................  
....................    modbus_serial_putc(data_len+2); 
....................    modbus_serial_putc(slave_id); 
....................  
....................    if(run_status) 
....................     modbus_serial_putc(0xFF); 
....................    else 
....................     modbus_serial_putc(0x00); 
....................  
....................    for(i=0; i < data_len; ++i) 
....................    { 
....................       modbus_serial_putc(*data); 
....................       data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Number of bytes to send 
....................            read_sub_request_rsp*    request            Structure holding record/data information 
.................... Output:    void 
.................... */ 
.................... void modbus_read_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_read_sub_request_rsp *request) 
.................... { 
....................    int8 i=0,j; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    while(i < byte_count); 
....................    { 
....................       modbus_serial_putc(request->record_length); 
....................       modbus_serial_putc(request->reference_type); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................  
....................       i += (request->record_length)+1; 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Echo of number of bytes sent 
....................            write_sub_request_rsp*   request            Echo of Structure holding record information 
.................... Output:    void 
.................... */ 
.................... void modbus_write_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_write_sub_request_rsp *request) 
.................... { 
....................    int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... mask_write_register_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       reference_address  Echo of reference address 
....................            int16       AND_mask           Echo of AND mask 
....................            int16       OR_mask            Echo or OR mask 
.................... Output:    void 
.................... */ 
.................... void modbus_mask_write_register_rsp(int8 address, int16 reference_address, 
....................                            int16 AND_mask, int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16*      data               Pointer to an array of data 
....................            int8        data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_read_write_multiple_registers_rsp(int8 address, int8 data_len,  
....................                                                 int16 *data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(data_len*2); 
....................  
....................    for(i=0; i < data_len*2; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       FIFO_len           Length of FIFO in bytes 
....................            int16*      data               Pointer to an array of data 
.................... Output:    void 
.................... */ 
.................... void modbus_read_FIFO_queue_rsp(int8 address, int16 FIFO_len, int16 *data) 
.................... { 
....................    int8 i; 
....................    int16 byte_count; 
....................  
....................    byte_count = ((FIFO_len*2)+2); 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(byte_count, 1)); 
....................    modbus_serial_putc(make8(byte_count, 0)); 
....................  
....................    modbus_serial_putc(make8(FIFO_len, 1)); 
....................    modbus_serial_putc(make8(FIFO_len, 0)); 
....................  
....................    for(i=0; i < FIFO_len; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... void modbus_exception_rsp(int8 address, int16 func, exception error) 
.................... { 
....................    modbus_serial_send_start(address, func|0x80); 
*
0346:  BSF    03.5
0347:  MOVF   4E,W
0348:  IORLW  80
0349:  MOVWF  51
034A:  MOVF   4F,W
034B:  MOVWF  52
034C:  MOVF   4D,W
034D:  MOVWF  56
034E:  MOVF   51,W
034F:  MOVWF  57
0350:  BCF    03.5
0351:  CALL   30D
....................    modbus_serial_putc(error); 
0352:  BSF    03.5
0353:  MOVF   50,W
0354:  MOVWF  58
0355:  BCF    03.5
0356:  CALL   2F6
....................    modbus_serial_send_stop(); 
0357:  CALL   325
.................... } 
0358:  RETURN
....................  
.................... #endif 
....................  
....................  
.................... #define MODBUS_ADDRESS 0x01 
....................  
.................... /*This function may come in handy for you since MODBUS uses MSB first.*/ 
.................... int8 swap_bits(int8 c) 
.................... { 
....................    return ((c&1)?128:0)|((c&2)?64:0)|((c&4)?32:0)|((c&8)?16:0)|((c&16)?8:0) 
....................           |((c&32)?4:0)|((c&64)?2:0)|((c&128)?1:0); 
*
045C:  BSF    03.5
045D:  BTFSS  4D.0
045E:  GOTO   461
045F:  MOVLW  80
0460:  GOTO   462
0461:  MOVLW  00
0462:  MOVWF  4E
0463:  BTFSS  4D.1
0464:  GOTO   467
0465:  MOVLW  40
0466:  GOTO   468
0467:  MOVLW  00
0468:  IORWF  4E,F
0469:  BTFSS  4D.2
046A:  GOTO   46D
046B:  MOVLW  20
046C:  GOTO   46E
046D:  MOVLW  00
046E:  IORWF  4E,F
046F:  BTFSS  4D.3
0470:  GOTO   473
0471:  MOVLW  10
0472:  GOTO   474
0473:  MOVLW  00
0474:  IORWF  4E,F
0475:  BTFSS  4D.4
0476:  GOTO   479
0477:  MOVLW  08
0478:  GOTO   47A
0479:  MOVLW  00
047A:  IORWF  4E,F
047B:  BTFSS  4D.5
047C:  GOTO   47F
047D:  MOVLW  04
047E:  GOTO   480
047F:  MOVLW  00
0480:  IORWF  4E,F
0481:  BTFSS  4D.6
0482:  GOTO   485
0483:  MOVLW  02
0484:  GOTO   486
0485:  MOVLW  00
0486:  IORWF  4E,F
0487:  BTFSS  4D.7
0488:  GOTO   48B
0489:  MOVLW  01
048A:  GOTO   48C
048B:  MOVLW  00
048C:  IORWF  4E,W
048D:  BCF    03.5
048E:  MOVWF  21
.................... } 
048F:  BSF    0A.3
0490:  GOTO   272 (RETURN)
....................  
.................... void main() 
.................... { 
*
0800:  CLRF   04
0801:  BCF    03.7
0802:  MOVLW  1F
0803:  ANDWF  03,F
0804:  MOVLW  61
0805:  BSF    03.5
0806:  MOVWF  0F
0807:  MOVF   0F,W
0808:  BCF    1B.3
0809:  MOVLW  19
080A:  MOVWF  19
080B:  MOVLW  A6
080C:  MOVWF  18
080D:  MOVLW  90
080E:  BCF    03.5
080F:  MOVWF  18
0810:  BCF    2E.0
0811:  CLRF   2F
0812:  BSF    03.6
0813:  BCF    1F.0
0814:  BCF    1F.1
0815:  BCF    1F.2
0816:  BCF    1F.3
0817:  BCF    03.6
0818:  BCF    1F.6
0819:  MOVLW  00
081A:  BSF    03.6
081B:  MOVWF  1E
081C:  CLRF   19
081D:  CLRF   1A
081E:  BSF    03.5
081F:  CLRF   1E
0820:  BCF    03.5
0821:  CLRF   1B
0822:  BCF    03.6
0823:  BCF    0D.5
*
0825:  MOVLW  07
0826:  MOVWF  76
0827:  MOVLW  09
0828:  MOVWF  77
*
0859:  CLRF   79
085A:  CLRF   78
....................    int8 coils = 0b00000111; 
....................    int8 inputs = 0b00001001; 
....................    int16 hold_regs[] = {0x8800,0x7700,0x6600,0x5500,0x4400,0x3300,0x2200,0x1100}; 
*
0829:  BSF    03.5
082A:  CLRF   20
082B:  MOVLW  88
082C:  MOVWF  21
082D:  CLRF   22
082E:  MOVLW  77
082F:  MOVWF  23
0830:  CLRF   24
0831:  MOVLW  66
0832:  MOVWF  25
0833:  CLRF   26
0834:  MOVLW  55
0835:  MOVWF  27
0836:  CLRF   28
0837:  MOVLW  44
0838:  MOVWF  29
0839:  CLRF   2A
083A:  MOVLW  33
083B:  MOVWF  2B
083C:  CLRF   2C
083D:  MOVLW  22
083E:  MOVWF  2D
083F:  CLRF   2E
0840:  MOVLW  11
0841:  MOVWF  2F
....................    int16 input_regs[] = {0x1100,0x2200,0x3300,0x4400,0x5500,0x6600,0x7700,0x8800}; 
0842:  CLRF   30
0843:  MOVWF  31
0844:  CLRF   32
0845:  MOVLW  22
0846:  MOVWF  33
0847:  CLRF   34
0848:  MOVLW  33
0849:  MOVWF  35
084A:  CLRF   36
084B:  MOVLW  44
084C:  MOVWF  37
084D:  CLRF   38
084E:  MOVLW  55
084F:  MOVWF  39
0850:  CLRF   3A
0851:  MOVLW  66
0852:  MOVWF  3B
0853:  CLRF   3C
0854:  MOVLW  77
0855:  MOVWF  3D
0856:  CLRF   3E
0857:  MOVLW  88
0858:  MOVWF  3F
....................    int16 event_count = 0; 
....................  
....................    long int ADC_value0,ADC_value1,ADC_value2; 
....................  
.................... //   lcd_init(); 
.................... //      delay_ms(6);    
....................  
....................       SETUP_ADC_PORTS(sAN2|sAN6|sAN7|sAN8|sAN9); 
*
085B:  BCF    03.5
085C:  BSF    03.6
085D:  BSF    1F.0
085E:  BSF    1F.1
085F:  BCF    1F.2
0860:  BCF    1F.3
0861:  BCF    03.6
0862:  BCF    1F.6
0863:  MOVLW  C4
0864:  BSF    03.6
0865:  MOVWF  1E
.................... //      setup_adc(ADC_CLOCK_INTERNAL); 
.................... //   setup_adc_ports( RA0_RA1_RA3_ANALOG ); 
....................    setup_adc(adc_clock_internal); 
0866:  BSF    03.5
0867:  BCF    03.6
0868:  BSF    1F.4
0869:  BSF    1F.5
086A:  BCF    1F.6
086B:  BCF    03.5
086C:  BSF    1F.7
086D:  BSF    1F.0
....................     
....................    modbus_init(); 
086E:  BCF    0A.3
086F:  GOTO   2D4
0870:  BSF    0A.3
....................  
.................... //   lcd_gotoxy(1,1);    
.................... //   printf(lcd_putc,"Modbus Slave                  "); 
.................... //   lcd_gotoxy(1,2);      
.................... //   printf(lcd_putc,"addr 0x%X CH0-1                 ",MODBUS_ADDRESS); 
.................... //      delay_ms(2000); 
....................  
....................    while(TRUE) 
....................    { 
....................       output_toggle(PIN_A0); 
0871:  BSF    03.5
0872:  BCF    05.0
0873:  MOVLW  01
0874:  BCF    03.5
0875:  XORWF  05,F
....................     set_adc_channel(2); 
0876:  MOVLW  08
0877:  MOVWF  21
0878:  MOVF   1F,W
0879:  ANDLW  C3
087A:  IORWF  21,W
087B:  MOVWF  1F
....................          delay_us(20); 
087C:  MOVLW  06
087D:  MOVWF  20
087E:  DECFSZ 20,F
087F:  GOTO   07E
0880:  NOP
....................      ADC_value0=read_adc(); 
0881:  BSF    1F.1
0882:  BTFSC  1F.1
0883:  GOTO   082
0884:  BSF    03.5
0885:  MOVF   1E,W
0886:  MOVWF  7A
0887:  BCF    03.5
0888:  MOVF   1E,W
0889:  MOVWF  7B
....................      input_regs[0]=ADC_value0; 
088A:  MOVF   7B,W
088B:  BSF    03.5
088C:  MOVWF  31
088D:  MOVF   7A,W
088E:  MOVWF  30
....................  
....................     set_adc_channel(6); 
088F:  MOVLW  18
0890:  BCF    03.5
0891:  MOVWF  21
0892:  MOVF   1F,W
0893:  ANDLW  C3
0894:  IORWF  21,W
0895:  MOVWF  1F
....................          delay_us(20); 
0896:  MOVLW  06
0897:  MOVWF  20
0898:  DECFSZ 20,F
0899:  GOTO   098
089A:  NOP
....................      ADC_value1=read_adc(); 
089B:  BSF    1F.1
089C:  BTFSC  1F.1
089D:  GOTO   09C
089E:  BSF    03.5
089F:  MOVF   1E,W
08A0:  MOVWF  7C
08A1:  BCF    03.5
08A2:  MOVF   1E,W
08A3:  MOVWF  7D
....................      input_regs[1]=ADC_value1; 
08A4:  MOVF   7D,W
08A5:  BSF    03.5
08A6:  MOVWF  33
08A7:  MOVF   7C,W
08A8:  MOVWF  32
....................  
....................     set_adc_channel(7); 
08A9:  MOVLW  1C
08AA:  BCF    03.5
08AB:  MOVWF  21
08AC:  MOVF   1F,W
08AD:  ANDLW  C3
08AE:  IORWF  21,W
08AF:  MOVWF  1F
....................          delay_us(20); 
08B0:  MOVLW  06
08B1:  MOVWF  20
08B2:  DECFSZ 20,F
08B3:  GOTO   0B2
08B4:  NOP
....................      ADC_value2=read_adc(); 
08B5:  BSF    1F.1
08B6:  BTFSC  1F.1
08B7:  GOTO   0B6
08B8:  BSF    03.5
08B9:  MOVF   1E,W
08BA:  MOVWF  40
08BB:  BCF    03.5
08BC:  MOVF   1E,W
08BD:  BSF    03.5
08BE:  MOVWF  41
....................      input_regs[2]=ADC_value2; 
08BF:  MOVF   41,W
08C0:  MOVWF  35
08C1:  MOVF   40,W
08C2:  MOVWF  34
....................  
....................     while(!modbus_kbhit()); 
08C3:  BCF    0A.3
08C4:  BCF    03.5
08C5:  GOTO   2E5
08C6:  BSF    0A.3
08C7:  MOVF   21,F
08C8:  BTFSS  03.2
08C9:  GOTO   0CC
08CA:  BSF    03.5
08CB:  GOTO   0C3
....................       
....................       delay_us(50); 
08CC:  MOVLW  10
08CD:  MOVWF  20
08CE:  DECFSZ 20,F
08CF:  GOTO   0CE
08D0:  NOP
....................        
....................       //check address against our address, 0 is broadcast 
....................       if((modbus_rx.address == MODBUS_ADDRESS) || modbus_rx.address == 0) 
08D1:  DECFSZ 32,W
08D2:  GOTO   0D4
08D3:  GOTO   0D7
08D4:  MOVF   32,F
08D5:  BTFSS  03.2
08D6:  GOTO   35B
....................       { 
....................          switch(modbus_rx.func) 
....................          { 
08D7:  MOVF   34,W
08D8:  XORLW  01
08D9:  BTFSC  03.2
08DA:  GOTO   0F1
08DB:  XORLW  03
08DC:  BTFSC  03.2
08DD:  GOTO   0F1
08DE:  XORLW  01
08DF:  BTFSC  03.2
08E0:  GOTO   151
08E1:  XORLW  07
08E2:  BTFSC  03.2
08E3:  GOTO   151
08E4:  XORLW  01
08E5:  BTFSC  03.2
08E6:  GOTO   1AA
08E7:  XORLW  03
08E8:  BTFSC  03.2
08E9:  GOTO   20F
08EA:  XORLW  09
08EB:  BTFSC  03.2
08EC:  GOTO   24E
08ED:  XORLW  1F
08EE:  BTFSC  03.2
08EF:  GOTO   2DD
08F0:  GOTO   34D
....................             case FUNC_READ_COILS:    //read coils 
....................             case FUNC_READ_DISCRETE_INPUT:    //read inputs 
....................                if(modbus_rx.data[0] || modbus_rx.data[2] || 
....................                   modbus_rx.data[1] >= 8 || modbus_rx.data[3]+modbus_rx.data[1] > 8) 
08F1:  MOVF   36,F
08F2:  BTFSS  03.2
08F3:  GOTO   100
08F4:  MOVF   38,F
08F5:  BTFSS  03.2
08F6:  GOTO   100
08F7:  MOVF   37,W
08F8:  SUBLW  07
08F9:  BTFSS  03.0
08FA:  GOTO   100
08FB:  MOVF   37,W
08FC:  ADDWF  39,W
08FD:  SUBLW  08
08FE:  BTFSC  03.0
08FF:  GOTO   10F
....................                   modbus_exception_rsp(MODBUS_ADDRESS,modbus_rx.func,ILLEGAL_DATA_ADDRESS); 
0900:  MOVLW  01
0901:  BSF    03.5
0902:  MOVWF  4D
0903:  CLRF   4F
0904:  BCF    03.5
0905:  MOVF   34,W
0906:  BSF    03.5
0907:  MOVWF  4E
0908:  MOVLW  02
0909:  MOVWF  50
090A:  BCF    0A.3
090B:  BCF    03.5
090C:  CALL   346
090D:  BSF    0A.3
....................                else 
090E:  GOTO   150
....................                { 
....................                   int8 data; 
....................                    
....................                   if(modbus_rx.func == FUNC_READ_COILS) 
090F:  DECFSZ 34,W
0910:  GOTO   11C
....................                      data = coils>>(modbus_rx.data[1]);      //move to the starting coil 
0911:  MOVF   76,W
0912:  MOVWF  7E
0913:  MOVF   37,W
0914:  MOVWF  21
0915:  BTFSC  03.2
0916:  GOTO   11B
0917:  BCF    03.0
0918:  RRF    7E,F
0919:  DECFSZ 21,F
091A:  GOTO   117
....................                   else 
091B:  GOTO   126
....................                      data = inputs>>(modbus_rx.data[1]);      //move to the starting input 
091C:  MOVF   77,W
091D:  MOVWF  7E
091E:  MOVF   37,W
091F:  MOVWF  21
0920:  BTFSC  03.2
0921:  GOTO   126
0922:  BCF    03.0
0923:  RRF    7E,F
0924:  DECFSZ 21,F
0925:  GOTO   122
....................  
....................                   data = data & (0xFF>>(8-modbus_rx.data[3]));  //0 out values after quantity 
0926:  MOVF   39,W
0927:  SUBLW  08
0928:  MOVWF  21
0929:  MOVLW  FF
092A:  MOVWF  20
092B:  MOVF   21,F
092C:  BTFSC  03.2
092D:  GOTO   132
092E:  BCF    03.0
092F:  RRF    20,F
0930:  DECFSZ 21,F
0931:  GOTO   12E
0932:  MOVF   20,W
0933:  ANDWF  7E,F
....................  
....................                   if(modbus_rx.func == FUNC_READ_COILS) 
0934:  DECFSZ 34,W
0935:  GOTO   142
....................                      modbus_read_discrete_input_rsp(MODBUS_ADDRESS, 0x01, &data); 
0936:  MOVLW  01
0937:  BSF    03.5
0938:  MOVWF  4D
0939:  MOVWF  4E
093A:  CLRF   50
093B:  MOVLW  7E
093C:  MOVWF  4F
093D:  BCF    0A.3
093E:  BCF    03.5
093F:  CALL   359
0940:  BSF    0A.3
....................                   else 
0941:  GOTO   14D
....................                      modbus_read_discrete_input_rsp(MODBUS_ADDRESS, 0x01, &data); 
0942:  MOVLW  01
0943:  BSF    03.5
0944:  MOVWF  4D
0945:  MOVWF  4E
0946:  CLRF   50
0947:  MOVLW  7E
0948:  MOVWF  4F
0949:  BCF    0A.3
094A:  BCF    03.5
094B:  CALL   359
094C:  BSF    0A.3
....................                       
....................                   event_count++; 
094D:  INCF   78,F
094E:  BTFSC  03.2
094F:  INCF   79,F
....................                } 
....................                break; 
0950:  GOTO   35B
....................             case FUNC_READ_HOLDING_REGISTERS: 
....................             case FUNC_READ_INPUT_REGISTERS: 
....................                if(modbus_rx.data[0] || modbus_rx.data[2] || 
....................                   modbus_rx.data[1] >= 8 || modbus_rx.data[3]+modbus_rx.data[1] > 8) 
0951:  MOVF   36,F
0952:  BTFSS  03.2
0953:  GOTO   160
0954:  MOVF   38,F
0955:  BTFSS  03.2
0956:  GOTO   160
0957:  MOVF   37,W
0958:  SUBLW  07
0959:  BTFSS  03.0
095A:  GOTO   160
095B:  MOVF   37,W
095C:  ADDWF  39,W
095D:  SUBLW  08
095E:  BTFSC  03.0
095F:  GOTO   16F
....................                   modbus_exception_rsp(MODBUS_ADDRESS,modbus_rx.func,ILLEGAL_DATA_ADDRESS); 
0960:  MOVLW  01
0961:  BSF    03.5
0962:  MOVWF  4D
0963:  CLRF   4F
0964:  BCF    03.5
0965:  MOVF   34,W
0966:  BSF    03.5
0967:  MOVWF  4E
0968:  MOVLW  02
0969:  MOVWF  50
096A:  BCF    0A.3
096B:  BCF    03.5
096C:  CALL   346
096D:  BSF    0A.3
....................                else 
096E:  GOTO   1A9
....................                { 
....................                   if(modbus_rx.func == FUNC_READ_HOLDING_REGISTERS) 
096F:  MOVF   34,W
0970:  SUBLW  03
0971:  BTFSS  03.2
0972:  GOTO   18D
....................                      modbus_read_holding_registers_rsp(MODBUS_ADDRESS,(modbus_rx.data[3]*2),hold_regs+modbus_rx.data[1]); 
0973:  BCF    03.0
0974:  RLF    39,W
0975:  BSF    03.5
0976:  MOVWF  46
0977:  BCF    03.0
0978:  BCF    03.5
0979:  RLF    37,W
097A:  ADDLW  A0
097B:  BSF    03.5
097C:  MOVWF  47
097D:  CLRF   48
097E:  BTFSC  03.0
097F:  INCF   48,F
0980:  MOVLW  01
0981:  MOVWF  50
0982:  MOVF   46,W
0983:  MOVWF  51
0984:  MOVF   48,W
0985:  MOVWF  53
0986:  MOVF   47,W
0987:  MOVWF  52
0988:  BCF    0A.3
0989:  BCF    03.5
098A:  GOTO   384
098B:  BSF    0A.3
....................                   else 
098C:  GOTO   1A6
....................                      modbus_read_input_registers_rsp(MODBUS_ADDRESS,(modbus_rx.data[3]*2),input_regs+modbus_rx.data[1]); 
098D:  BCF    03.0
098E:  RLF    39,W
098F:  BSF    03.5
0990:  MOVWF  46
0991:  BCF    03.0
0992:  BCF    03.5
0993:  RLF    37,W
0994:  ADDLW  B0
0995:  BSF    03.5
0996:  MOVWF  47
0997:  CLRF   48
0998:  BTFSC  03.0
0999:  INCF   48,F
099A:  MOVLW  01
099B:  MOVWF  50
099C:  MOVF   46,W
099D:  MOVWF  51
099E:  MOVF   48,W
099F:  MOVWF  53
09A0:  MOVF   47,W
09A1:  MOVWF  52
09A2:  BCF    0A.3
09A3:  BCF    03.5
09A4:  GOTO   3CE
09A5:  BSF    0A.3
....................                    
....................                   event_count++; 
09A6:  INCF   78,F
09A7:  BTFSC  03.2
09A8:  INCF   79,F
....................                } 
....................                break; 
09A9:  GOTO   35B
....................             case FUNC_WRITE_SINGLE_COIL:      //write coil 
....................                if(modbus_rx.data[0] || modbus_rx.data[3] || modbus_rx.data[1] > 8) 
09AA:  MOVF   36,F
09AB:  BTFSS  03.2
09AC:  GOTO   1B4
09AD:  MOVF   39,F
09AE:  BTFSS  03.2
09AF:  GOTO   1B4
09B0:  MOVF   37,W
09B1:  SUBLW  08
09B2:  BTFSC  03.0
09B3:  GOTO   1C3
....................                   modbus_exception_rsp(MODBUS_ADDRESS,modbus_rx.func,ILLEGAL_DATA_ADDRESS); 
09B4:  MOVLW  01
09B5:  BSF    03.5
09B6:  MOVWF  4D
09B7:  CLRF   4F
09B8:  BCF    03.5
09B9:  MOVF   34,W
09BA:  BSF    03.5
09BB:  MOVWF  4E
09BC:  MOVLW  02
09BD:  MOVWF  50
09BE:  BCF    0A.3
09BF:  BCF    03.5
09C0:  CALL   346
09C1:  BSF    0A.3
....................                else if(modbus_rx.data[2] != 0xFF && modbus_rx.data[2] != 0x00) 
09C2:  GOTO   20E
09C3:  INCFSZ 38,W
09C4:  GOTO   1C6
09C5:  GOTO   1D8
09C6:  MOVF   38,F
09C7:  BTFSC  03.2
09C8:  GOTO   1D8
....................                   modbus_exception_rsp(MODBUS_ADDRESS,modbus_rx.func,ILLEGAL_DATA_VALUE); 
09C9:  MOVLW  01
09CA:  BSF    03.5
09CB:  MOVWF  4D
09CC:  CLRF   4F
09CD:  BCF    03.5
09CE:  MOVF   34,W
09CF:  BSF    03.5
09D0:  MOVWF  4E
09D1:  MOVLW  03
09D2:  MOVWF  50
09D3:  BCF    0A.3
09D4:  BCF    03.5
09D5:  CALL   346
09D6:  BSF    0A.3
....................                else 
09D7:  GOTO   20E
....................                { 
....................                   //coils are stored msb->lsb so we must use 7-address 
....................                   if(modbus_rx.data[2] == 0xFF) 
09D8:  INCFSZ 38,W
09D9:  GOTO   1E7
....................                      bit_set(coils,modbus_rx.data[1]); 
09DA:  MOVLW  01
09DB:  MOVWF  20
09DC:  MOVF   37,W
09DD:  MOVWF  21
09DE:  BTFSC  03.2
09DF:  GOTO   1E4
09E0:  BCF    03.0
09E1:  RLF    20,F
09E2:  DECFSZ 21,F
09E3:  GOTO   1E0
09E4:  MOVF   20,W
09E5:  IORWF  76,F
....................                   else 
09E6:  GOTO   1F4
....................                      bit_clear(coils,modbus_rx.data[1]); 
09E7:  MOVLW  01
09E8:  MOVWF  20
09E9:  MOVF   37,W
09EA:  MOVWF  21
09EB:  BTFSC  03.2
09EC:  GOTO   1F1
09ED:  BCF    03.0
09EE:  RLF    20,F
09EF:  DECFSZ 21,F
09F0:  GOTO   1ED
09F1:  MOVF   20,W
09F2:  XORLW  FF
09F3:  ANDWF  76,F
....................  
....................                   modbus_write_single_coil_rsp(MODBUS_ADDRESS,modbus_rx.data[1],((int16)(modbus_rx.data[2]))<<8); 
09F4:  BSF    03.5
09F5:  CLRF   47
09F6:  BCF    03.5
09F7:  MOVF   38,W
09F8:  BSF    03.5
09F9:  MOVWF  46
09FA:  MOVWF  47
09FB:  CLRF   46
09FC:  MOVLW  01
09FD:  MOVWF  4F
09FE:  CLRF   51
09FF:  BCF    03.5
0A00:  MOVF   37,W
0A01:  BSF    03.5
0A02:  MOVWF  50
0A03:  MOVF   47,W
0A04:  MOVWF  53
0A05:  MOVF   46,W
0A06:  MOVWF  52
0A07:  BCF    0A.3
0A08:  BCF    03.5
0A09:  GOTO   418
0A0A:  BSF    0A.3
....................                    
....................                   event_count++; 
0A0B:  INCF   78,F
0A0C:  BTFSC  03.2
0A0D:  INCF   79,F
....................                } 
....................                break; 
0A0E:  GOTO   35B
....................             case FUNC_WRITE_SINGLE_REGISTER: 
....................                if(modbus_rx.data[0] || modbus_rx.data[1] >= 8) 
0A0F:  MOVF   36,F
0A10:  BTFSS  03.2
0A11:  GOTO   216
0A12:  MOVF   37,W
0A13:  SUBLW  07
0A14:  BTFSC  03.0
0A15:  GOTO   225
....................                   modbus_exception_rsp(MODBUS_ADDRESS,modbus_rx.func,ILLEGAL_DATA_ADDRESS); 
0A16:  MOVLW  01
0A17:  BSF    03.5
0A18:  MOVWF  4D
0A19:  CLRF   4F
0A1A:  BCF    03.5
0A1B:  MOVF   34,W
0A1C:  BSF    03.5
0A1D:  MOVWF  4E
0A1E:  MOVLW  02
0A1F:  MOVWF  50
0A20:  BCF    0A.3
0A21:  BCF    03.5
0A22:  CALL   346
0A23:  BSF    0A.3
....................                else 
0A24:  GOTO   24D
....................                { 
....................                   //the registers are stored in little endian format 
....................                   hold_regs[modbus_rx.data[1]] = make16(modbus_rx.data[3],modbus_rx.data[2]); 
0A25:  BCF    03.0
0A26:  RLF    37,W
0A27:  ADDLW  A0
0A28:  MOVWF  04
0A29:  BCF    03.7
0A2A:  INCF   04,F
0A2B:  MOVF   39,W
0A2C:  MOVWF  00
0A2D:  DECF   04,F
0A2E:  MOVF   38,W
0A2F:  MOVWF  00
....................  
....................                   modbus_write_single_register_rsp(MODBUS_ADDRESS, 
....................                                make16(modbus_rx.data[0],modbus_rx.data[1]), 
....................                                make16(modbus_rx.data[2],modbus_rx.data[3])); 
0A30:  MOVF   36,W
0A31:  BSF    03.5
0A32:  MOVWF  47
0A33:  BCF    03.5
0A34:  MOVF   37,W
0A35:  BSF    03.5
0A36:  MOVWF  46
0A37:  BCF    03.5
0A38:  MOVF   38,W
0A39:  BSF    03.5
0A3A:  MOVWF  49
0A3B:  BCF    03.5
0A3C:  MOVF   39,W
0A3D:  BSF    03.5
0A3E:  MOVWF  48
0A3F:  MOVLW  01
0A40:  MOVWF  51
0A41:  MOVF   47,W
0A42:  MOVWF  53
0A43:  MOVF   46,W
0A44:  MOVWF  52
0A45:  MOVF   49,W
0A46:  MOVWF  55
0A47:  MOVF   48,W
0A48:  MOVWF  54
0A49:  BCF    0A.3
0A4A:  BCF    03.5
0A4B:  GOTO   43A
0A4C:  BSF    0A.3
....................                } 
....................                break; 
0A4D:  GOTO   35B
....................             case FUNC_WRITE_MULTIPLE_COILS: 
....................                if(modbus_rx.data[0] || modbus_rx.data[2] || 
....................                   modbus_rx.data[1] >= 8 || modbus_rx.data[3]+modbus_rx.data[1] > 8) 
0A4E:  MOVF   36,F
0A4F:  BTFSS  03.2
0A50:  GOTO   25D
0A51:  MOVF   38,F
0A52:  BTFSS  03.2
0A53:  GOTO   25D
0A54:  MOVF   37,W
0A55:  SUBLW  07
0A56:  BTFSS  03.0
0A57:  GOTO   25D
0A58:  MOVF   37,W
0A59:  ADDWF  39,W
0A5A:  SUBLW  08
0A5B:  BTFSC  03.0
0A5C:  GOTO   26C
....................                   modbus_exception_rsp(MODBUS_ADDRESS,modbus_rx.func,ILLEGAL_DATA_ADDRESS); 
0A5D:  MOVLW  01
0A5E:  BSF    03.5
0A5F:  MOVWF  4D
0A60:  CLRF   4F
0A61:  BCF    03.5
0A62:  MOVF   34,W
0A63:  BSF    03.5
0A64:  MOVWF  4E
0A65:  MOVLW  02
0A66:  MOVWF  50
0A67:  BCF    0A.3
0A68:  BCF    03.5
0A69:  CALL   346
0A6A:  BSF    0A.3
....................                else 
0A6B:  GOTO   2DC
....................                { 
....................                   int i,j; 
....................  
....................                   modbus_rx.data[5] = swap_bits(modbus_rx.data[5]); 
0A6C:  MOVF   3B,W
0A6D:  BSF    03.5
0A6E:  MOVWF  4D
0A6F:  BCF    0A.3
0A70:  BCF    03.5
0A71:  GOTO   45C
0A72:  BSF    0A.3
0A73:  MOVF   21,W
0A74:  MOVWF  3B
....................  
....................                   for(i=modbus_rx.data[1],j=0; i < modbus_rx.data[1]+modbus_rx.data[3]; ++i,++j) 
0A75:  MOVF   37,W
0A76:  BSF    03.5
0A77:  MOVWF  42
0A78:  CLRF   43
0A79:  BCF    03.5
0A7A:  MOVF   39,W
0A7B:  ADDWF  37,W
0A7C:  BSF    03.5
0A7D:  SUBWF  42,W
0A7E:  BTFSC  03.0
0A7F:  GOTO   2BB
....................                   {   
....................                      if(bit_test(modbus_rx.data[5],j)) 
0A80:  BCF    03.5
0A81:  MOVF   3B,W
0A82:  MOVWF  20
0A83:  BSF    03.5
0A84:  MOVF   43,W
0A85:  BCF    03.5
0A86:  MOVWF  21
0A87:  BTFSC  03.2
0A88:  GOTO   28D
0A89:  BCF    03.0
0A8A:  RRF    20,F
0A8B:  DECFSZ 21,F
0A8C:  GOTO   289
0A8D:  BTFSS  20.0
0A8E:  GOTO   2A3
....................                         bit_set(coils,7-i); 
0A8F:  BSF    03.5
0A90:  MOVF   42,W
0A91:  SUBLW  07
0A92:  MOVWF  46
0A93:  MOVLW  01
0A94:  BCF    03.5
0A95:  MOVWF  20
0A96:  BSF    03.5
0A97:  MOVF   46,W
0A98:  BCF    03.5
0A99:  MOVWF  21
0A9A:  BTFSC  03.2
0A9B:  GOTO   2A0
0A9C:  BCF    03.0
0A9D:  RLF    20,F
0A9E:  DECFSZ 21,F
0A9F:  GOTO   29C
0AA0:  MOVF   20,W
0AA1:  IORWF  76,F
....................                      else 
0AA2:  GOTO   2B7
....................                         bit_clear(coils,7-i); 
0AA3:  BSF    03.5
0AA4:  MOVF   42,W
0AA5:  SUBLW  07
0AA6:  MOVWF  46
0AA7:  MOVLW  01
0AA8:  BCF    03.5
0AA9:  MOVWF  20
0AAA:  BSF    03.5
0AAB:  MOVF   46,W
0AAC:  BCF    03.5
0AAD:  MOVWF  21
0AAE:  BTFSC  03.2
0AAF:  GOTO   2B4
0AB0:  BCF    03.0
0AB1:  RLF    20,F
0AB2:  DECFSZ 21,F
0AB3:  GOTO   2B0
0AB4:  MOVF   20,W
0AB5:  XORLW  FF
0AB6:  ANDWF  76,F
....................                   } 
0AB7:  BSF    03.5
0AB8:  INCF   42,F
0AB9:  INCF   43,F
0ABA:  GOTO   279
....................  
....................                   modbus_write_multiple_coils_rsp(MODBUS_ADDRESS, 
....................                                  make16(modbus_rx.data[0],modbus_rx.data[1]), 
....................                                  make16(modbus_rx.data[2],modbus_rx.data[3])); 
0ABB:  BCF    03.5
0ABC:  MOVF   36,W
0ABD:  BSF    03.5
0ABE:  MOVWF  47
0ABF:  BCF    03.5
0AC0:  MOVF   37,W
0AC1:  BSF    03.5
0AC2:  MOVWF  46
0AC3:  BCF    03.5
0AC4:  MOVF   38,W
0AC5:  BSF    03.5
0AC6:  MOVWF  49
0AC7:  BCF    03.5
0AC8:  MOVF   39,W
0AC9:  BSF    03.5
0ACA:  MOVWF  48
0ACB:  MOVLW  01
0ACC:  MOVWF  51
0ACD:  MOVF   47,W
0ACE:  MOVWF  53
0ACF:  MOVF   46,W
0AD0:  MOVWF  52
0AD1:  MOVF   49,W
0AD2:  MOVWF  55
0AD3:  MOVF   48,W
0AD4:  MOVWF  54
0AD5:  BCF    0A.3
0AD6:  BCF    03.5
0AD7:  GOTO   491
0AD8:  BSF    0A.3
....................                    
....................                   event_count++; 
0AD9:  INCF   78,F
0ADA:  BTFSC  03.2
0ADB:  INCF   79,F
....................                } 
....................                break; 
0ADC:  GOTO   35B
....................             case FUNC_WRITE_MULTIPLE_REGISTERS: 
....................                if(modbus_rx.data[0] || modbus_rx.data[2] || 
....................                   modbus_rx.data[1] >= 8 || modbus_rx.data[3]+modbus_rx.data[1] > 8) 
0ADD:  MOVF   36,F
0ADE:  BTFSS  03.2
0ADF:  GOTO   2EC
0AE0:  MOVF   38,F
0AE1:  BTFSS  03.2
0AE2:  GOTO   2EC
0AE3:  MOVF   37,W
0AE4:  SUBLW  07
0AE5:  BTFSS  03.0
0AE6:  GOTO   2EC
0AE7:  MOVF   37,W
0AE8:  ADDWF  39,W
0AE9:  SUBLW  08
0AEA:  BTFSC  03.0
0AEB:  GOTO   2FB
....................                   modbus_exception_rsp(MODBUS_ADDRESS,modbus_rx.func,ILLEGAL_DATA_ADDRESS); 
0AEC:  MOVLW  01
0AED:  BSF    03.5
0AEE:  MOVWF  4D
0AEF:  CLRF   4F
0AF0:  BCF    03.5
0AF1:  MOVF   34,W
0AF2:  BSF    03.5
0AF3:  MOVWF  4E
0AF4:  MOVLW  02
0AF5:  MOVWF  50
0AF6:  BCF    0A.3
0AF7:  BCF    03.5
0AF8:  CALL   346
0AF9:  BSF    0A.3
....................                else 
0AFA:  GOTO   34C
....................                { 
....................                   int i,j; 
....................  
....................                   for(i=0,j=5; i < modbus_rx.data[4]/2; ++i,j+=2) 
0AFB:  BSF    03.5
0AFC:  CLRF   44
0AFD:  MOVLW  05
0AFE:  MOVWF  45
0AFF:  BCF    03.0
0B00:  BCF    03.5
0B01:  RRF    3A,W
0B02:  BSF    03.5
0B03:  SUBWF  44,W
0B04:  BTFSC  03.0
0B05:  GOTO   32B
....................                      hold_regs[i] = make16(modbus_rx.data[j+1],modbus_rx.data[j]); 
0B06:  BCF    03.0
0B07:  RLF    44,W
0B08:  BCF    03.5
0B09:  ADDLW  A0
0B0A:  BSF    03.5
0B0B:  MOVWF  46
0B0C:  CLRF   47
0B0D:  BTFSC  03.0
0B0E:  INCF   47,F
0B0F:  MOVLW  01
0B10:  ADDWF  45,W
0B11:  ADDLW  36
0B12:  MOVWF  04
0B13:  BCF    03.7
0B14:  MOVF   00,W
0B15:  MOVWF  48
0B16:  MOVLW  36
0B17:  ADDWF  45,W
0B18:  MOVWF  04
0B19:  BCF    03.7
0B1A:  MOVF   00,W
0B1B:  MOVWF  49
0B1C:  MOVF   46,W
0B1D:  MOVWF  04
0B1E:  BCF    03.7
0B1F:  BTFSC  47.0
0B20:  BSF    03.7
0B21:  INCF   04,F
0B22:  MOVF   48,W
0B23:  MOVWF  00
0B24:  DECF   04,F
0B25:  MOVF   49,W
0B26:  MOVWF  00
0B27:  INCF   44,F
0B28:  MOVLW  02
0B29:  ADDWF  45,F
0B2A:  GOTO   2FF
....................  
....................                   modbus_write_multiple_registers_rsp(MODBUS_ADDRESS, 
....................                                  make16(modbus_rx.data[0],modbus_rx.data[1]), 
....................                                  make16(modbus_rx.data[2],modbus_rx.data[3])); 
0B2B:  BCF    03.5
0B2C:  MOVF   36,W
0B2D:  BSF    03.5
0B2E:  MOVWF  47
0B2F:  BCF    03.5
0B30:  MOVF   37,W
0B31:  BSF    03.5
0B32:  MOVWF  46
0B33:  BCF    03.5
0B34:  MOVF   38,W
0B35:  BSF    03.5
0B36:  MOVWF  49
0B37:  BCF    03.5
0B38:  MOVF   39,W
0B39:  BSF    03.5
0B3A:  MOVWF  48
0B3B:  MOVLW  01
0B3C:  MOVWF  51
0B3D:  MOVF   47,W
0B3E:  MOVWF  53
0B3F:  MOVF   46,W
0B40:  MOVWF  52
0B41:  MOVF   49,W
0B42:  MOVWF  55
0B43:  MOVF   48,W
0B44:  MOVWF  54
0B45:  BCF    0A.3
0B46:  BCF    03.5
0B47:  GOTO   4B3
0B48:  BSF    0A.3
....................                 
....................                   event_count++; 
0B49:  INCF   78,F
0B4A:  BTFSC  03.2
0B4B:  INCF   79,F
....................                } 
....................                break;            
0B4C:  GOTO   35B
....................             default:    //We don't support the function, so return exception 
....................                modbus_exception_rsp(MODBUS_ADDRESS,modbus_rx.func,ILLEGAL_FUNCTION); 
0B4D:  MOVLW  01
0B4E:  BSF    03.5
0B4F:  MOVWF  4D
0B50:  CLRF   4F
0B51:  BCF    03.5
0B52:  MOVF   34,W
0B53:  BSF    03.5
0B54:  MOVWF  4E
0B55:  MOVLW  01
0B56:  MOVWF  50
0B57:  BCF    0A.3
0B58:  BCF    03.5
0B59:  CALL   346
0B5A:  BSF    0A.3
....................          } 
....................       } 
.................... //      lcd_gotoxy(1,1);    
.................... //      printf(lcd_putc,"ADC0: %LX              ",ADC_value0); 
.................... //      lcd_gotoxy(1,2);    
.................... //     printf(lcd_putc,"ADC1: %LX              ",ADC_value1); 
....................   } 
0B5B:  GOTO   071
.................... } 
0B5C:  SLEEP

Configuration Fuses:
   Word  1: 3CE5   INTRC NOPROTECT NOBROWNOUT MCLR NOCPD NOWDT PUT IESO FCMEN
