CCS PCH C Compiler, Version 4.104, 5967               04-feb.-21 17:00

               Filename: D:\Laboratorio\Modulo Flujo Laminar\2021\JPCFLVMOD-2PM TOUCH Abaco OP202130 #0045884XX\Ejemplo MODBUS\Schematic I2C-RS485\RS485_I2C\RS485_I2C.lst

               ROM used: 3678 bytes (11%)
                         Largest free fragment is 29086
               RAM used: 1221 (60%) at main() level
                         1238 (60%) worst case
               Stack:    9 worst case (6 in main + 3 for interrupts)

*
0000:  GOTO   0D4C
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  F9D.1
004A:  GOTO   0054
004E:  BTFSC  F9E.1
0050:  GOTO   0304
0054:  BTFSS  F9D.5
0056:  GOTO   0060
005A:  BTFSC  F9E.5
005C:  GOTO   038A
0060:  BTFSS  F9D.3
0062:  GOTO   006C
0066:  BTFSC  F9E.3
0068:  GOTO   0408
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
.................... // Cuatro pulsadores de entrada (Derecha, Izquierda, arriba y abajo). 
.................... // Reloj con XT de 4 MHz. 
.................... // Programación para Autoclave con Calderin 
.................... // Tiene Menú:Ciclo: Liquidos, Instrumental suave, Textil Instrumental y Caucho. 
.................... // Tiene 6 niveles programables para desfogue suave. 
.................... // Ing. Juan David Piñeros. 
.................... // JP Inglobal. 2015 
....................  
.................... #include <18F2550.h> 
.................... //////// Standard Header file for the PIC18F2550 device //////////////// 
.................... #device PIC18F2550 
.................... #list 
....................  
.................... //#include <18F4620.h> 
.................... #device adc=10 
.................... #fuses XTPLL,NOWDT,NOPROTECT,NOLVP,NODEBUG,NOSTVREN,NOPUT,NOCPD,NOWRT,NOIESO,NOFCMEN,NOPBADEN,NOWRTC,NOWRTB,NOEBTR,NOEBTRB,NOCPB,NOXINST,NOBROWNOUT,NOLPT1OSC,NOMCLR,NOUSBDIV,NOVREGEN,PLL1 
.................... //#fuses HS,NOWDT,NOPROTECT,NOLVP,NODEBUG,NOSTVREN,NOPUT,NOCPD,NOWRT,NOIESO,NOFCMEN,NOPBADEN,NOWRTC,NOWRTB,NOEBTR,NOEBTRB,NOCPB,NOXINST,NOLPT1OSC,NOMCLR 
.................... #use delay(clock=4M) 
.................... #use i2c(slave, slow, sda=PIN_B0, scl=PIN_B1, address=0xB0) 
*
03F0:  MOVF   FC9,W
03F2:  MOVFF  4D4,FC9
03F6:  BSF    FC6.4
03F8:  BCF    F9E.3
03FA:  BTFSC  FC7.0
03FC:  BRA    03FA
03FE:  CLRF   01
0400:  BTFSC  FC6.4
0402:  INCF   01,F
0404:  GOTO   043C (RETURN)
.................... //#use i2c(slave, slow, sda=PIN_C4, scl=PIN_C3, address=0xB0) 
....................  
.................... #define MODBUS_TYPE MODBUS_TYPE_MASTER 
.................... #define MODBUS_SERIAL_TYPE MODBUS_RTU     //use MODBUS_ASCII for ASCII mode 
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE 1023 
.................... #define MODBUS_SERIAL_BAUD 9600 
....................  
.................... //#ifndef USE_WITH_PC 
.................... //#use rs232(baud=9600, UART1, stream=PC, errors) 
.................... #use RS232(BAUD=9600, BITS=8, PARITY=N, XMIT=PIN_B4, RCV=PIN_B5,stream=PC, errors) 
*
07FA:  BCF    F93.4
07FC:  BCF    F8A.4
07FE:  MOVLW  08
0800:  MOVWF  01
0802:  BRA    0804
0804:  NOP   
0806:  BSF    01.7
0808:  BRA    082A
080A:  BCF    01.7
080C:  MOVLB  4
080E:  RRCF   xCA,F
0810:  MOVLB  0
0812:  BTFSC  FD8.0
0814:  BSF    F8A.4
0816:  BTFSS  FD8.0
0818:  BCF    F8A.4
081A:  BSF    01.6
081C:  BRA    082A
081E:  BCF    01.6
0820:  DECFSZ 01,F
0822:  BRA    080C
0824:  BRA    0826
0826:  NOP   
0828:  BSF    F8A.4
082A:  MOVLW  1C
082C:  MOVWF  FE9
082E:  DECFSZ FE9,F
0830:  BRA    082E
0832:  BRA    0834
0834:  BTFSC  01.7
0836:  BRA    080A
0838:  BTFSC  01.6
083A:  BRA    081E
083C:  RETLW  00
.................... //#define MODBUS_SERIAL_INT_SOURCE MODBUS_INT_EXT 
.................... #define MODBUS_SERIAL_INT_SOURCE MODBUS_INT_RDA 
.................... #define MODBUS_SERIAL_TX_PIN PIN_C6   // Data transmit pin 
.................... #define MODBUS_SERIAL_RX_PIN PIN_C7   // Data receive pin 
.................... //The following should be defined for RS485 communication 
.................... #define MODBUS_SERIAL_ENABLE_PIN   PIN_C1   // Controls DE pin for RS485 
.................... #define MODBUS_SERIAL_RX_ENABLE    0   // Controls RE pin for RS485 
.................... #define DEBUG_MSG(msg) fprintf(PC, msg) 
.................... #define DEBUG_DATA(msg,data) fprintf(PC, msg, data) 
.................... //#else 
.................... //#define MODBUS_SERIAL_INT_SOURCE MODBUS_INT_EXT 
.................... //#define DEBUG_MSG(msg) if(0) 
.................... //#define DEBUG_DATA(msg,data) if(0) 
.................... //#endif 
....................  
.................... #include <modbus.c> 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                      modbus.c                                    //// 
.................... ////                                                                                  //// 
.................... ////                 MODBUS protocol driver for serial communications.                //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// DEFINES:                                                                         //// 
.................... ////                                                                                  //// 
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           //// 
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              //// 
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2,   //// 
.................... ////                                   MODBUS_INT_RDA3,MODBUS_INT_RDA4)               //// 
.................... ////  MODBUS_SERIAL_TYPE            MODBUS_RTU or MODBUS_ASCII                        //// 
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        //// 
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      //// 
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     //// 
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           //// 
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       //// 
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        //// 
.................... ////                                                                                  //// 
.................... ////                                                                                  //// 
.................... //// SHARED API:                                                                      //// 
.................... ////                                                                                  //// 
.................... ////  modbus_init()                                                                   //// 
.................... ////    - Initialize modbus serial communication system                               //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_start(address,func)                                          //// 
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data //// 
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_stop()                                                       //// 
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  //// 
.................... ////                                                                                  //// 
.................... ////  modbus_kbhit()                                                                  //// 
.................... ////    - Used to check if a packet has been received.                                //// 
.................... ////                                                                                  //// 
.................... //// MASTER API:                                                                      //// 
.................... ////  All master API functions return 0 on success.                                   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     //// 
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            //// 
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         //// 
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           //// 
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   //// 
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           //// 
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_exception_status(address)                                 //// 
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             //// 
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_counter(address)                                //// 
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_log(address)                                    //// 
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   //// 
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.//// 
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  //// 
.................... ////                    coils.                                                        //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)/// 
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. //// 
.................... ////    - Special Note: values is a pointer to an int8 array                          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_report_slave_id(address)                                       //// 
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  //// 
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 //// 
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)//// 
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,//// 
.................... ////                            write_start,write_quantity, *write_registers_value)   //// 
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          //// 
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////                                                                                  //// 
.................... //// Slave API:                                                                       //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_coils_rsp(address,byte_count,*coil_data)                       //// 
.................... ////    - Wrapper to respond to 0x01(read coils) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_discrete_input_rsp(address,byte_count,*input_data)             //// 
.................... ////    - Wrapper to respond to 0x02(read discret input) in the MODBUS specification. //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_holding_registers_rsp(address,byte_count,*reg_data)            //// 
.................... ////    - Wrapper to respond to 0x03(read holding regs) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_input_registers_rsp(address,byte_count,*input_data)            //// 
.................... ////    - Wrapper to respond to 0x04(read input regs) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_single_coil_rsp(address,output_address,output_value)          //// 
.................... ////    - Wrapper to respond to 0x05(write single coil) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_single_register_rsp(address,reg_address,reg_value)            //// 
.................... ////    - Wrapper to respond to 0x06(write single reg) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_exception_status_rsp(address, data)                            //// 
.................... ////    - Wrapper to respond to 0x07(read void status) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_diagnostics_rsp(address,sub_func,data)                              //// 
.................... ////    - Wrapper to respond to 0x08(diagnostics) in the MODBUS specification.        //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_get_comm_event_counter_rsp(address,status,event_count)              //// 
.................... ////    - Wrapper to respond to 0x0B(get comm event count) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_get_comm_event_log_rsp(address,status,event_count,message_count,    //// 
.................... ////                                   *events, events_len)                           //// 
.................... ////    - Wrapper to respond to 0x0C(get comm event log) in the MODBUS specification. //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_multiple_coils_rsp(address,start_address,quantity)            //// 
.................... ////    - Wrapper to respond to 0x0F(write multiple coils) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_multiple_registers_rsp(address,start_address,quantity)        //// 
.................... ////    - Wrapper to respond to 0x10(write multiple regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_report_slave_id_rsp(address,slave_id,run_status,*data,data_len)     //// 
.................... ////    - Wrapper to respond to 0x11(report slave id) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_file_record_rsp(address,byte_count,*request)                   //// 
.................... ////    - Wrapper to respond to 0x14(read file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_file_record_rsp(address,byte_count,*request)                  //// 
.................... ////    - Wrapper to respond to 0x15(write file record) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_mask_write_register_rsp(address,reference_address,AND_mask,OR_mask) //// 
.................... ////    - Wrapper to respond to 0x16(read coils) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_write_multiple_registers_rsp(address,*data,data_len)           //// 
.................... ////    - Wrapper to respond to 0x17(read write mult regs) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_FIFO_queue_rsp(address,FIFO_len,*data)                         //// 
.................... ////    - Wrapper to respond to 0x18(read FIFO queue) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_exception_rsp(int8 address, int16 func, exception error)            //// 
.................... ////    - Wrapper to send an exception response.  See exception list below.           //// 
.................... ////                                                                                  //// 
.................... //// Exception List:                                                                  //// 
.................... ////  ILLEGAL_FUNCTION, ILLEGAL_DATA_ADDRESS, ILLEGAL_DATA_VALUE,                     //// 
.................... ////  SLAVE_DEVICE_FAILURE, ACKNOWLEDGE, SLAVE_DEVICE_BUSY, MEMORY_PARITY_ERROR,      //// 
.................... ////  GATEWAY_PATH_UNAVAILABLE, GATEWAY_TARGET_NO_RESPONSE                            //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// Revision history:                                                                //// 
.................... ////  May 8, 2009          Made PCD Compatible                                        //// 
.................... ////  August 21, 2009      Added Modbus ASCII protocol                                //// 
.................... ////  September 25, 2009   Fixed Bug in RCV_ON function                               //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2006 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... /*Some defines so we can use identifiers to set things up*/ 
.................... #define MODBUS_TYPE_MASTER 99999 
.................... #define MODBUS_TYPE_SLAVE  88888 
.................... #define MODBUS_INT_RDA     77777 
.................... #define MODBUS_INT_RDA2    66666 
.................... #define MODBUS_INT_RDA3    44444 
.................... #define MODBUS_INT_RDA4    33333 
.................... #define MODBUS_INT_EXT     55555 
.................... #define MODBUS_RTU         1 
.................... #define MODBUS_ASCII       2 
....................  
.................... #ifndef MODBUS_TYPE 
.................... #define MODBUS_TYPE MODBUS_TYPE_MASTER 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_TYPE 
.................... #define MODBUS_SERIAL_TYPE MODBUS_RTU 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_INT_SOURCE 
.................... #define MODBUS_SERIAL_INT_SOURCE MODBUS_INT_RDA    // Select between external interrupt 
.................... #endif                                             // or asynchronous serial interrupt 
....................  
.................... #ifndef MODBUS_SERIAL_BAUD 
.................... #define MODBUS_SERIAL_BAUD 9600 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_RX_PIN 
.................... #define MODBUS_SERIAL_RX_PIN       PIN_C7   // Data receive pin 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_TX_PIN 
.................... #define MODBUS_SERIAL_TX_PIN       PIN_C6   // Data transmit pin 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_ENABLE_PIN 
.................... #define MODBUS_SERIAL_ENABLE_PIN   0   // Controls DE pin.  RX low, TX high. 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_RX_ENABLE 
.................... #define MODBUS_SERIAL_RX_ENABLE    0   // Controls RE pin.  Should keep low. 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_TIMEOUT 
....................    #if (MODBUS_SERIAL_TYPE == MODBUS_ASCII) 
....................       #define MODBUS_SERIAL_TIMEOUT    1000000 
....................    #else 
....................       #define MODBUS_SERIAL_TIMEOUT      10000     //in us 
....................    #endif 
.................... #endif 
....................  
.................... #if( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA ) 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART1, bits=8, stop=1, parity=N, stream=MODBUS_SERIAL, errors) 
*
0336:  BTFSS  F9E.5
0338:  BRA    0336
033A:  MOVFF  FAB,17
033E:  MOVFF  FAE,01
0342:  BTFSS  17.1
0344:  BRA    034A
0346:  BCF    FAB.4
0348:  BSF    FAB.4
034A:  RETLW  00
*
09AC:  BTFSS  F9E.4
09AE:  BRA    09AC
09B0:  MOVWF  FAD
09B2:  GOTO   09BE (RETURN)
....................    #define RCV_OFF() {disable_interrupts(INT_RDA);} 
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2 ) 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART2, bits=8, stop=1, parity=N, stream=MODBUS_SERIAL, errors) 
....................    #define RCV_OFF() {disable_interrupts(INT_RDA2);} 
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3 ) 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART3, bits=8, stop=1, parity=N, stream=MODBUS_SERIAL, errors) 
....................    #define RCV_OFF() {disable_interrupts(INT_RDA3);} 
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4 ) 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART4, bits=8, stop=1, parity=N, stream=MODBUS_SERIAL, errors) 
....................    #define RCV_OFF() {disable_interrupts(INT_RDA4);} 
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_EXT ) 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, xmit=MODBUS_SERIAL_TX_PIN, rcv=MODBUS_SERIAL_RX_PIN, bits=8, stop=1, parity=N, stream=MODBUS_SERIAL, disable_ints) 
....................    #if defined(__PCD__) 
....................    #define RCV_OFF() {disable_interrupts(INT_EXT0);} 
....................    #else 
....................    #define RCV_OFF() {disable_interrupts(INT_EXT);} 
....................    #endif 
.................... #else 
....................    #error Please define a correct interrupt source 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_RX_BUFFER_SIZE 
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE  64      //size of send/rcv buffer 
.................... #endif 
....................  
.................... #if (MODBUS_TYPE == MODBUS_TYPE_MASTER) 
.................... int32 modbus_serial_wait=MODBUS_SERIAL_TIMEOUT; 
....................  
.................... #define MODBUS_SERIAL_WAIT_FOR_RESPONSE()\ 
.................... {\ 
....................     if(address)\ 
....................     {\ 
....................         while(!modbus_kbhit() && --modbus_serial_wait)\ 
....................             delay_us(1);\ 
....................         if(!modbus_serial_wait)\ 
....................             modbus_rx.error=TIMEOUT;\ 
....................     }\ 
....................     modbus_serial_wait = MODBUS_SERIAL_TIMEOUT;\ 
.................... } 
.................... #endif 
....................  
.................... #if (MODBUS_SERIAL_INT_SOURCE != MODBUS_INT_EXT) 
....................    #if defined(__PCD__) 
....................       #if (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA) 
....................          #word TXSTA=getenv("SFR:U1STA")  
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2) 
....................          #word TXSTA=getenv("SFR:U2STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3) 
....................          #word TXSTA=getenv("SFR:U3STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4) 
....................          #word TXSTA=getenv("SFR:U4STA") 
....................          #bit TRMT=TXSTA.8 
....................       #endif 
....................    #else 
....................       #byte TXSTA=getenv("sfr:TXSTA") 
....................       #bit TRMT=TXSTA.1 
....................    #endif 
....................  
.................... #define WAIT_FOR_HW_BUFFER()\ 
.................... {\ 
....................    while(!TRMT);\ 
.................... }    
.................... #endif 
....................  
.................... int1 modbus_serial_new=0; 
....................  
.................... /******************************************************************** 
.................... These exceptions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to communicate problems with the transmission back 
.................... to the master who can also use these to easily check the exceptions.   
.................... The first exception is the only one that is not part of the protocol  
.................... specification.  The TIMEOUT exception is returned when no slave  
.................... responds to the master's request within the timeout period. 
.................... ********************************************************************/ 
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2,  
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6,  
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11, 
.................... TIMEOUT=12} exception; 
....................  
.................... /******************************************************************** 
.................... These functions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to check the incomming function.  See  
.................... ex_modbus_slave.c for example usage. 
.................... ********************************************************************/ 
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02, 
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04, 
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06, 
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08, 
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C, 
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10, 
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14, 
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16, 
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function; 
....................      
.................... /*Stages of MODBUS reception.  Used to keep our ISR fast enough.*/ 
.................... #if (MODBUS_SERIAL_TYPE==MODBUS_ASCII) 
....................    enum {MODBUS_START=0, MODBUS_GETADDY, MODBUS_GETFUNC, MODBUS_GETDATA, MODBUS_STOP} modbus_serial_state=0; 
.................... #else 
....................    enum {MODBUS_GETADDY=0, MODBUS_GETFUNC=1, MODBUS_GETDATA=2} modbus_serial_state = 0; 
.................... #endif 
....................  
.................... /*Global value holding our current CRC value.*/ 
.................... #if (MODBUS_SERIAL_TYPE==MODBUS_ASCII) 
....................    unsigned int8 modbus_serial_lrc; 
.................... #else 
....................    union 
....................    { 
....................       int8 b[2]; 
....................       int16 d; 
....................    } modbus_serial_crc; 
.................... #endif 
....................  
.................... /******************************************************************** 
.................... Our receive struct.  This is used when receiving data as a master or 
.................... slave.  Once a message is sent to you with your address, you should 
.................... begin processing that message.  Refer to ex_modbus_slave.c to see  
.................... how to properly use this structure. 
.................... ********************************************************************/ 
.................... struct 
.................... { 
....................    int8 address; 
....................    int8 len;                                //number of bytes in the message received 
....................    function func;                           //the function of the message received 
....................    exception error;                         //error recieved, if any 
....................    int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received 
.................... } modbus_rx; 
....................  
.................... /* Table of CRC values for highorder byte */ 
.................... #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
.................... const unsigned char modbus_auchCRCHi[] = { 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40 
.................... }; 
....................  
.................... /* Table of CRC values for loworder byte */ 
.................... const char modbus_auchCRCLo[] = { 
.................... 0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4, 
.................... 0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09, 
.................... 0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD, 
.................... 0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3, 
.................... 0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7, 
.................... 0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A, 
.................... 0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE, 
.................... 0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26, 
.................... 0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2, 
.................... 0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F, 
.................... 0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB, 
.................... 0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5, 
.................... 0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91, 
.................... 0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C, 
.................... 0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88, 
.................... 0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C, 
.................... 0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80, 
.................... 0x40 
.................... }; 
.................... #endif 
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void) 
.................... { 
....................    #if (MODBUS_SERIAL_INT_SOURCE!=MODBUS_INT_EXT) 
....................       while(kbhit(MODBUS_SERIAL)) {fgetc(MODBUS_SERIAL);}  //Clear RX buffer. Clear RDA interrupt flag. Clear overrun error flag. 
*
085E:  BTFSS  F9E.5
0860:  BRA    0866
0862:  RCALL  0336
....................       #if (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA) 
0864:  BRA    085E
....................         clear_interrupt(INT_RDA); 
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA2) 
....................         clear_interrupt(INT_RDA2); 
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA3) 
....................         clear_interrupt(INT_RDA3); 
....................       #else 
....................         clear_interrupt(INT_RDA4); 
....................       #endif 
....................  
....................       #if (MODBUS_SERIAL_RX_ENABLE!=0)  
....................          output_low(MODBUS_SERIAL_RX_ENABLE); 
....................       #endif 
....................  
....................       #if (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA) 
....................         enable_interrupts(INT_RDA); 
0866:  BSF    F9D.5
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA2) 
....................         enable_interrupts(INT_RDA2); 
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA3) 
....................         enable_interrupts(INT_RDA3); 
....................       #else 
....................         enable_interrupts(INT_RDA4); 
....................       #endif 
....................    #else 
....................       #if defined(__PCD__) 
....................          clear_interrupt(INT_EXT0); 
....................       #else 
....................          clear_interrupt(INT_EXT); 
....................       #endif 
....................        
....................       ext_int_edge(H_TO_L); 
....................       
....................       #if (MODBUS_SERIAL_RX_ENABLE!=0)  
....................          output_low(MODBUS_SERIAL_RX_ENABLE); 
....................       #endif 
....................  
....................       #if defined(__PCD__) 
....................          enable_interrupts(INT_EXT0); 
....................       #else 
....................          enable_interrupts(INT_EXT); 
....................       #endif 
....................    #endif 
.................... } 
0868:  RETLW  00
....................  
.................... // Purpose:    Initialize RS485 communication. Call this before 
.................... //             using any other RS485 functions. 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void modbus_init() 
.................... { 
....................    output_low(MODBUS_SERIAL_ENABLE_PIN); 
086A:  BCF    F94.1
086C:  BCF    F8B.1
....................  
....................    RCV_ON(); 
086E:  RCALL  085E
....................  
....................    #if defined(__PCD__) 
....................       #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
....................          setup_timer2(TMR_INTERNAL | TMR_DIV_BY_8,4999); //~4ms interrupts for 20Mhz clock 
....................       #endif 
....................       enable_interrupts(INTR_GLOBAL); 
....................    #else 
....................       #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
....................          setup_timer_2(T2_DIV_BY_16,249,5);  //~4ms interrupts 
0870:  MOVLW  20
0872:  IORLW  06
0874:  MOVWF  FCA
0876:  MOVLW  F9
0878:  MOVWF  FCB
....................       #endif 
....................       enable_interrupts(GLOBAL); 
087A:  MOVLW  C0
087C:  IORWF  FF2,F
....................    #endif 
.................... } 
087E:  GOTO   0DF2 (RETURN)
....................  
.................... // Purpose:    Start our timeout timer 
.................... // Inputs:     Enable, used to turn timer on/off 
.................... // Outputs:    None 
.................... // Not used for ASCII mode 
.................... #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
.................... void modbus_enable_timeout(int1 enable) 
.................... { 
....................    disable_interrupts(INT_TIMER2); 
*
02F2:  BCF    F9D.1
....................    if (enable) { 
02F4:  MOVLB  4
02F6:  MOVF   xD3,F
02F8:  BZ    0300
....................       set_timer2(0); 
02FA:  CLRF   FCC
....................       clear_interrupt(INT_TIMER2); 
02FC:  BCF    F9E.1
....................       enable_interrupts(INT_TIMER2); 
02FE:  BSF    F9D.1
....................    } 
.................... } 
0300:  MOVLB  0
0302:  RETLW  00
.................... #endif 
....................  
.................... // Purpose:    Check if we have timed out waiting for a response 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... // Not used for ASCII mode 
.................... #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
....................    #int_timer2 
....................    void modbus_timeout_now(void) 
....................    { 
....................       if((modbus_serial_state == MODBUS_GETDATA) && (modbus_serial_crc.d == 0x0000) && (!modbus_serial_new)) 
0304:  MOVF   1D,W
0306:  SUBLW  02
0308:  BNZ   031E
030A:  MOVF   1E,F
030C:  BNZ   031E
030E:  MOVF   1F,F
0310:  BNZ   031E
0312:  BTFSC  1C.0
0314:  BRA    031E
....................       { 
....................          modbus_rx.len-=2; 
0316:  MOVLW  02
0318:  SUBWF  21,F
....................          modbus_serial_new=TRUE; 
031A:  BSF    1C.0
....................       } 
....................       else 
031C:  BRA    0320
....................          modbus_serial_new=FALSE; 
031E:  BCF    1C.0
....................     
....................       modbus_serial_crc.d=0xFFFF; 
0320:  MOVLW  FF
0322:  MOVWF  1F
0324:  MOVWF  1E
....................       modbus_serial_state=MODBUS_GETADDY; 
0326:  CLRF   1D
....................       modbus_enable_timeout(FALSE); 
0328:  MOVLB  4
032A:  CLRF   xD3
032C:  MOVLB  0
032E:  RCALL  02F2
....................    } 
.................... #endif 
....................  
.................... // Purpose:    Calculate crc of data and updates global crc 
.................... // Inputs:     Character 
.................... // Outputs:    None 
0330:  BCF    F9E.1
0332:  GOTO   006C
.................... void modbus_calc_crc(char data) 
.................... { 
....................    #if (MODBUS_SERIAL_TYPE == MODBUS_ASCII) 
....................       modbus_serial_lrc+=data; 
....................    #else 
....................       unsigned int8 uIndex ; // will index into CRC lookup table 
....................  
....................       uIndex = (modbus_serial_crc.b[1]) ^ data; // calculate the CRC 
*
034C:  MOVF   1F,W
034E:  MOVLB  4
0350:  XORWF  xD3,W
0352:  MOVWF  xD4
....................       modbus_serial_crc.b[1] = (modbus_serial_crc.b[0]) ^ modbus_auchCRCHi[uIndex]; 
0354:  CLRF   03
0356:  MOVF   xD4,W
0358:  MOVFF  FF2,4D5
035C:  BCF    FF2.7
035E:  MOVLB  0
0360:  RCALL  00AE
0362:  MOVLB  4
0364:  BTFSC  xD5.7
0366:  BSF    FF2.7
0368:  MOVWF  01
036A:  MOVF   1E,W
036C:  XORWF  01,W
036E:  MOVWF  1F
....................       modbus_serial_crc.b[0] = modbus_auchCRCLo[uIndex]; 
0370:  CLRF   03
0372:  MOVF   xD4,W
0374:  MOVFF  FF2,4D5
0378:  BCF    FF2.7
037A:  MOVLB  0
037C:  RCALL  01D0
037E:  MOVLB  4
0380:  BTFSC  xD5.7
0382:  BSF    FF2.7
0384:  MOVWF  1E
....................    #endif 
.................... } 
0386:  MOVLB  0
0388:  RETLW  00
....................  
.................... // Purpose:    Puts a character onto the serial line 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_putc(int8 c) 
.................... { 
....................    #if (MODBUS_SERIAL_TYPE==MODBUS_ASCII) 
....................       int8 asciih,asciil; 
....................        
....................       asciih=c>>4; 
....................       if(asciih>9) 
....................          asciih+=0x37; 
....................       else 
....................          asciih+=0x30; 
....................       asciil=c&0xF; 
....................       if(asciil>9) 
....................          asciil+=0x37; 
....................       else 
....................          asciil+=0x30; 
....................       fputc(asciih,MODBUS_SERIAL); 
....................       fputc(asciil,MODBUS_SERIAL); 
....................       modbus_calc_crc(c); 
....................    #else 
....................       fputc(c, MODBUS_SERIAL); 
*
09B6:  MOVLB  4
09B8:  MOVF   xCE,W
09BA:  MOVLB  0
09BC:  BRA    09AC
09BE:  CLRF   16
09C0:  BTFSC  FF2.7
09C2:  BSF    16.7
09C4:  BCF    FF2.7
....................       modbus_calc_crc(c); 
09C6:  MOVFF  4CE,4D3
09CA:  RCALL  034C
09CC:  BTFSC  16.7
09CE:  BSF    FF2.7
....................       delay_us(1000000/MODBUS_SERIAL_BAUD); //one stop bit.  not exact 
09D0:  MOVLW  22
09D2:  MOVWF  00
09D4:  DECFSZ 00,F
09D6:  BRA    09D4
09D8:  NOP   
....................    #endif 
.................... } 
09DA:  RETLW  00
....................  
.................... // Purpose:   Interrupt service routine for handling incoming serial data 
.................... // Inputs:    None 
.................... // Outputs:   None 
.................... #if (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA) 
.................... #int_rda 
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA2) 
.................... #int_rda2 
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA3) 
.................... #int_rda3 
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA4) 
.................... #int_rda4 
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_EXT) 
.................... #if defined(__PCD__) 
.................... #int_ext0 
.................... #else 
.................... #int_ext 
.................... #endif 
.................... #else 
.................... #error Please define a correct interrupt source 
.................... #endif 
.................... void incomming_modbus_serial() { 
....................    char c; 
....................    #if (MODBUS_SERIAL_TYPE==MODBUS_ASCII) 
....................       static int1 two_characters=0; 
....................       static int8 datah,datal,data; 
....................    #endif 
....................  
....................    c=fgetc(MODBUS_SERIAL); 
*
038A:  RCALL  0336
038C:  MOVFF  01,4D2
....................     
....................    if (!modbus_serial_new) 
0390:  BTFSC  1C.0
0392:  BRA    03DE
....................    { 
....................       #if (MODBUS_SERIAL_TYPE==MODBUS_ASCII) 
....................          if(modbus_serial_state == MODBUS_START) 
....................          { 
....................             if(c==':') 
....................                modbus_serial_state++; 
....................          } 
....................          else if(modbus_serial_state == MODBUS_GETADDY) 
....................          { 
....................             if(!two_characters) 
....................             { 
....................                if(c>=0x41) 
....................                   datah=((c-0x37)<<4); 
....................                else 
....................                   datah=((c-0x30)<<4); 
....................                modbus_serial_lrc=0; 
....................             } 
....................             else 
....................             { 
....................                if(c>=0x41) 
....................                   datal=c-0x37; 
....................                else 
....................                   datal=c-0x30; 
....................                data=(datah | datal); 
....................                modbus_rx.address=data; 
....................                modbus_calc_crc(data); 
....................                modbus_serial_state++; 
....................             } 
....................             two_characters++; 
....................          } 
....................          else if(modbus_serial_state == MODBUS_GETFUNC) 
....................          { 
....................             if(!two_characters) 
....................             { 
....................                if(c>=0x41) 
....................                   datah=((c-0x37)<<4); 
....................                else 
....................                   datah=((c-0x30)<<4); 
....................             } 
....................             else 
....................             { 
....................                if(c>=0x41) 
....................                   datal=c-0x37; 
....................                else 
....................                   datal=c-0x30; 
....................                data=(datah | datal); 
....................                modbus_rx.func=data; 
....................                modbus_calc_crc(data); 
....................                modbus_serial_state++; 
....................                modbus_rx.len=0; 
....................                modbus_rx.error=0; 
....................             } 
....................             two_characters++; 
....................          } 
....................          else if(modbus_serial_state == MODBUS_GETDATA) 
....................          { 
....................             if(c=='\r') 
....................             { 
....................                modbus_serial_state++; 
....................                modbus_rx.len--; 
....................                modbus_serial_lrc-=data; 
....................             } 
....................             else if(!two_characters) 
....................             { 
....................                if(c>=0x41) 
....................                   datah=((c-0x37)<<4); 
....................                else 
....................                   datah=((c-0x30)<<4); 
....................                two_characters++; 
....................             } 
....................             else 
....................             { 
....................                if(c>=0x41) 
....................                   datal=c-0x37; 
....................                else 
....................                   datal=c-0x30; 
....................                data=(datah | datal); 
....................                if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) 
....................                   modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1; 
....................                modbus_rx.data[modbus_rx.len]=data; 
....................                modbus_rx.len++; 
....................                modbus_calc_crc(data); 
....................                two_characters++; 
....................             } 
....................          } 
....................          else if(modbus_serial_state==MODBUS_STOP) 
....................          { 
....................             if(c=='\n') 
....................             { 
....................                modbus_serial_lrc=((0xFF-modbus_serial_lrc)+1); 
....................                if(modbus_serial_lrc==data) 
....................                   modbus_serial_new=TRUE; 
....................             } 
....................             modbus_serial_state=MODBUS_START; 
....................             two_characters=0; 
....................          } 
....................       #else 
....................              
....................          if(modbus_serial_state == MODBUS_GETADDY) 
0394:  MOVF   1D,F
0396:  BNZ   03AA
....................          { 
....................             modbus_serial_crc.d = 0xFFFF; 
0398:  MOVLW  FF
039A:  MOVWF  1F
039C:  MOVWF  1E
....................             modbus_rx.address = c; 
039E:  MOVFF  4D2,20
....................             modbus_serial_state++; 
03A2:  INCF   1D,F
....................             modbus_rx.len = 0; 
03A4:  CLRF   21
....................             modbus_rx.error=0; 
03A6:  CLRF   23
....................          } 
....................          else if(modbus_serial_state == MODBUS_GETFUNC) 
03A8:  BRA    03CE
03AA:  DECFSZ 1D,W
03AC:  BRA    03B6
....................          { 
....................             modbus_rx.func = c; 
03AE:  MOVFF  4D2,22
....................             modbus_serial_state++; 
03B2:  INCF   1D,F
....................          } 
....................          else if(modbus_serial_state == MODBUS_GETDATA) 
03B4:  BRA    03CE
03B6:  MOVF   1D,W
03B8:  SUBLW  02
03BA:  BNZ   03CE
....................          { 
....................             if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) {modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1;} 
....................             modbus_rx.data[modbus_rx.len]=c; 
03BC:  MOVLW  24
03BE:  ADDWF  21,W
03C0:  MOVWF  FE9
03C2:  CLRF   FEA
03C4:  BTFSC  FD8.0
03C6:  INCF   FEA,F
03C8:  MOVFF  4D2,FEF
....................             modbus_rx.len++; 
03CC:  INCF   21,F
....................          } 
....................     
....................          modbus_calc_crc(c); 
03CE:  MOVFF  4D2,4D3
03D2:  RCALL  034C
....................          modbus_enable_timeout(TRUE); 
03D4:  MOVLW  01
03D6:  MOVLB  4
03D8:  MOVWF  xD3
03DA:  MOVLB  0
03DC:  RCALL  02F2
....................       #endif 
....................    } 
....................    #if (MODBUS_TYPE == MODBUS_TYPE_MASTER) 
....................       modbus_serial_wait=MODBUS_SERIAL_TIMEOUT; 
03DE:  CLRF   1B
03E0:  CLRF   1A
03E2:  MOVLW  27
03E4:  MOVWF  19
03E6:  MOVLW  10
03E8:  MOVWF  18
....................    #endif 
.................... } 
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... //             4) The length of the data 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
03EA:  BCF    F9E.5
03EC:  GOTO   006C
.................... void modbus_serial_send_start(int8 to, int8 func) 
.................... { 
....................    #if (MODBUS_SERIAL_TYPE==MODBUS_ASCII) 
....................       modbus_serial_lrc=0; 
....................    #else 
....................       modbus_serial_crc.d=0xFFFF; 
*
09DC:  MOVLW  FF
09DE:  MOVWF  1F
09E0:  MOVWF  1E
....................    #endif 
....................    modbus_serial_new=FALSE; 
09E2:  BCF    1C.0
....................  
....................    RCV_OFF(); 
09E4:  BCF    F9D.5
....................     
.................... #if (MODBUS_SERIAL_ENABLE_PIN!=0)  
....................    output_high(MODBUS_SERIAL_ENABLE_PIN); 
09E6:  BCF    F94.1
09E8:  BSF    F8B.1
.................... #endif 
....................  
....................    #if (MODBUS_SERIAL_TYPE==MODBUS_RTU) 
....................       delay_us(3500000/MODBUS_SERIAL_BAUD); //3.5 character delay 
09EA:  MOVLW  79
09EC:  MOVWF  00
09EE:  DECFSZ 00,F
09F0:  BRA    09EE
....................    #else 
....................       fputc(':',MODBUS_SERIAL); 
....................    #endif 
....................  
....................    modbus_serial_putc(to); 
09F2:  MOVFF  4CC,4CE
09F6:  RCALL  09B6
....................    modbus_serial_putc(func); 
09F8:  MOVFF  4CD,4CE
09FC:  RCALL  09B6
.................... } 
09FE:  RETLW  00
....................  
.................... void modbus_serial_send_stop() 
.................... { 
....................    #if (MODBUS_SERIAL_TYPE == MODBUS_ASCII) 
....................       int8 i; 
....................        
....................       for(i=0;i<8;i++) 
....................       { 
....................          if(bit_test(modbus_serial_lrc,i)) 
....................             bit_clear(modbus_serial_lrc,i); 
....................          else 
....................             bit_set(modbus_serial_lrc,i); 
....................       } 
....................       modbus_serial_lrc++; 
....................        
....................       modbus_serial_putc(modbus_serial_lrc); 
....................       fputc('\r',MODBUS_SERIAL); 
....................       fputc('\n',MODBUS_SERIAL); 
....................    #else 
....................       int8 crc_low, crc_high; 
....................     
....................       crc_high=modbus_serial_crc.b[1]; 
0A00:  MOVFF  1F,4CD
....................       crc_low=modbus_serial_crc.b[0]; 
0A04:  MOVFF  1E,4CC
....................     
....................       modbus_serial_putc(crc_high); 
0A08:  MOVFF  4CD,4CE
0A0C:  RCALL  09B6
....................       modbus_serial_putc(crc_low); 
0A0E:  MOVFF  4CC,4CE
0A12:  RCALL  09B6
....................    #endif 
....................     
.................... #if (MODBUS_SERIAL_INT_SOURCE!=MODBUS_INT_EXT) 
....................    WAIT_FOR_HW_BUFFER(); 
0A14:  BTFSS  FAC.1
0A16:  BRA    0A14
.................... #endif 
....................     
....................    #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
....................       delay_us(3500000/MODBUS_SERIAL_BAUD); //3.5 character delay 
0A18:  MOVLW  79
0A1A:  MOVWF  00
0A1C:  DECFSZ 00,F
0A1E:  BRA    0A1C
....................    #endif 
....................  
....................    RCV_ON(); 
0A20:  RCALL  085E
....................  
.................... #if (MODBUS_SERIAL_ENABLE_PIN!=0)  
....................    output_low(MODBUS_SERIAL_ENABLE_PIN); 
0A22:  BCF    F94.1
0A24:  BCF    F8B.1
.................... #endif 
....................  
....................    #if (MODBUS_SERIAL_TYPE == MODBUS_ASCII) 
....................       modbus_serial_lrc=0; 
....................    #else 
....................       modbus_serial_crc.d=0xFFFF; 
0A26:  MOVLW  FF
0A28:  MOVWF  1F
0A2A:  MOVWF  1E
....................    #endif 
.................... } 
0A2C:  RETLW  00
....................  
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer 
.................... // Inputs:     None 
.................... // Outputs:    TRUE if a message was received 
.................... //             FALSE if no message is available 
.................... // Note:       Data will be filled in at the modbus_rx struct: 
.................... int1 modbus_kbhit() 
.................... { 
....................    if(!modbus_serial_new) 
0A2E:  BTFSC  1C.0
0A30:  BRA    0A3A
....................       return FALSE; 
0A32:  MOVLW  00
0A34:  MOVWF  01
0A36:  BRA    0A4C
....................    else if(modbus_rx.func & 0x80)           //did we receive an error? 
0A38:  BRA    0A46
0A3A:  BTFSS  22.7
0A3C:  BRA    0A46
....................    { 
....................       modbus_rx.error = modbus_rx.data[0];  //if so grab the error and return true 
0A3E:  MOVFF  24,23
....................       modbus_rx.len = 1; 
0A42:  MOVLW  01
0A44:  MOVWF  21
....................    } 
....................    modbus_serial_new=FALSE; 
0A46:  BCF    1C.0
....................    return TRUE; 
0A48:  MOVLW  01
0A4A:  MOVWF  01
.................... } 
0A4C:  RETLW  00
....................  
.................... #if (MODBUS_TYPE==MODBUS_TYPE_MASTER) 
.................... /*MODBUS Master Functions*/ 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request.  These 
.................... functions take in one of these structs. 
.................... Please refer to the MODBUS protocol specification if you do not 
.................... understand the members of the structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
.................... } modbus_read_sub_request; 
....................  
.................... typedef struct _modbus_write_sub_request 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
....................    int16 data[MODBUS_SERIAL_RX_BUFFER_SIZE-8]; 
.................... } modbus_write_sub_request; 
....................  
....................  
.................... /******************************************************************** 
.................... The following functions are defined in the MODBUS protocol.  Please 
.................... refer to http://www.modbus.org for the purpose of each of these. 
.................... All functions take the slaves address as their first parameter. 
.................... Each function returns the exception code received from the response. 
.................... The function will return 0 if there were no errors in transmission. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_coils(int8 address, int16 start_address, int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................     
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_discrete_input 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_discrete_input(int8 address, int16 start_address, int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................        
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_holding_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_holding_registers(int8 address, int16 start_address, int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
0A4E:  MOVFF  4C5,4CC
0A52:  MOVLW  03
0A54:  MOVLB  4
0A56:  MOVWF  xCD
0A58:  MOVLB  0
0A5A:  RCALL  09DC
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
0A5C:  MOVFF  4C7,4CA
0A60:  MOVFF  4C7,4CE
0A64:  RCALL  09B6
....................    modbus_serial_putc(make8(start_address,0)); 
0A66:  MOVFF  4C6,4CA
0A6A:  MOVFF  4C6,4CE
0A6E:  RCALL  09B6
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
0A70:  MOVFF  4C9,4CA
0A74:  MOVFF  4C9,4CE
0A78:  RCALL  09B6
....................    modbus_serial_putc(make8(quantity,0)); 
0A7A:  MOVFF  4C8,4CA
0A7E:  MOVFF  4C8,4CE
0A82:  RCALL  09B6
....................  
....................    modbus_serial_send_stop(); 
0A84:  RCALL  0A00
....................     
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
0A86:  MOVLB  4
0A88:  MOVF   xC5,F
0A8A:  BZ    0ACE
0A8C:  MOVLB  0
0A8E:  RCALL  0A2E
0A90:  MOVF   01,F
0A92:  BNZ   0AB8
0A94:  MOVLW  FF
0A96:  ADDWF  18,F
0A98:  BTFSS  FD8.0
0A9A:  ADDWF  19,F
0A9C:  BTFSS  FD8.0
0A9E:  ADDWF  1A,F
0AA0:  BTFSS  FD8.0
0AA2:  ADDWF  1B,F
0AA4:  MOVF   18,F
0AA6:  BNZ   0AB4
0AA8:  MOVF   19,F
0AAA:  BNZ   0AB4
0AAC:  MOVF   1A,F
0AAE:  BNZ   0AB4
0AB0:  MOVF   1B,F
0AB2:  BZ    0AB8
0AB4:  NOP   
0AB6:  BRA    0A8E
0AB8:  MOVF   18,F
0ABA:  BNZ   0ACC
0ABC:  MOVF   19,F
0ABE:  BNZ   0ACC
0AC0:  MOVF   1A,F
0AC2:  BNZ   0ACC
0AC4:  MOVF   1B,F
0AC6:  BNZ   0ACC
0AC8:  MOVLW  0C
0ACA:  MOVWF  23
0ACC:  MOVLB  4
0ACE:  CLRF   1B
0AD0:  CLRF   1A
0AD2:  MOVLW  27
0AD4:  MOVWF  19
0AD6:  MOVLW  10
0AD8:  MOVWF  18
....................  
....................    return modbus_rx.error; 
0ADA:  MOVFF  23,01
.................... } 
0ADE:  MOVLB  0
0AE0:  GOTO   0B4A (RETURN)
....................  
.................... /* 
.................... read_input_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_input_registers(int8 address, int16 start_address, int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................     
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_single_coil 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Address to write into 
....................            int1       on                 true for on, false for off 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_single_coil(int8 address, int16 output_address, int1 on) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
....................    modbus_serial_putc(make8(output_address,0)); 
....................  
....................    if(on) 
....................        modbus_serial_putc(0xFF); 
....................    else 
....................        modbus_serial_putc(0x00); 
....................     
....................    modbus_serial_putc(0x00); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_single_register 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Address to write into 
....................            int16      reg_value          Value to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_single_register(int8 address, int16 reg_address, int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
*
0C06:  MOVFF  4C7,4CC
0C0A:  MOVLW  06
0C0C:  MOVLB  4
0C0E:  MOVWF  xCD
0C10:  MOVLB  0
0C12:  RCALL  09DC
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
0C14:  MOVFF  4C9,4CC
0C18:  MOVFF  4C9,4CE
0C1C:  RCALL  09B6
....................    modbus_serial_putc(make8(reg_address,0)); 
0C1E:  MOVFF  4C8,4CC
0C22:  MOVFF  4C8,4CE
0C26:  RCALL  09B6
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
0C28:  MOVFF  4CB,4CC
0C2C:  MOVFF  4CB,4CE
0C30:  RCALL  09B6
....................    modbus_serial_putc(make8(reg_value,0)); 
0C32:  MOVFF  4CA,4CC
0C36:  MOVFF  4CA,4CE
0C3A:  RCALL  09B6
....................  
....................    modbus_serial_send_stop(); 
0C3C:  RCALL  0A00
....................     
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
0C3E:  MOVLB  4
0C40:  MOVF   xC7,F
0C42:  BZ    0C86
0C44:  MOVLB  0
0C46:  RCALL  0A2E
0C48:  MOVF   01,F
0C4A:  BNZ   0C70
0C4C:  MOVLW  FF
0C4E:  ADDWF  18,F
0C50:  BTFSS  FD8.0
0C52:  ADDWF  19,F
0C54:  BTFSS  FD8.0
0C56:  ADDWF  1A,F
0C58:  BTFSS  FD8.0
0C5A:  ADDWF  1B,F
0C5C:  MOVF   18,F
0C5E:  BNZ   0C6C
0C60:  MOVF   19,F
0C62:  BNZ   0C6C
0C64:  MOVF   1A,F
0C66:  BNZ   0C6C
0C68:  MOVF   1B,F
0C6A:  BZ    0C70
0C6C:  NOP   
0C6E:  BRA    0C46
0C70:  MOVF   18,F
0C72:  BNZ   0C84
0C74:  MOVF   19,F
0C76:  BNZ   0C84
0C78:  MOVF   1A,F
0C7A:  BNZ   0C84
0C7C:  MOVF   1B,F
0C7E:  BNZ   0C84
0C80:  MOVLW  0C
0C82:  MOVWF  23
0C84:  MOVLB  4
0C86:  CLRF   1B
0C88:  CLRF   1A
0C8A:  MOVLW  27
0C8C:  MOVWF  19
0C8E:  MOVLW  10
0C90:  MOVWF  18
....................  
....................    return modbus_rx.error; 
0C92:  MOVFF  23,01
.................... } 
0C96:  MOVLB  0
0C98:  GOTO   0CC0 (RETURN)
....................  
.................... /* 
.................... read_exception_status 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_exception_status(int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... diagnostics 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Subfunction to send 
....................            int16      data               Data to send, changes based on subfunction 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_diagnostics(int8 address, int16 sub_func, int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... get_comm_event_couter 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_get_comm_event_counter(int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... get_comm_event_log 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_get_comm_event_log(int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start at 
....................            int16      quantity           Amount of coils to write to 
....................            int1*      values             A pointer to an array holding the values to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_multiple_coils(int8 address, int16 start_address, int16 quantity, 
....................                            int8 *values) 
.................... { 
....................    int8 i,count; 
....................     
....................    count = (int8)((quantity/8)); 
....................     
....................    if(quantity%8) 
....................       count++;       
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_putc(count); 
....................  
....................    for(i=0; i < count; ++i)  
....................       modbus_serial_putc(values[i]); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_multiple_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start at 
....................            int16      quantity           Amount of coils to write to 
....................            int16*     values             A pointer to an array holding the data to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_multiple_registers(int8 address, int16 start_address, int16 quantity, 
....................                            int16 *values) 
.................... { 
....................    int8 i,count; 
....................     
....................    count = quantity*2; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................     
....................    modbus_serial_putc(count); 
....................  
....................    for(i=0; i < quantity; ++i) 
....................    { 
....................       modbus_serial_putc(make8(values[i],1)); 
....................       modbus_serial_putc(make8(values[i],0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... report_slave_id 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_report_slave_id(int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_file_record 
.................... Input:     int8                address            Slave Address 
....................            int8                byte_count         Number of bytes to read 
....................            read_sub_request*   request            Structure holding record information 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_file_record(int8 address, int8 byte_count,  
....................                             modbus_read_sub_request *request) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < (byte_count/7); i+=7) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_file_record 
.................... Input:     int8                address            Slave Address 
....................            int8                byte_count         Number of bytes to read 
....................            read_sub_request*   request            Structure holding record/data information 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_file_record(int8 address, int8 byte_count,  
....................                             modbus_write_sub_request *request) 
.................... { 
....................    int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length) &&  
....................             (j < MODBUS_SERIAL_RX_BUFFER_SIZE-8); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... mask_write_register 
.................... Input:     int8       address            Slave Address 
....................            int16      reference_address  Address to mask 
....................            int16      AND_mask           A mask to AND with the data at reference_address 
....................            int16      OR_mask            A mask to OR with the data at reference_address 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_mask_write_register(int8 address, int16 reference_address, 
....................                            int16 AND_mask, int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers 
.................... Input:     int8       address                Slave Address 
....................            int16      read_start             Address to start reading 
....................            int16      read_quantity          Amount of registers to read 
....................            int16      write_start            Address to start writing 
....................            int16      write_quantity         Amount of registers to write 
....................            int16*     write_registers_value  Pointer to an aray us to write 
.................... Output:    exception                         0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_write_multiple_registers(int8 address, int16 read_start, 
....................                                     int16 read_quantity, int16 write_start, 
....................                                     int16 write_quantity, 
....................                                     int16 *write_registers_value) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(read_start,1)); 
....................    modbus_serial_putc(make8(read_start,0)); 
....................  
....................    modbus_serial_putc(make8(read_quantity,1)); 
....................    modbus_serial_putc(make8(read_quantity,0)); 
....................  
....................    modbus_serial_putc(make8(write_start, 1)); 
....................    modbus_serial_putc(make8(write_start, 0)); 
....................  
....................    modbus_serial_putc(make8(write_quantity, 1)); 
....................    modbus_serial_putc(make8(write_quantity, 0)); 
....................  
....................    modbus_serial_putc((int8)(2*write_quantity)); 
....................  
....................    for(i=0; i < write_quantity ; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(write_registers_value[i], 1)); 
....................       modbus_serial_putc(make8(write_registers_value[i+1], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue 
.................... Input:     int8       address           Slave Address 
....................            int16      FIFO_address      FIFO address 
.................... Output:    exception                    0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_FIFO_queue(int8 address, int16 FIFO_address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(FIFO_address, 1)); 
....................    modbus_serial_putc(make8(FIFO_address, 0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... #else 
.................... /*MODBUS Slave Functions*/ 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request_rsp.  These 
.................... functions take in one of these structs.  Please refer to the MODBUS 
.................... protocol specification if you do not understand the members of the 
.................... structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request_rsp 
.................... { 
....................    int8 record_length; 
....................    int8 reference_type; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3]; 
.................... } modbus_read_sub_request_rsp; 
....................  
.................... typedef struct _modbus_write_sub_request_rsp 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8]; 
.................... } modbus_write_sub_request_rsp; 
....................  
....................  
.................... /******************************************************************** 
.................... The following slave functions are defined in the MODBUS protocol. 
.................... Please refer to http://www.modbus.org for the purpose of each of 
.................... these.  All functions take the slaves address as their first 
.................... parameter. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      coil_data          Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_coils_rsp(int8 address, int8 byte_count, int8* coil_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*coil_data); 
....................       coil_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_discrete_input_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_discrete_input_rsp(int8 address, int8 byte_count,  
....................                                     int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_holding_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      reg_data           Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_holding_registers_rsp(int8 address, int8 byte_count,  
....................                                         int16 *reg_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(*reg_data,1)); 
....................       modbus_serial_putc(make8(*reg_data,0)); 
....................       reg_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_input_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_input_registers_rsp(int8 address, int8 byte_count,  
....................                                         int16 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(*input_data,1)); 
....................       modbus_serial_putc(make8(*input_data,0)); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_coil_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Echo of output address received 
....................            int16      output_value       Echo of output value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_coil_rsp(int8 address, int16 output_address,  
....................                                     int16 output_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
....................    modbus_serial_putc(make8(output_address,0)); 
....................  
....................    modbus_serial_putc(make8(output_value,1)); 
....................    modbus_serial_putc(make8(output_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_register_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Echo of register address received 
....................            int16      reg_value          Echo of register value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_register_rsp(int8 address, int16 reg_address,  
....................                                         int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
....................    modbus_serial_putc(make8(reg_address,0)); 
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
....................    modbus_serial_putc(make8(reg_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_exception_status_rsp 
.................... Input:     int8       address            Slave Address 
.................... Output:    void 
.................... */ 
.................... void modbus_read_exception_status_rsp(int8 address, int8 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... diagnostics_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Echo of sub function received 
....................            int16      data               Echo of data received 
.................... Output:    void 
.................... */ 
.................... void modbus_diagnostics_rsp(int8 address, int16 sub_func, int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_counter_rsp(int8 address, int16 status,  
....................                                         int16 event_count) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
....................            int16      message_count      Count of messages 
....................            int8*      events             Pointer to event data 
....................            int8       events_len         Length of event data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_log_rsp(int8 address, int16 status, 
....................                                     int16 event_count, int16 message_count,  
....................                                     int8 *events, int8 events_len) 
.................... { 
....................    int8 i; 
....................      
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................  
....................    modbus_serial_putc(events_len+6); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_putc(make8(message_count, 1)); 
....................    modbus_serial_putc(make8(message_count, 0)); 
....................  
....................    for(i=0; i < events_len; ++i) 
....................    { 
....................       modbus_serial_putc(*events); 
....................       events++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of coils written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_coils_rsp(int8 address, int16 start_address,  
....................                                         int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of registers written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_registers_rsp(int8 address, int16 start_address,  
....................                                             int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... report_slave_id_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       slave_id           Slave Address 
....................            int8       run_status         Are we running? 
....................            int8*      data               Pointer to an array holding the data 
....................            int8       data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_report_slave_id_rsp(int8 address, int8 slave_id, int1 run_status, 
....................                               int8 *data, int8 data_len) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................  
....................    modbus_serial_putc(data_len+2); 
....................    modbus_serial_putc(slave_id); 
....................  
....................    if(run_status) 
....................     modbus_serial_putc(0xFF); 
....................    else 
....................     modbus_serial_putc(0x00); 
....................  
....................    for(i=0; i < data_len; ++i) 
....................    { 
....................       modbus_serial_putc(*data); 
....................       data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Number of bytes to send 
....................            read_sub_request_rsp*    request            Structure holding record/data information 
.................... Output:    void 
.................... */ 
.................... void modbus_read_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_read_sub_request_rsp *request) 
.................... { 
....................    int8 i=0,j; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    while(i < byte_count); 
....................    { 
....................       modbus_serial_putc(request->record_length); 
....................       modbus_serial_putc(request->reference_type); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................  
....................       i += (request->record_length)+1; 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Echo of number of bytes sent 
....................            write_sub_request_rsp*   request            Echo of Structure holding record information 
.................... Output:    void 
.................... */ 
.................... void modbus_write_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_write_sub_request_rsp *request) 
.................... { 
....................    int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... mask_write_register_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       reference_address  Echo of reference address 
....................            int16       AND_mask           Echo of AND mask 
....................            int16       OR_mask            Echo or OR mask 
.................... Output:    void 
.................... */ 
.................... void modbus_mask_write_register_rsp(int8 address, int16 reference_address, 
....................                            int16 AND_mask, int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16*      data               Pointer to an array of data 
....................            int8        data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_read_write_multiple_registers_rsp(int8 address, int8 data_len,  
....................                                                 int16 *data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(data_len*2); 
....................  
....................    for(i=0; i < data_len*2; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       FIFO_len           Length of FIFO in bytes 
....................            int16*      data               Pointer to an array of data 
.................... Output:    void 
.................... */ 
.................... void modbus_read_FIFO_queue_rsp(int8 address, int16 FIFO_len, int16 *data) 
.................... { 
....................    int8 i; 
....................    int16 byte_count; 
....................  
....................    byte_count = ((FIFO_len*2)+2); 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(byte_count, 1)); 
....................    modbus_serial_putc(make8(byte_count, 0)); 
....................  
....................    modbus_serial_putc(make8(FIFO_len, 1)); 
....................    modbus_serial_putc(make8(FIFO_len, 0)); 
....................  
....................    for(i=0; i < FIFO_len; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... void modbus_exception_rsp(int8 address, int16 func, exception error) 
.................... { 
....................    modbus_serial_send_start(address, func|0x80); 
....................    modbus_serial_putc(error); 
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... #define MODBUS_SLAVE_ADDRESS 0x01 
....................  
.................... // Variables para Pt100 
.................... int8 instruccion=0,address=0,regl=0,regh=0,i=0; 
.................... int16 reg=0; 
....................  
.................... int8 fstate;                     //Guardara el estado del bus I2C 
.................... int8 posicion, buffer[50], txbuf[50],rxbuf[50];     //Buffer de memoria 
....................  
.................... #INT_SSP 
.................... void ssp_interupt (){ 
....................     
....................    int incoming;                //Variable donde se recibe el byte que manda el maestro 
....................     
....................    fstate = i2c_isr_state();    //Lectura del estado del bus I2c la interrupción 
*
0408:  BTFSC  FC7.5
040A:  BRA    0414
040C:  MOVLB  4
040E:  CLRF   xC2
0410:  BTFSC  FC7.2
0412:  BSF    xC2.7
0414:  MOVLB  4
0416:  MOVF   xC2,W
0418:  INCF   xC2,F
041A:  MOVWF  x2A
....................  
....................    /* Solicitud de lectura del esclavo por el master */ 
....................    if(fstate == 0x80) {          
041C:  MOVF   x2A,W
041E:  SUBLW  80
0420:  BNZ   0440
....................        //Manda al maestro la información contenida en la posición de memoria que le ha solicitado 
....................       i2c_write (txbuf[posicion]); 
0422:  CLRF   03
0424:  MOVF   x2B,W
0426:  ADDLW  5E
0428:  MOVWF  FE9
042A:  MOVLW  04
042C:  ADDWFC 03,W
042E:  MOVWF  FEA
0430:  MOVFF  FEF,4D3
0434:  MOVFF  4D3,4D4
0438:  MOVLB  0
043A:  BRA    03F0
....................    } 
.................... /* Sino está solicitando lectura es que está enviando algo */ 
....................    else {                              //Sino es que hay dato en el bus I2C... 
043C:  BRA    0470
043E:  MOVLB  4
....................       incoming = i2c_read();           //... lo lee 
0440:  BCF    FC6.6
0442:  BTFSS  F9E.3
0444:  BRA    0442
0446:  MOVF   FC9,W
0448:  BSF    FC6.4
044A:  MOVWF  xD2
....................       if (fState == 1) {          //Información recibida corresponde a la posicion 
044C:  DECFSZ x2A,W
044E:  BRA    0456
....................          posicion = incoming;          //Se guarda posición 
0450:  MOVFF  4D2,42B
....................       } 
....................       else if (fState == 2) {          //Información recibida corresponde al dato 
0454:  BRA    046E
0456:  MOVF   x2A,W
0458:  SUBLW  02
045A:  BNZ   046E
....................          rxbuf[posicion] = incoming; 
045C:  CLRF   03
045E:  MOVF   x2B,W
0460:  ADDLW  90
0462:  MOVWF  FE9
0464:  MOVLW  04
0466:  ADDWFC 03,W
0468:  MOVWF  FEA
046A:  MOVFF  4D2,FEF
046E:  MOVLB  0
....................       } 
....................   } 
.................... } 
....................  
0470:  BCF    F9E.3
0472:  GOTO   006C
.................... void Lee_Vector(void){ 
....................    instruccion=rxbuf[0]; 
*
08A6:  MOVFF  490,423
....................    address=rxbuf[1]; 
08AA:  MOVFF  491,424
....................    regl=rxbuf[2]; 
08AE:  MOVFF  492,425
....................    regh=rxbuf[3]; 
08B2:  MOVFF  493,426
....................    reg=(regh*256)+regl; 
08B6:  MOVLB  4
08B8:  CLRF   xC4
08BA:  MOVFF  426,4C3
08BE:  MOVLW  01
08C0:  MOVWF  xC6
08C2:  CLRF   xC5
08C4:  MOVLB  0
08C6:  BRA    0882
08C8:  MOVLB  4
08CA:  MOVF   x25,W
08CC:  ADDWF  01,W
08CE:  MOVWF  x28
08D0:  MOVLW  00
08D2:  ADDWFC 02,W
08D4:  MOVWF  x29
.................... } 
08D6:  MOVLB  0
08D8:  RETLW  00
....................  
.................... /*This function may come in handy for you since MODBUS uses MSB first.*/ 
.................... int8 swap_bits(int8 c) 
.................... { 
....................    return ((c&1)?128:0)|((c&2)?64:0)|((c&4)?32:0)|((c&8)?16:0)|((c&16)?8:0) 
....................           |((c&32)?4:0)|((c&64)?2:0)|((c&128)?1:0); 
.................... } 
....................  
.................... void print_menu() 
.................... { 
....................    DEBUG_MSG("\r\nPick command to send\r\n1. Read all coils.\r\n"); 
....................    DEBUG_MSG("2. Read all inputs.\r\n3. Read all holding registers.\r\n"); 
....................    DEBUG_MSG("4. Read all input registers.\r\n5. Turn coil 6 on.\r\n6. "); 
....................    DEBUG_MSG("Write 0x4444 to register 0x03\r\n7. Set 8 coils using 0x50 as mask\r\n"); 
....................    DEBUG_MSG("8. Set 2 registers to 0x1111, 0x2222\r\n9. Send unknown command\r\n"); 
.................... } 
....................  
.................... void read_all_coils() 
.................... { 
....................    DEBUG_MSG("Coils:\r\n"); 
....................    if(!(modbus_read_coils(MODBUS_SLAVE_ADDRESS,0,8))) 
....................    { 
....................       DEBUG_MSG("Data: "); 
....................       /*Started at 1 since 0 is quantity of coils*/ 
....................       for(i=1; i < (modbus_rx.len); ++i) 
....................          DEBUG_DATA("%X ", modbus_rx.data[i]); 
....................       DEBUG_MSG("\r\n\r\n"); 
....................    } 
....................    else 
....................    { 
....................       DEBUG_DATA("<-**Exception %X**->\r\n\r\n", modbus_rx.error); 
....................    } 
.................... } 
....................  
.................... void read_all_inputs() 
.................... { 
....................    DEBUG_MSG("Inputs:\r\n"); 
....................    if(!(modbus_read_discrete_input(MODBUS_SLAVE_ADDRESS,0,8))) 
....................    { 
....................       DEBUG_MSG("Data: "); 
....................       /*Started at 1 since 0 is quantity of coils*/ 
....................       for(i=1; i < (modbus_rx.len); ++i) 
....................          DEBUG_DATA("%X ", modbus_rx.data[i]); 
....................       DEBUG_MSG("\r\n\r\n"); 
....................    } 
....................    else 
....................    { 
....................       DEBUG_DATA("<-**Exception %X**->\r\n\r\n", modbus_rx.error); 
....................    } 
.................... } 
....................  
.................... void read_all_holding(int8 start,int8 size) 
.................... { 
....................    DEBUG_MSG("Holding Registers:\r\n"); 
*
0B2A:  MOVLW  F8
0B2C:  MOVWF  FF6
0B2E:  MOVLW  05
0B30:  MOVWF  FF7
0B32:  RCALL  083E
....................    if(!(modbus_read_holding_registers(MODBUS_SLAVE_ADDRESS,start,size))) 
0B34:  MOVLW  01
0B36:  MOVLB  4
0B38:  MOVWF  xC5
0B3A:  CLRF   xC7
0B3C:  MOVFF  4C3,4C6
0B40:  CLRF   xC9
0B42:  MOVFF  4C4,4C8
0B46:  MOVLB  0
0B48:  BRA    0A4E
0B4A:  MOVF   01,F
0B4C:  BNZ   0BCC
....................    { 
....................       DEBUG_MSG("Data: "); 
0B4E:  MOVLW  0E
0B50:  MOVWF  FF6
0B52:  MOVLW  06
0B54:  MOVWF  FF7
0B56:  RCALL  083E
....................       /*Started at 1 since 0 is quantity of coils*/ 
....................       for(i=1; i < (modbus_rx.len); ++i){ 
0B58:  MOVLW  01
0B5A:  MOVLB  4
0B5C:  MOVWF  x27
0B5E:  MOVF   21,W
0B60:  SUBWF  x27,W
0B62:  BC    0BBE
....................          DEBUG_DATA("%X ", modbus_rx.data[i]); 
0B64:  MOVLW  24
0B66:  ADDWF  x27,W
0B68:  MOVWF  FE9
0B6A:  CLRF   FEA
0B6C:  BTFSC  FD8.0
0B6E:  INCF   FEA,F
0B70:  MOVFF  FEF,4C5
0B74:  MOVFF  4C5,4C8
0B78:  MOVLW  37
0B7A:  MOVWF  xC9
0B7C:  MOVLB  0
0B7E:  RCALL  0AE4
0B80:  MOVLW  20
0B82:  MOVLB  4
0B84:  MOVWF  xCA
0B86:  MOVLB  0
0B88:  RCALL  07FA
....................          if(i<20) 
0B8A:  MOVLB  4
0B8C:  MOVF   x27,W
0B8E:  SUBLW  13
0B90:  BNC   0BBA
....................             txbuf[i]=modbus_rx.data[i]; 
0B92:  CLRF   03
0B94:  MOVF   x27,W
0B96:  ADDLW  5E
0B98:  MOVWF  01
0B9A:  MOVLW  04
0B9C:  ADDWFC 03,F
0B9E:  MOVLW  24
0BA0:  ADDWF  x27,W
0BA2:  MOVWF  FE9
0BA4:  CLRF   FEA
0BA6:  BTFSC  FD8.0
0BA8:  INCF   FEA,F
0BAA:  MOVFF  FEF,4C7
0BAE:  MOVFF  03,FEA
0BB2:  MOVFF  01,FE9
0BB6:  MOVFF  4C7,FEF
....................       } 
0BBA:  INCF   x27,F
0BBC:  BRA    0B5E
....................       DEBUG_MSG("\r\n\r\n"); 
0BBE:  MOVLW  16
0BC0:  MOVWF  FF6
0BC2:  MOVLW  06
0BC4:  MOVWF  FF7
0BC6:  MOVLB  0
0BC8:  RCALL  083E
....................    }  
....................    else 
0BCA:  BRA    0C02
....................    { 
....................       DEBUG_DATA("<-**Exception %X**->\r\n\r\n", modbus_rx.error); 
0BCC:  MOVLW  1C
0BCE:  MOVWF  FF6
0BD0:  MOVLW  06
0BD2:  MOVWF  FF7
0BD4:  MOVLW  0E
0BD6:  MOVLB  4
0BD8:  MOVWF  xC7
0BDA:  MOVLB  0
0BDC:  RCALL  08DA
0BDE:  MOVFF  23,4C8
0BE2:  MOVLW  37
0BE4:  MOVLB  4
0BE6:  MOVWF  xC9
0BE8:  MOVLB  0
0BEA:  RCALL  0AE4
0BEC:  MOVLW  2C
0BEE:  MOVWF  FF6
0BF0:  MOVLW  06
0BF2:  MOVWF  FF7
0BF4:  MOVLW  08
0BF6:  MOVLB  4
0BF8:  MOVWF  xC7
0BFA:  MOVLB  0
0BFC:  RCALL  08DA
....................       output_bit(PIN_B7,1); 
0BFE:  BSF    F8A.7
0C00:  BCF    F93.7
....................    } 
.................... } 
0C02:  GOTO   0E42 (RETURN)
....................  
.................... void read_all_input_reg(int8 start,int8 size) 
.................... { 
....................    DEBUG_MSG("Input Registers:\r\n"); 
....................    if(!(modbus_read_input_registers(MODBUS_SLAVE_ADDRESS,start,size))) 
....................    { 
....................       DEBUG_MSG("Data: "); 
....................       /*Started at 1 since 0 is quantity of coils*/ 
....................       for(i=1; i < (modbus_rx.len); ++i) 
....................          DEBUG_DATA("%X ", modbus_rx.data[i]);        
....................         
....................        DEBUG_MSG("\r\n\r\n"); 
....................  
....................    } 
....................    else 
....................    { 
....................       DEBUG_DATA("<-**Exception %X**->\r\n\r\n", modbus_rx.error); 
....................       output_bit(PIN_B7,1); 
....................    } 
.................... } 
....................  
.................... void write_coil() 
.................... { 
....................    DEBUG_MSG("Writing Single Coil:\r\n"); 
....................    if(!(modbus_write_single_coil(MODBUS_SLAVE_ADDRESS,6,TRUE))) 
....................    { 
....................       DEBUG_MSG("Data: "); 
....................       for(i=0; i < (modbus_rx.len); ++i) 
....................          DEBUG_DATA("%X ", modbus_rx.data[i]); 
....................       DEBUG_MSG("\r\n\r\n"); 
....................    } 
....................    else 
....................    { 
....................       DEBUG_DATA("<-**Exception %X**->\r\n\r\n", modbus_rx.error); 
....................    }    
.................... } 
....................  
.................... void write_reg(int16 address,int16 reg) 
.................... { 
....................    DEBUG_MSG("Writing Single Register:\r\n"); 
*
0C9C:  MOVLW  B2
0C9E:  MOVWF  FF6
0CA0:  MOVLW  06
0CA2:  MOVWF  FF7
0CA4:  RCALL  083E
....................    if(!(modbus_write_single_register(MODBUS_SLAVE_ADDRESS,address,reg))) 
0CA6:  MOVLW  01
0CA8:  MOVLB  4
0CAA:  MOVWF  xC7
0CAC:  MOVFF  4C4,4C9
0CB0:  MOVFF  4C3,4C8
0CB4:  MOVFF  4C6,4CB
0CB8:  MOVFF  4C5,4CA
0CBC:  MOVLB  0
0CBE:  BRA    0C06
0CC0:  MOVF   01,F
0CC2:  BNZ   0D12
....................    { 
....................       DEBUG_MSG("Data: "); 
0CC4:  MOVLW  CE
0CC6:  MOVWF  FF6
0CC8:  MOVLW  06
0CCA:  MOVWF  FF7
0CCC:  RCALL  083E
....................       for(i=0; i < (modbus_rx.len); ++i) 
0CCE:  MOVLB  4
0CD0:  CLRF   x27
0CD2:  MOVF   21,W
0CD4:  SUBWF  x27,W
0CD6:  BC    0D04
....................          DEBUG_DATA("%X ", modbus_rx.data[i]); 
0CD8:  MOVLW  24
0CDA:  ADDWF  x27,W
0CDC:  MOVWF  FE9
0CDE:  CLRF   FEA
0CE0:  BTFSC  FD8.0
0CE2:  INCF   FEA,F
0CE4:  MOVFF  FEF,4C7
0CE8:  MOVFF  4C7,4C8
0CEC:  MOVLW  37
0CEE:  MOVWF  xC9
0CF0:  MOVLB  0
0CF2:  RCALL  0AE4
0CF4:  MOVLW  20
0CF6:  MOVLB  4
0CF8:  MOVWF  xCA
0CFA:  MOVLB  0
0CFC:  RCALL  07FA
0CFE:  MOVLB  4
0D00:  INCF   x27,F
0D02:  BRA    0CD2
....................       DEBUG_MSG("\r\n\r\n"); 
0D04:  MOVLW  D6
0D06:  MOVWF  FF6
0D08:  MOVLW  06
0D0A:  MOVWF  FF7
0D0C:  MOVLB  0
0D0E:  RCALL  083E
....................    } 
....................    else 
0D10:  BRA    0D48
....................    { 
....................       DEBUG_DATA("<-**Exception %X**->\r\n\r\n", modbus_rx.error); 
0D12:  MOVLW  DC
0D14:  MOVWF  FF6
0D16:  MOVLW  06
0D18:  MOVWF  FF7
0D1A:  MOVLW  0E
0D1C:  MOVLB  4
0D1E:  MOVWF  xC7
0D20:  MOVLB  0
0D22:  RCALL  08DA
0D24:  MOVFF  23,4C8
0D28:  MOVLW  37
0D2A:  MOVLB  4
0D2C:  MOVWF  xC9
0D2E:  MOVLB  0
0D30:  RCALL  0AE4
0D32:  MOVLW  EC
0D34:  MOVWF  FF6
0D36:  MOVLW  06
0D38:  MOVWF  FF7
0D3A:  MOVLW  08
0D3C:  MOVLB  4
0D3E:  MOVWF  xC7
0D40:  MOVLB  0
0D42:  RCALL  08DA
....................       output_bit(PIN_B7,1); 
0D44:  BSF    F8A.7
0D46:  BCF    F93.7
....................    } 
.................... } 
0D48:  GOTO   0E5C (RETURN)
....................  
.................... void write_coils() 
.................... { 
....................    int8 coils[1] = { 0x50 }; 
....................    DEBUG_MSG("Writing Multiple Coils:\r\n"); 
....................    if(!(modbus_write_multiple_coils(MODBUS_SLAVE_ADDRESS,0,8,coils))) 
....................    { 
....................       DEBUG_MSG("Data: "); 
....................       for(i=0; i < (modbus_rx.len); ++i) 
....................          DEBUG_DATA("%X ", modbus_rx.data[i]); 
....................       DEBUG_MSG("\r\n\r\n"); 
....................    } 
....................    else 
....................    { 
....................       DEBUG_DATA("<-**Exception %X**->\r\n\r\n", modbus_rx.error); 
....................    }    
.................... } 
....................  
.................... void write_regs() 
.................... { 
....................    int16 reg_array[2] = {0x1111, 0x2222}; 
....................    DEBUG_MSG("Writing Multiple Registers:\r\n"); 
....................    if(!(modbus_write_multiple_registers(MODBUS_SLAVE_ADDRESS,0,2,reg_array))) 
....................    { 
....................       DEBUG_MSG("Data: "); 
....................       for(i=0; i < (modbus_rx.len); ++i) 
....................          DEBUG_DATA("%X ", modbus_rx.data[i]); 
....................       DEBUG_MSG("\r\n\r\n"); 
....................    } 
....................    else 
....................    { 
....................       DEBUG_DATA("<-**Exception %X**->\r\n\r\n", modbus_rx.error); 
....................    }    
.................... } 
....................  
.................... void unknown_func() 
.................... { 
....................    DEBUG_MSG("Trying unknown function\r\n"); 
....................    DEBUG_MSG("Diagnostic:\r\n"); 
....................    if(!(modbus_diagnostics(MODBUS_SLAVE_ADDRESS,0,0))) 
....................    { 
....................       DEBUG_MSG("Data:"); 
....................       for(i=0; i < (modbus_rx.len); ++i) 
....................          DEBUG_DATA("%X ", modbus_rx.data[i]); 
....................       DEBUG_MSG("\r\n\r\n"); 
....................    } 
....................    else 
....................    { 
....................       DEBUG_DATA("<-**Exception %X**->\r\n\r\n", modbus_rx.error); 
....................    } 
.................... } 
....................  
....................  
.................... void main() 
.................... { 
0D4C:  CLRF   FF8
0D4E:  BCF    FD0.7
0D50:  BSF    07.7
0D52:  CLRF   FEA
0D54:  CLRF   FE9
0D56:  BSF    F93.1
0D58:  BSF    F93.0
0D5A:  MOVLW  B0
0D5C:  MOVWF  FC8
0D5E:  MOVLW  36
0D60:  MOVWF  FC6
0D62:  BCF    F93.4
0D64:  BSF    F8A.4
0D66:  BCF    FB8.3
0D68:  MOVLW  19
0D6A:  MOVWF  FAF
0D6C:  MOVLW  A6
0D6E:  MOVWF  FAC
0D70:  MOVLW  90
0D72:  MOVWF  FAB
0D74:  CLRF   1B
0D76:  CLRF   1A
0D78:  MOVLW  27
0D7A:  MOVWF  19
0D7C:  MOVLW  10
0D7E:  MOVWF  18
0D80:  BCF    1C.0
0D82:  CLRF   1D
0D84:  MOVLB  4
0D86:  CLRF   x23
0D88:  CLRF   x24
0D8A:  CLRF   x25
0D8C:  CLRF   x26
0D8E:  CLRF   x27
0D90:  CLRF   x29
0D92:  CLRF   x28
0D94:  MOVF   FC1,W
0D96:  ANDLW  C0
0D98:  IORLW  0F
0D9A:  MOVWF  FC1
0D9C:  MOVLW  07
0D9E:  MOVWF  FB4
0DA0:  CLRF   17
0DA2:  MOVLW  03
0DA4:  MOVWF  xC2
....................    fState = 0; 
0DA6:  CLRF   x2A
....................    for (posicion=0;posicion<0x10;posicion++){ 
0DA8:  CLRF   x2B
0DAA:  MOVF   x2B,W
0DAC:  SUBLW  0F
0DAE:  BNC   0DE4
....................       buffer[posicion] = 0x00; 
0DB0:  CLRF   03
0DB2:  MOVF   x2B,W
0DB4:  ADDLW  2C
0DB6:  MOVWF  FE9
0DB8:  MOVLW  04
0DBA:  ADDWFC 03,W
0DBC:  MOVWF  FEA
0DBE:  CLRF   FEF
....................       txbuf[posicion] = 0x00; 
0DC0:  CLRF   03
0DC2:  MOVF   x2B,W
0DC4:  ADDLW  5E
0DC6:  MOVWF  FE9
0DC8:  MOVLW  04
0DCA:  ADDWFC 03,W
0DCC:  MOVWF  FEA
0DCE:  CLRF   FEF
....................       rxbuf[posicion] = 0x00; 
0DD0:  CLRF   03
0DD2:  MOVF   x2B,W
0DD4:  ADDLW  90
0DD6:  MOVWF  FE9
0DD8:  MOVLW  04
0DDA:  ADDWFC 03,W
0DDC:  MOVWF  FEA
0DDE:  CLRF   FEF
....................    } 
0DE0:  INCF   x2B,F
0DE2:  BRA    0DAA
....................    DEBUG_MSG("\r\nInitializing..."); 
0DE4:  MOVLW  CC
0DE6:  MOVWF  FF6
0DE8:  MOVLW  07
0DEA:  MOVWF  FF7
0DEC:  MOVLB  0
0DEE:  RCALL  083E
....................    modbus_init(); 
0DF0:  BRA    086A
....................    DEBUG_MSG("...ready\r\n"); 
0DF2:  MOVLW  DE
0DF4:  MOVWF  FF6
0DF6:  MOVLW  07
0DF8:  MOVWF  FF7
0DFA:  RCALL  083E
....................    Lee_Vector(); 
0DFC:  RCALL  08A6
....................    enable_interrupts(INT_SSP); 
0DFE:  BSF    F9D.3
....................    enable_interrupts(global); 
0E00:  MOVLW  C0
0E02:  IORWF  FF2,F
....................     
....................  
.................... while(true) 
.................... { 
....................    DEBUG_DATA("Address: %02u ", address); 
0E04:  MOVLW  EA
0E06:  MOVWF  FF6
0E08:  MOVLW  07
0E0A:  MOVWF  FF7
0E0C:  MOVLW  09
0E0E:  MOVLB  4
0E10:  MOVWF  xC7
0E12:  MOVLB  0
0E14:  RCALL  08DA
0E16:  MOVFF  424,4C3
0E1A:  MOVLW  01
0E1C:  MOVLB  4
0E1E:  MOVWF  xC4
0E20:  MOVLB  0
0E22:  BRA    092E
0E24:  MOVLW  20
0E26:  MOVLB  4
0E28:  MOVWF  xCA
0E2A:  MOVLB  0
0E2C:  RCALL  07FA
....................    Lee_Vector();    
0E2E:  RCALL  08A6
....................    if(instruccion==3){ 
0E30:  MOVLB  4
0E32:  MOVF   x23,W
0E34:  SUBLW  03
0E36:  BNZ   0E44
....................       read_all_holding(0,8); 
0E38:  CLRF   xC3
0E3A:  MOVLW  08
0E3C:  MOVWF  xC4
0E3E:  MOVLB  0
0E40:  BRA    0B2A
0E42:  MOVLB  4
....................    } 
....................    if(instruccion==5){ 
0E44:  MOVF   x23,W
0E46:  SUBLW  05
0E48:  BNZ   0E5C
....................       write_reg(address,reg); 
0E4A:  CLRF   xC4
0E4C:  MOVFF  424,4C3
0E50:  MOVFF  429,4C6
0E54:  MOVFF  428,4C5
0E58:  MOVLB  0
0E5A:  BRA    0C9C
....................    }   
.................... } 
0E5C:  MOVLB  0
0E5E:  BRA    0E04
.................... } 
0E60:  SLEEP 

Configuration Fuses:
   Word  1: 0218   XTPLL NOIESO NOFCMEN PLL1 CPUDIV4 NOUSBDIV
   Word  2: 1E19   NOBROWNOUT NOWDT BORV20 NOPUT WDT32768 NOVREGEN
   Word  3: 0100   NOPBADEN CCP2C1 NOMCLR NOLPT1OSC
   Word  4: 0080   NOSTVREN NODEBUG NOLVP NOXINST
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
